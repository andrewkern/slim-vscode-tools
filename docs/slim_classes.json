{
    "Chromosome": {
        "constructor": {},
        "methods": {
            "ancestralNucleotides": {
                "signature": "(is)ancestralNucleotides([Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL], [string$\u00a0format\u00a0=\u00a0\"string\"])",
                "description": " Returns the ancestral nucleotide sequence originally supplied to initializeAncestralNucleotides(), including any sequence changes due to nucleotide mutations that have fixed and substituted.\u00a0 This nucleotide sequence is the reference sequence for positions in a genome that do not contain a nucleotide-based mutation.\u00a0 The range of the returned sequence may be constrained by a start position given in start and/or an end position given in end; nucleotides will be returned from start to end, inclusive.\u00a0 The default value of NULL for start and end represent the first and last base positions of the chromosome, respectively. The format of the returned sequence is controlled by the format parameter.\u00a0 A format of \"string\" will return the sequence as a singleton string (e.g., \"TATA\").\u00a0 A format of \"char\" will return a string vector with one element per nucleotide (e.g., \"T\", \"A\", \"T\", \"A\").\u00a0 A format of \"integer\" will return an integer vector with values A=0, C=1, G=2, T=3 (e.g., 3, 0, 3, 0).\u00a0 If the sequence returned is likely to be long, the \"string\" format will be the most memory-efficient, and may also be the fastest (but may be harder to work with). For purposes related to interpreting the nucleotide sequence as a coding sequence, a format of \"codon\" is also supported.\u00a0 This format will return an integer vector with values from 0 to 63, based upon successive nucleotide triplets in the sequence (which, for this format, must have a length that is a multiple of three).\u00a0 The codon value for a given nucleotide triplet XYZ is 16X\u00a0+\u00a04Y\u00a0+\u00a0Z, where X, Y, and Z have the usual values A=0, C=1, G=2, T=3.\u00a0 For example, the triplet AAA has a codon value of 0, AAC is 1, AAG is 2, AAT is 3, ACA is 4, and on upward to TTT which is 63.\u00a0 If the nucleotide sequence AACACATTT is requested in codon format, the codon vector 1 4 63 will therefore be returned.\u00a0 These codon values can be useful in themselves; they can also be passed to codonToAminoAcid() to translate them into the corresponding amino acid sequence if desired."
            },
            "drawBreakpoints": {
                "signature": "(integer)drawBreakpoints([No<Individual>$\u00a0parent\u00a0=\u00a0NULL], [Ni$\u00a0n\u00a0=\u00a0NULL])",
                "description": " Draw recombination breakpoints, using the chromosome\u2019s recombination rate map, the current gene conversion parameters, and (in some cases \u2013 see below) any active and applicable recombination() callbacks.\u00a0 The number of breakpoints to generate, n, may be supplied; if it is NULL (the default), the number of breakpoints will be drawn based upon the overall recombination rate and the chromosome length (following the standard procedure in SLiM).\u00a0 Note that if the double-stranded breaks model has been chosen, the number of breakpoints generated will probably not be equal to the number requested, because most breakpoints will entail gene conversion tracts, which entail additional crossover breakpoints. It is generally recommended that the parent individual be supplied to this method, but parent is NULL by default.\u00a0 The individual supplied in parent is used for two purposes.\u00a0 First, in sexual models that define separate recombination rate maps for males versus females, the sex of parent will be used to determine which map is used; in this case, a non-NULL value must be supplied for parent, since the choice of recombination rate map must be determined.\u00a0 Second, in models that define recombination() callbacks, parent is used to determine the various pseudo-parameters that are passed to recombination() callbacks (individual, genome1, genome2, subpop), and the subpopulation to which parent belongs is used to select which recombination() callbacks are applicable; given the necessity of this information, recombination() callbacks will not be called as a side effect of this method if parent is NULL.\u00a0 Apart from these two uses, parent is not used, and the caller does not guarantee that the generated breakpoints will actually be used to recombine the genomes of parent in particular.\u00a0 If a recombination() callback is called, genome1 for that callback will always be parent.genome1; in other words, drawBreakpoints() will always treat parent.genome1 as the initial copy strand.\u00a0 If the caller wishes to randomly choose an initial copy strand (which is usually desirable), they should do that themselves."
            },
            "genomicElementForPosition": {
                "signature": "(object<GenomicElement>)genomicElementForPosition(integer\u00a0positions)",
                "description": " Returns a vector of GenomicElement objects corresponding to the given vector positions, which contains base positions along the chromosome.\u00a0 If every position lies within a defined genomic element, the returned vector will have the same length as positions, and will correspond one-to-one with it.\u00a0 However, if a position in positions is not within a genomic element, no GenomicElement object will be present for it in the returned vector, and so the returned vector will no longer have the same length as positions, and will no longer correspond one-to-one with it.\u00a0 The method hasGenomicElementForPosition() can be used to detect this circumstance."
            },
            "hasGenomicElementForPosition": {
                "signature": "(logical)hasGenomicElementForPosition(integer\u00a0positions)",
                "description": " Returns a logical vector corresponding to the given vector positions, which contains base positions along the chromosome.\u00a0 The returned vector will have the same length as positions, and will correspond one-to-one with it, containing T if the corresponding position lies inside a genomic element, or F if it does not.\u00a0 The method genomicElementForPosition() can be used to look up the GenomicElement objects themselves."
            },
            "setAncestralNucleotides": {
                "signature": "(integer$)setAncestralNucleotides(is\u00a0sequence)",
                "description": " This method, which may be called only in nucleotide-based models, replaces the ancestral nucleotide sequence for the model.\u00a0 The sequence parameter is interpreted exactly as it is in the initializeAncestralSequence() function; see that documentation for details.\u00a0 The length of the ancestral sequence is returned. It is unusual to replace the ancestral sequence in a running simulation, since the nucleotide states of segregating and fixed mutations will depend upon the original ancestral sequence.\u00a0 It can be useful when loading a new population state with readFromMS() or readFromVCF(), such as when resetting the simulation state to an earlier state in a conditional simulation; however, that is more commonly done using readFromPopulationFile() with a SLiM or .trees file."
            },
            "setGeneConversion": {
                "signature": "(void)setGeneConversion(numeric$\u00a0nonCrossoverFraction, numeric$\u00a0meanLength, numeric$\u00a0simpleConversionFraction, [numeric$\u00a0bias\u00a0=\u00a00])",
                "description": " This method switches the recombination model to the \u201cdouble-stranded break (DSB)\u201d model (if it is not already set to that), and configures the details of the gene conversion tracts that will therefore be modeled.\u00a0 The meanings and effects of the parameters exactly mirror the initializeGeneConversion() function."
            },
            "setHotspotMap": {
                "signature": "(void)setHotspotMap(numeric\u00a0multipliers, [Ni\u00a0ends\u00a0=\u00a0NULL], [string$\u00a0sex\u00a0=\u00a0\"*\"])",
                "description": " In nucleotide-based models, set the mutation rate multiplier along the chromosome.\u00a0 There are two ways to call this method.\u00a0 If the optional ends parameter is NULL (the default), then multipliers must be a singleton value that specifies a single multiplier to be used along the entire chromosome.\u00a0 If, on the other hand, ends is supplied, then multipliers and ends must be the same length, and the values in ends must be specified in ascending order.\u00a0 In that case, multipliers and ends taken together specify the multipliers to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in ends should extend to the end of the chromosome (as previously determined, during simulation initialization).\u00a0 See the initializeHotspotMap() function for further discussion of precisely how these multipliers and positions are interpreted. If the optional sex parameter is \"*\" (the default), then the supplied hotspot map will be used for both sexes (which is the only option for hermaphroditic simulations).\u00a0 In sexual simulations sex may be \"M\" or \"F\" instead, in which case the supplied hotspot map is used only for that sex.\u00a0 Note that whether sex-specific hotspot maps will be used is set by the way that the simulation is initially configured with initializeHotspot(), and cannot be changed with this method; so if the simulation was set up to use sex-specific hotspot maps then sex must be \"M\" or \"F\" here, whereas if it was set up not to, then sex must be \"*\" or unsupplied here.\u00a0 If a simulation needs sex-specific hotspot maps only some of the time, the male and female maps can simply be set to be identical the rest of the time. The hotspot map is normally constant in simulations, so be sure you know what you are doing."
            },
            "setMutationRate": {
                "signature": "(void)setMutationRate(numeric\u00a0rates, [Ni\u00a0ends\u00a0=\u00a0NULL], [string$\u00a0sex\u00a0=\u00a0\"*\"])",
                "description": " Set the mutation rate per base position per gamete.\u00a0 There are two ways to call this method.\u00a0 If the optional ends parameter is NULL (the default), then rates must be a singleton value that specifies a single mutation rate to be used along the entire chromosome.\u00a0 If, on the other hand, ends is supplied, then rates and ends must be the same length, and the values in ends must be specified in ascending order.\u00a0 In that case, rates and ends taken together specify the mutation rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in ends should extend to the end of the chromosome (as previously determined, during simulation initialization).\u00a0 See the initializeMutationRate() function for further discussion of precisely how these rates and positions are interpreted. If the optional sex parameter is \"*\" (the default), then the supplied mutation rate map will be used for both sexes (which is the only option for hermaphroditic simulations).\u00a0 In sexual simulations sex may be \"M\" or \"F\" instead, in which case the supplied mutation rate map is used only for that sex.\u00a0 Note that whether sex-specific mutation rate maps will be used is set by the way that the simulation is initially configured with initializeMutationRate(), and cannot be changed with this method; so if the simulation was set up to use sex-specific mutation rate maps then sex must be \"M\" or \"F\" here, whereas if it was set up not to, then sex must be \"*\" or unsupplied here.\u00a0 If a simulation needs sex-specific mutation rate maps only some of the time, the male and female maps can simply be set to be identical the rest of the time. The mutation rate intervals are normally a constant in simulations, so be sure you know what you are doing. In nucleotide-based models, setMutationRate() may not be called.\u00a0 If variation in the mutation rate along the chromosome is desired, setHotspotMap() should be used."
            },
            "setRecombinationRate": {
                "signature": "(void)setRecombinationRate(numeric\u00a0rates, [Ni\u00a0ends\u00a0=\u00a0NULL], [string$\u00a0sex\u00a0=\u00a0\"*\"])",
                "description": " Set the recombination rate per base position per gamete.\u00a0 All rates must be in the interval [0.0, 0.5].\u00a0 There are two ways to call this method.\u00a0 If the optional ends parameter is NULL (the default), then rates must be a singleton value that specifies a single recombination rate to be used along the entire chromosome.\u00a0 If, on the other hand, ends is supplied, then rates and ends must be the same length, and the values in ends must be specified in ascending order.\u00a0 In that case, rates and ends taken together specify the recombination rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in ends should extend to the end of the chromosome (as previously determined, during simulation initialization).\u00a0 See the initializeRecombinationRate() function for further discussion of precisely how these rates and positions are interpreted. If the optional sex parameter is \"*\" (the default), then the supplied recombination rate map will be used for both sexes (which is the only option for hermaphroditic simulations).\u00a0 In sexual simulations sex may be \"M\" or \"F\" instead, in which case the supplied recombination map is used only for that sex.\u00a0 Note that whether sex-specific recombination maps will be used is set by the way that the simulation is initially configured with initializeRecombinationRate(), and cannot be changed with this method; so if the simulation was set up to use sex-specific recombination maps then sex must be \"M\" or \"F\" here, whereas if it was set up not to, then sex must be \"*\" or unsupplied here.\u00a0 If a simulation needs sex-specific recombination maps only some of the time, the male and female maps can simply be set to be identical the rest of the time. The recombination intervals are normally a constant in simulations, so be sure you know what you are doing."
            }
        },
        "properties": {
            "colorSubstitution": {
                "type": "string$",
                "description": " The color used to display substitutions in SLiMgui when both mutations and substitutions are being displayed in the chromosome view.\u00a0 Outside of SLiMgui, this property still exists, but is not used by SLiM.\u00a0 Colors may be specified by name, or with hexadecimal RGB values of the form \"#RRGGBB\".\u00a0 If colorSubstitution is the empty string, \"\", SLiMgui will defer to the color scheme of each MutationType, just as it does when only substitutions are being displayed.\u00a0 The default, \"3333FF\", causes all substitutions to be shown as dark blue when displayed in conjunction with mutations, to prevent the view from becoming too noisy.\u00a0 Note that when substitutions are displayed without mutations also being displayed, this value is ignored by SLiMgui and the substitutions use the color scheme of each MutationType."
            },
            "geneConversionEnabled": {
                "type": "logical$",
                "description": " When gene conversion has been enabled by calling initializeGeneConversion(), switching to the DSB recombination model, this property is T; otherwise, when using the crossover breakpoints model, it is F."
            },
            "geneConversionGCBias": {
                "type": "float$",
                "description": " The gene conversion bias coefficient, which expresses a bias in the resolution of heteroduplex mismatches in complex gene conversion tracts.\u00a0 When gene conversion has not been enabled by calling initializeGeneConversion(), this property will be unavailable."
            },
            "geneConversionNonCrossoverFraction": {
                "type": "float$",
                "description": " The fraction of double-stranded breaks that result in non-crossover events.\u00a0 When gene conversion has not been enabled by calling initializeGeneConversion(), this property will be unavailable."
            },
            "geneConversionMeanLength": {
                "type": "float$",
                "description": " The mean length of a gene conversion tract (in base positions).\u00a0 When gene conversion has not been enabled by calling initializeGeneConversion(), this property will be unavailable."
            },
            "geneConversionSimpleConversionFraction": {
                "type": "float$",
                "description": " The fraction of gene conversion tracts that are \u201csimple\u201d (i.e., not involving resolution of heteroduplex mismatches); the remainder will be \u201ccomplex\u201d.\u00a0 When gene conversion has not been enabled by calling initializeGeneConversion(), this property will be unavailable."
            },
            "genomicElements": {
                "type": "object<GenomicElement>",
                "description": " All of the GenomicElement objects that comprise the chromosome, in sorted order (not necessarily in the order in which they were defined)."
            },
            "hotspotEndPositions": {
                "type": "integer",
                "description": " The end positions for hotspot map regions along the chromosome.\u00a0 Each hotspot map region is assumed to start at the position following the end of the previous hotspot map region; in other words, the regions are assumed to be contiguous.\u00a0 When using sex-specific hotspot maps, this property will unavailable; see hotspotEndPositionsF and hotspotEndPositionsM."
            },
            "hotspotEndPositionsF": {
                "type": "integer",
                "description": " The end positions for hotspot map regions for females, when using sex-specific hotspot maps; unavailable otherwise.\u00a0 See hotspotEndPositions for further explanation."
            },
            "hotspotEndPositionsM": {
                "type": "integer",
                "description": " The end positions for hotspot map regions for males, when using sex-specific hotspot maps; unavailable otherwise.\u00a0 See hotspotEndPositions for further explanation."
            },
            "hotspotMultipliers": {
                "type": "float",
                "description": " The hotspot multiplier for each of the hotspot map regions specified by hotspotEndPositions.\u00a0 When using sex-specific hotspot maps, this property will be unavailable; see hotspotMultipliersF and hotspotMultipliersM."
            },
            "hotspotMultipliersF": {
                "type": "float",
                "description": " The hotspot multiplier for each of the hotspot map regions specified by hotspotEndPositionsF, when using sex-specific hotspot maps; unavailable otherwise."
            },
            "hotspotMultipliersM": {
                "type": "float",
                "description": " The hotspot multiplier for each of the hotspot map regions specified by hotspotEndPositionsM, when using sex-specific hotspot maps; unavailable otherwise."
            },
            "lastPosition": {
                "type": "integer$",
                "description": " The last valid position in the chromosome; its length, essentially.\u00a0 Note that the chromosome length is determined by the maximum of the end of the last genomic element, the end of the last recombination region, and the end of the last mutation map region (or hotspot map region)."
            },
            "mutationEndPositions": {
                "type": "integer",
                "description": " The end positions for mutation rate regions along the chromosome.\u00a0 Each mutation rate region is assumed to start at the position following the end of the previous mutation rate region; in other words, the regions are assumed to be contiguous.\u00a0 When using sex-specific mutation rate maps, this property will unavailable; see mutationEndPositionsF and mutationEndPositionsM. This property is unavailable in nucleotide-based models."
            },
            "mutationEndPositionsF": {
                "type": "integer",
                "description": " The end positions for mutation rate regions for females, when using sex-specific mutation rate maps; unavailable otherwise.\u00a0 See mutationEndPositions for further explanation. This property is unavailable in nucleotide-based models."
            },
            "mutationEndPositionsM": {
                "type": "integer",
                "description": " The end positions for mutation rate regions for males, when using sex-specific mutation rate maps; unavailable otherwise.\u00a0 See mutationEndPositions for further explanation. This property is unavailable in nucleotide-based models."
            },
            "mutationRates": {
                "type": "float",
                "description": " The mutation rate for each of the mutation rate regions specified by mutationEndPositions.\u00a0 When using sex-specific mutation rate maps, this property will be unavailable; see mutationRatesF and mutationRatesM. This property is unavailable in nucleotide-based models."
            },
            "mutationRatesF": {
                "type": "float",
                "description": " The mutation rate for each of the mutation rate regions specified by mutationEndPositionsF, when using sex-specific mutation rate maps; unavailable otherwise. This property is unavailable in nucleotide-based models."
            },
            "mutationRatesM": {
                "type": "float",
                "description": " The mutation rate for each of the mutation rate regions specified by mutationEndPositionsM, when using sex-specific mutation rate maps; unavailable otherwise. This property is unavailable in nucleotide-based models."
            },
            "overallMutationRate": {
                "type": "float$",
                "description": " The overall mutation rate across the whole chromosome determining the overall number of mutation events that will occur anywhere in the chromosome, as calculated from the individual mutation ranges and rates as well as the coverage of the chromosome by genomic elements (since mutations are only generated within genomic elements, regardless of the mutation rate map).\u00a0 When using sex-specific mutation rate maps, this property will unavailable; see overallMutationRateF and overallMutationRateM. This property is unavailable in nucleotide-based models."
            },
            "overallMutationRateF": {
                "type": "float$",
                "description": " The overall mutation rate for females, when using sex-specific mutation rate maps; unavailable otherwise.\u00a0 See overallMutationRate for further explanation. This property is unavailable in nucleotide-based models."
            },
            "overallMutationRateM": {
                "type": "float$",
                "description": " The overall mutation rate for males, when using sex-specific mutation rate maps; unavailable otherwise.\u00a0 See overallMutationRate for further explanation. This property is unavailable in nucleotide-based models."
            },
            "overallRecombinationRate": {
                "type": "float$",
                "description": " The overall recombination rate across the whole chromosome determining the overall number of recombination events that will occur anywhere in the chromosome, as calculated from the individual recombination ranges and rates.\u00a0 When using sex-specific recombination maps, this property will unavailable; see overallRecombinationRateF and overallRecombinationRateM."
            },
            "overallRecombinationRateF": {
                "type": "float$",
                "description": " The overall recombination rate for females, when using sex-specific recombination maps; unavailable otherwise.\u00a0 See overallRecombinationRate for further explanation."
            },
            "overallRecombinationRateM": {
                "type": "float$",
                "description": " The overall recombination rate for males, when using sex-specific recombination maps; unavailable otherwise.\u00a0 See overallRecombinationRate for further explanation."
            },
            "recombinationEndPositions": {
                "type": "integer",
                "description": " The end positions for recombination regions along the chromosome.\u00a0 Each recombination region is assumed to start at the position following the end of the previous recombination region; in other words, the regions are assumed to be contiguous.\u00a0 When using sex-specific recombination maps, this property will unavailable; see recombinationEndPositionsF and recombinationEndPositionsM."
            },
            "recombinationEndPositionsF": {
                "type": "integer",
                "description": " The end positions for recombination regions for females, when using sex-specific recombination maps; unavailable otherwise.\u00a0 See recombinationEndPositions for further explanation."
            },
            "recombinationEndPositionsM": {
                "type": "integer",
                "description": " The end positions for recombination regions for males, when using sex-specific recombination maps; unavailable otherwise.\u00a0 See recombinationEndPositions for further explanation."
            },
            "recombinationRates": {
                "type": "float",
                "description": " The recombination rate for each of the recombination regions specified by recombinationEndPositions.\u00a0 When using sex-specific recombination maps, this property will unavailable; see recombinationRatesF and recombinationRatesM."
            },
            "recombinationRatesF": {
                "type": "float",
                "description": " The recombination rate for each of the recombination regions specified by recombinationEndPositionsF, when using sex-specific recombination maps; unavailable otherwise."
            },
            "recombinationRatesM": {
                "type": "float",
                "description": " The recombination rate for each of the recombination regions specified by recombinationEndPositionsM, when using sex-specific recombination maps; unavailable otherwise."
            },
            "species": {
                "type": "object<Species>$",
                "description": " The species to which the target object belongs."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use."
            }
        }
    },
    "Community": {
        "constructor": {},
        "methods": {
            "createLogFile": {
                "signature": "(object<LogFile>$)createLogFile(string$\u00a0filePath, [Ns\u00a0initialContents\u00a0=\u00a0NULL], [logical$\u00a0append\u00a0=\u00a0F], [logical$\u00a0compress\u00a0=\u00a0F], [string$\u00a0sep\u00a0=\u00a0\",\"], [Ni$\u00a0logInterval\u00a0=\u00a0NULL], [Ni$\u00a0flushInterval\u00a0=\u00a0NULL])",
                "description": " Creates and returns a new LogFile object that logs data from the simulation (see the documentation for the LogFile class for details).\u00a0 Logged data will be written to the file at filePath, overwriting any existing file at that path by default, or appending to it instead if append is T (successive rows of the log table will always be appended to the previously written content, of course).\u00a0 Before the header line for the log is written out, any string elements in initialContents will be written first, separated by newlines, allowing for a user-defined file header.\u00a0 If compress is T, the contents will be compressed with zlib as they are written, and the standard .gz extension for gzip-compressed files will be appended to the filename in filePath if it is not already present. The sep parameter specifies the separator between data values within a row.\u00a0 The default of \",\" will generate a \u201ccomma-separated value\u201d (CSV) file, while passing sep=\"\\t\" will use a tab separator instead to generate a \u201ctab-separated value\u201d (TSV) file.\u00a0 Other values for sep may also be used, but are less standard. LogTable supports periodic automatic logging of a new row of data, enabled by supplying a non-NULL value for logInterval.\u00a0 In this case, a new row will be logged (as if logRow() were called on the LogFile) at the end of every logInterval ticks (just before the tick counter increments, in both WF and nonWF models), starting at the end of the tick in which the LogFile was created.\u00a0 A logInterval of 1 will cause automatic logging at the end of every tick, whereas a logInterval of NULL disables automatic logging.\u00a0 Automatic logging can always be disabled or reconfigured later with the LogFile method setLogInterval(), or logging can be triggered manually by calling logRow(). When compression is enabled, LogFile flushes new data lazily by default, for performance reasons, buffering data for multiple rows before writing to disk.\u00a0 Passing a non-NULL value for flushInterval requests a flush every flushInterval rows (with a value of 1 providing unbuffered operation).\u00a0 Note that flushing very frequently will likely result in both lower performance and a larger final file size (in one simple test, 48943 bytes instead of 4280 bytes, or more than a 10\u00d7 increase in size).\u00a0 Alternatively, passing a very large value for flushInterval will effectively disable automatic flushing, except at the end of the simulation (but be aware that this may use a large amount of memory for large log files).\u00a0 In any case, the log file will be created immediately, with its requested initial contents; the initial write is not buffered.\u00a0 When compression is not enabled, the flushInterval setting is ignored. The LogFile documentation discusses how to configure and use LogFile to write out the data you are interested in from your simulation."
            },
            "estimatedLastTick": {
                "signature": "(integer$)estimatedLastTick(void)",
                "description": " Returns SLiM\u2019s current estimate of the last tick in which the model will execute.\u00a0 Because script blocks can be added, removed, and rescheduled, and because the simulation may end prematurely (due to a call to simulationFinished(), for example), this is only an estimate, and may change over time."
            },
            "deregisterScriptBlock": {
                "signature": "(void)deregisterScriptBlock(io<SLiMEidosBlock>\u00a0scriptBlocks)",
                "description": " All SLiMEidosBlock objects specified by scriptBlocks (either with SLiMEidosBlock objects or with integer identifiers) will be scheduled for deregistration.\u00a0 The deregistered blocks remain valid, and may even still be executed in the current stage of the current tick; the blocks are not actually deregistered and deallocated until sometime after the currently executing script block has completed.\u00a0 To immediately prevent a script block from executing, even when it is scheduled to execute in the current stage of the current tick, use the active property of the script block."
            },
            "genomicElementTypesWithIDs": {
                "signature": "(object<GenomicElementType>)genomicElementTypesWithIDs(integer\u00a0ids)",
                "description": " Find and return the GenomicElementType objects with id values matching the values in ids.\u00a0 If no matching GenomicElementType object can be found with a given id, an error results."
            },
            "interactionTypesWithIDs": {
                "signature": "(object<InteractionType>)interactionTypesWithIDs(integer\u00a0ids)",
                "description": " Find and return the InteractionType objects with id values matching the values in ids.\u00a0 If no matching InteractionType object can be found with a given id, an error results."
            },
            "mutationTypesWithIDs": {
                "signature": "(object<MutationType>)mutationTypesWithIDs(integer\u00a0ids)",
                "description": " Find and return the MutationType objects with id values matching the values in ids.\u00a0 If no matching MutationType object can be found with a given id, an error results."
            },
            "outputUsage": {
                "signature": "(void)outputUsage(void)",
                "description": " Output the current memory usage of the simulation to Eidos\u2019s output stream.\u00a0 The specifics of what is printed, and in what format, should not be relied upon as they may change from version to version of SLiM.\u00a0 This method is primarily useful for understanding where the memory usage of a simulation predominantly resides, for debugging or optimization.\u00a0 Note that it does not capture all memory usage by the process; rather, it summarizes the memory usage by SLiM and Eidos in directly allocated objects and buffers.\u00a0 To get the same memory usage reported by outputUsage(), but as a float$ value, use the Community method usage().\u00a0 To get the total memory usage of the running process (either current or peak), use the Eidos function usage()."
            },
            "registerEarlyEvent": {
                "signature": "(object<SLiMEidosBlock>$)registerEarlyEvent(Nis$\u00a0id, string$\u00a0source, [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL], [No<Species>$\u00a0ticksSpec\u00a0=\u00a0NULL])",
                "description": " Register a block of Eidos source code, represented as the string singleton source, as an Eidos early() event in the current simulation, with optional start and end ticks (and, for multispecies models, optional ticks specifier ticksSpec) limiting its applicability.\u00a0 The script block will be given identifier id (specified as an integer, or as a string symbolic name such as \"s5\"); this may be NULL if there is no need to be able to refer to the block later.\u00a0 The registered event is added to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible to execute in the current tick.\u00a0 The new SLiMEidosBlock will be defined as a global variable immediately by this method, and will also be returned by this method."
            },
            "registerFirstEvent": {
                "signature": "(object<SLiMEidosBlock>$)registerFirstEvent(Nis$\u00a0id, string$\u00a0source, [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL], [No<Species>$\u00a0ticksSpec\u00a0=\u00a0NULL])",
                "description": " Register a block of Eidos source code, represented as the string singleton source, as an Eidos first() event in the current simulation, with optional start and end ticks (and, for multispecies models, optional ticks specifier ticksSpec) limiting its applicability.\u00a0 The script block will be given identifier id (specified as an integer, or as a string symbolic name such as \"s5\"); this may be NULL if there is no need to be able to refer to the block later.\u00a0 The registered event is added to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible to execute in the current tick.\u00a0 The new SLiMEidosBlock will be defined as a global variable immediately by this method, and will also be returned by this method."
            },
            "registerInteractionCallback": {
                "signature": "(object<SLiMEidosBlock>$)registerInteractionCallback(Nis$\u00a0id, string$\u00a0source, io<InteractionType>$\u00a0intType, [Nio<Subpopulation>$\u00a0subpop\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])",
                "description": " Register a block of Eidos source code, represented as the string singleton source, as an Eidos interaction() callback in the current simulation (global to the community), with a required interaction type intType (which may be an integer identifier), optional exerter subpopulation subpop (which may also be an integer identifier, or NULL, the default, to indicate all subpopulations), and optional start and end ticks all limiting its applicability.\u00a0 The script block will be given identifier id (specified as an integer, or as a string symbolic name such as \"s5\"); this may be NULL if there is no need to be able to refer to the block later.\u00a0 The registered callback is added to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it will be eligible to execute the next time an InteractionType is evaluated.\u00a0 The new SLiMEidosBlock will be defined as a global variable immediately by this method, and will also be returned by this method."
            },
            "registerLateEvent": {
                "signature": "(object<SLiMEidosBlock>$)registerLateEvent(Nis$\u00a0id, string$\u00a0source, [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL], [No<Species>$\u00a0ticksSpec\u00a0=\u00a0NULL])",
                "description": " Register a block of Eidos source code, represented as the string singleton source, as an Eidos late() event in the current simulation, with optional start and end ticks (and, for multispecies models, optional ticks specifier ticksSpec) limiting its applicability.\u00a0 The script block will be given identifier id (specified as an integer, or as a string symbolic name such as \"s5\"); this may be NULL if there is no need to be able to refer to the block later.\u00a0 The registered event is added to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible to execute in the current tick.\u00a0 The new SLiMEidosBlock will be defined as a global variable immediately by this method, and will also be returned by this method."
            },
            "rescheduleScriptBlock": {
                "signature": "(object<SLiMEidosBlock>$)rescheduleScriptBlock(io<SLiMEidosBlock>$\u00a0block, [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL], [Ni\u00a0ticks\u00a0=\u00a0NULL])",
                "description": " Reschedule the target script block given by block to execute in a specified set of ticks.\u00a0 The block parameter may be either an integer representing the ID of the desired script block, or a SLiMScriptBlock specified directly.\u00a0 The target script block, block, is returned. The first way to specify the tick set is with start and end parameter values; block will then execute from start to end, inclusive. The second way to specify the tick set is using the ticks parameter, specifying each tick in which the block should execute.\u00a0 The vector supplied for ticks does not need to be in sorted order, but it must not contain any duplicates. It can sometimes be better to handle script block scheduling in other ways.\u00a0 If an early() event needs to execute every tenth tick over the whole duration of a long model run, for example, it might not be advisable to use a call like community.rescheduleScriptBlock(s1, ticks=seq(10, 100000, 10)) for that purpose, since that would make things complicated for SLiM\u2019s scheduler.\u00a0 Instead, it might be preferable to add a test such as if (community.tick % 10 != 0) return; at the beginning of the event.\u00a0 It is legal to reschedule a script block while the block is executing; a call like community.rescheduleScriptBlock(self, community.tick + 10, community.tick + 10); made inside a given block would therefore also cause the block to execute every tenth tick, although this sort of self-rescheduling code is probably harder to read, maintain, and debug. Whichever way of specifying the tick set is used, block may continue to be executed during the current tick cycle stage even after it has been rescheduled, unless it is made inactive using its active property, and similarly, the block may not execute during the current tick cycle stage if it was not already scheduled to do so.\u00a0 Rescheduling script blocks during the tick and tick cycle stage in which they are executing, or in which they are intended to execute, should be avoided.\u00a0 Also, note that script blocks which are open-ended (i.e., with no specified end tick), are not used in determining whether the end of the simulation has been reached (because then the simulation would run forever). Note that new script blocks can also be created and scheduled using the register...() methods of Community and Species; by using the same source as a template script block, the template can be duplicated and scheduled for different ticks, perhaps with modifications or variations.\u00a0 In multispecies models, note that blocks may not run due to their species or ticks specifier, even in ticks in which they are scheduled to run."
            },
            "scriptBlocksWithIDs": {
                "signature": "(object<SLiMEidosBlock>)scriptBlocksWithIDs(integer\u00a0ids)",
                "description": " Find and return the SLiMEidosBlock objects with id values matching the values in ids.\u00a0 If no matching SLiMEidosBlock object can be found with a given id, an error results."
            },
            "simulationFinished": {
                "signature": "(void)simulationFinished(void)",
                "description": " Declare the current simulation finished.\u00a0 Normally SLiM ends a simulation when, at the end of a tick, there are no script events or callbacks registered for any future tick (excluding scripts with no declared end tick).\u00a0 If you wish to end a simulation before this condition is met, a call to simulationFinished() will cause the current simulation to end at the end of the current tick.\u00a0 For example, a simulation might self-terminate if a test for a dynamic equilibrium condition is satisfied.\u00a0 Note that the current tick will finish executing; if you want the simulation to stop immediately, you can use the Eidos method stop(), which raises an error condition."
            },
            "speciesWithIDs": {
                "signature": "(object<Species>)speciesWithIDs(integer\u00a0ids)",
                "description": " Find and return the Species objects with id values matching the values in ids.\u00a0 If no matching Species object can be found with a given id, an error results."
            },
            "subpopulationsWithIDs": {
                "signature": "(object<Subpopulation>)subpopulationsWithIDs(integer\u00a0ids)",
                "description": " Find and return the Subpopulation objects with id values matching the values in ids.\u00a0 If no matching Subpopulation object can be found with a given id, an error results."
            },
            "subpopulationsWithNames": {
                "signature": "(object<Subpopulation>)subpopulationsWithNames(string\u00a0names)",
                "description": " Find and return the Subpopulation objects with name values matching the values in names.\u00a0 If no matching Subpopulation object can be found with a given name, an error results."
            },
            "usage": {
                "signature": "(float$)usage(void)",
                "description": " Return the current memory usage of the simulation.\u00a0 The specifics of what is totalled up should not be relied upon as it may change from version to version of SLiM.\u00a0 This method is primarily useful for understanding where the memory usage of a simulation predominantly resides, for debugging or optimization.\u00a0 Note that it does not capture all memory usage by the process; rather, it summarizes the memory usage by SLiM and Eidos in directly allocated objects and buffers.\u00a0 To see details of this internal memory usage, use the Community method outputUsage().\u00a0 To get the total memory usage of the running process (either current or peak), use the Eidos function usage()."
            }
        },
        "properties": {
            "allGenomicElementTypes": {
                "type": "object<GenomicElementType>",
                "description": " All of the GenomicElementType objects defined in the simulation.\u00a0 These are guaranteed to be in sorted order, by their id property."
            },
            "allInteractionTypes": {
                "type": "object<InteractionType>",
                "description": " All of the InteractionType objects defined in the simulation.\u00a0 These are guaranteed to be in sorted order, by their id property."
            },
            "allMutationTypes": {
                "type": "object<MutationType>",
                "description": " All of the MutationType objects defined in the simulation.\u00a0 These are guaranteed to be in sorted order, by their id property."
            },
            "allScriptBlocks": {
                "type": "object<SLiMEidosBlock>",
                "description": " All registered SLiMEidosBlock objects in the simulation.\u00a0 These are guaranteed to be in sorted order, by their id property."
            },
            "allSpecies": {
                "type": "object<Species>",
                "description": " All of the Species objects defined in the simulation (in species declaration order)."
            },
            "allSubpopulations": {
                "type": "object<Subpopulation>",
                "description": " All of the Subpopulation objects defined in the simulation."
            },
            "cycleStage": {
                "type": "string$",
                "description": " The current cycle stage, as a string.\u00a0 The values of this property essentially mirror the cycle stages of WF and nonWF models.\u00a0 Common values include \"first\" (during execution of first() events), \"early\" (during execution of early() events), \"reproduction\" (during offspring generation), \"fitness\" (during fitness evaluation), \"survival\" (while applying selection and mortality in nonWF models), and \"late\" (during execution of late() events). Other possible values include \"begin\" (during internal setup before each cycle), \"tally\" (while tallying mutation reference counts and removing fixed mutations), \"swap\" (while swapping the offspring generation into the parental generation in WF models), \"end\" (during internal bookkeeping after each cycle), and \"console\" (during the in-between-ticks state in which commands in SLiMgui\u2019s Eidos console are executed).\u00a0 It would probably be a good idea not to use this latter set of values; they are probably not user-visible during ordinary model execution anyway. During execution of initialize() callbacks, no Community object yet exists and so this property cannot be accessed.\u00a0 To detect this state, use exists(\"community\"); if that is F, community does not exist, and therefore your code is executing during initialize() callbacks (or outside of SLiM entirely, in some other Eidos-based context)."
            },
            "logFiles": {
                "type": "object<LogFile>",
                "description": " The LogFile objects being used in the simulation."
            },
            "modelType": {
                "type": "string$",
                "description": " The type of model being simulated, as specified in initializeSLiMModelType().\u00a0 This will be \"WF\" for WF models (Wright-Fisher models, the default), or \"nonWF\" for nonWF models (non-Wright-Fisher models).\u00a0 This must be the same for all species in the community; it is therefore a property on Community, not Species."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to the simulation."
            },
            "tick": {
                "type": "integer$",
                "description": " The current tick number."
            },
            "verbosity": {
                "type": "integer$",
                "description": " The verbosity level, for SLiM\u2019s logging of information about the simulation.\u00a0 This is 1 by default, but can be changed at the command line with the -l[ong] option.\u00a0 It is provided here so that scripts can consult it to govern the level of verbosity of their own output, or set the verbosity level for particular sections of their code.\u00a0 A verbosity level of 0 suppresses most of SLiM\u2019s optional output; 2 adds some extra output beyond SLiM\u2019s standard output."
            }
        }
    },
    "Genome": {
        "constructor": {},
        "methods": {
            "addMutations": {
                "signature": "(void)addMutations(object<Mutation>\u00a0mutations)",
                "description": " Add the existing mutations in mutations to the genome, if they are not already present (if they are already present, they will be ignored), and if the addition is not prevented by the mutation stacking policy (see the mutationStackPolicy property of MutationType). Calling this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the Species method recalculateFitness() \u2013 but see the documentation of that method for caveats. Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the tick in which the individual is created (i.e., when the age of the individual is greater than 0), to prevent the possibility of inconsistencies in the recorded tree sequence."
            },
            "addNewDrawnMutation": {
                "signature": "(object<Mutation>)addNewDrawnMutation(io<MutationType>\u00a0mutationType, integer\u00a0position, [Nio<Subpopulation>\u00a0originSubpop\u00a0=\u00a0NULL], [Nis\u00a0nucleotide\u00a0=\u00a0NULL])",
                "description": " Add new mutations to the target genome(s) with the specified mutationType (specified by the MutationType object or by integer identifier), position, and originSubpop (specified by the Subpopulation object or by integer identifier, or by NULL, the default, to specify the subpopulation to which the first target genome belongs).\u00a0 If originSubpop is supplied as an integer, it is intentionally not checked for validity; you may use arbitrary values of originSubpop to \u201ctag\u201d the mutations that you create.\u00a0 The selection coefficients of the mutations are drawn from their mutation types; addNewMutation() may be used instead if you wish to specify selection coefficients. In non-nucleotide-based models, mutationType will always be a non-nucleotide-based mutation type, and so nucleotide must be NULL (the default).\u00a0 In a nucleotide-based model, mutationType might still be non-nucleotide-based (in which case nucleotide must still be NULL), or mutationType might be nucleotide-based, in which case a non-NULL value must be supplied for nucleotide, specifying the nucleotide(s) to be associated with the new mutation(s).\u00a0 Nucleotides may be specified with string values (\"A\", \"C\", \"G\", or \"T\"), or with integer values (A=0, C=1, G=2, T=3).\u00a0 If a nucleotide mutation already exists at the mutating position, it is replaced automatically in accordance with the stacking policy for nucleotide-based mutation types.\u00a0 No check is performed that a new mutation\u2019s nucleotide differs from the ancestral sequence, or that its selection coefficient is consistent with other mutations that may already exist at the given position with the same nucleotide; model consistency is the responsibility of the model. Beginning in SLiM 2.5 this method is vectorized, so all of these parameters may be singletons (in which case that single value is used for all mutations created by the call) or non-singleton vectors (in which case one element is used for each corresponding mutation created).\u00a0 Non-singleton parameters must match in length, since their elements need to be matched up one-to-one. The new mutations created by this method are returned, even if their actual addition is prevented by the mutation stacking policy (see the mutationStackPolicy property of MutationType).\u00a0 However, the order of the mutations in the returned vector is not guaranteed to be the same as the order in which the values are specified in parameter vectors, unless the position parameter is specified in ascending order.\u00a0 In other words, pre-sorting the parameters to this method into ascending order by position, using order() and subsetting, will guarantee that the order of the returned vector of mutations corresponds to the order of elements in the parameters to this method; otherwise, no such guarantee exists. Beginning in SLiM 2.1, this is a class method, not an instance method.\u00a0 This means that it does not get multiplexed out to all of the elements of the receiver (which would add a different new mutation to each element); instead, it is performed as a single operation, adding the same new mutation objects to all of the elements of the receiver.\u00a0 Before SLiM 2.1, to add the same mutations to multiple genomes, it was necessary to call addNewDrawnMutation() on one of the genomes, and then add the returned Mutation object to all of the other genomes using addMutations().\u00a0 That is not necessary in SLiM 2.1 and later, because of this change (although doing it the old way does no harm and produces identical behavior).\u00a0 Pre-2.1 code that actually relied upon the old multiplexing behavior will no longer work correctly (but this is expected to be an extremely rare pattern of usage). Calling this will normally affect the fitness values calculated at the end of the current tick (but not sooner); if you want current fitness values to be affected, you can call the Species method recalculateFitness() \u2013 but see the documentation of that method for caveats. Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the tick in which the individual is created (i.e., when the age of the individual is greater than 0), to prevent the possibility of inconsistencies in the recorded tree sequence."
            },
            "addNewMutation": {
                "signature": "(object<Mutation>)addNewMutation(io<MutationType>\u00a0mutationType, numeric\u00a0selectionCoeff, integer\u00a0position, [Nio<Subpopulation>\u00a0originSubpop\u00a0=\u00a0NULL], [Nis\u00a0nucleotide\u00a0=\u00a0NULL])",
                "description": " Add new mutations to the target genome(s) with the specified mutationType (specified by the MutationType object or by integer identifier), selectionCoeff, position, and originSubpop (specified by the Subpopulation object or by integer identifier, or by NULL, the default, to specify the subpopulation to which the first target genome belongs).\u00a0 If originSubpop is supplied as an integer, it is intentionally not checked for validity; you may use arbitrary values of originSubpop to \u201ctag\u201d the mutations that you create.\u00a0 The addNewDrawnMutation() method may be used instead if you wish selection coefficients to be drawn from the mutation types of the mutations. In non-nucleotide-based models, mutationType will always be a non-nucleotide-based mutation type, and so nucleotide must be NULL (the default).\u00a0 In a nucleotide-based model, mutationType might still be non-nucleotide-based (in which case nucleotide must still be NULL), or mutationType might be nucleotide-based, in which case a non-NULL value must be supplied for nucleotide, specifying the nucleotide(s) to be associated with the new mutation(s).\u00a0 Nucleotides may be specified with string values (\"A\", \"C\", \"G\", or \"T\"), or with integer values (A=0, C=1, G=2, T=3).\u00a0 If a nucleotide mutation already exists at the mutating position, it is replaced automatically in accordance with the stacking policy for nucleotide-based mutation types.\u00a0 No check is performed that a new mutation\u2019s nucleotide differs from the ancestral sequence, or that its selection coefficient is consistent with other mutations that may already exist at the given position with the same nucleotide; model consistency is the responsibility of the model. The new mutations created by this method are returned, even if their actual addition is prevented by the mutation stacking policy (see the mutationStackPolicy property of MutationType).\u00a0 However, the order of the mutations in the returned vector is not guaranteed to be the same as the order in which the values are specified in parameter vectors, unless the position parameter is specified in ascending order.\u00a0 In other words, pre-sorting the parameters to this method into ascending order by position, using order() and subsetting, will guarantee that the order of the returned vector of mutations corresponds to the order of elements in the parameters to this method; otherwise, no such guarantee exists. Beginning in SLiM 2.1, this is a class method, not an instance method.\u00a0 This means that it does not get multiplexed out to all of the elements of the receiver (which would add a different new mutation to each element); instead, it is performed as a single operation, adding the same new mutation object to all of the elements of the receiver.\u00a0 Before SLiM 2.1, to add the same mutation to multiple genomes, it was necessary to call addNewMutation() on one of the genomes, and then add the returned Mutation object to all of the other genomes using addMutations().\u00a0 That is not necessary in SLiM 2.1 and later, because of this change (although doing it the old way does no harm and produces identical behavior).\u00a0 Pre-2.1 code that actually relied upon the old multiplexing behavior will no longer work correctly (but this is expected to be an extremely rare pattern of usage). Calling this will normally affect the fitness values calculated at the end of the current tick (but not sooner); if you want current fitness values to be affected, you can call the Species method recalculateFitness() \u2013 but see the documentation of that method for caveats. Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the tick in which the individual is created (i.e., when the age of the individual is greater than 0), to prevent the possibility of inconsistencies in the recorded tree sequence."
            },
            "containsMarkerMutation": {
                "signature": "(Nlo<Mutation>$)containsMarkerMutation(io<MutationType>$\u00a0mutType, integer$\u00a0position, [logical$\u00a0returnMutation\u00a0=\u00a0F])",
                "description": " Returns T if the genome contains a mutation of type mutType at position, F otherwise (if returnMutation has its default value of F; see below).\u00a0 This method is, as its name suggests, intended for checking for \u201cmarker mutations\u201d: mutations of a special mutation type that are not literally mutations in the usual sense, but instead are added in to particular genomes to mark them as possessing some property.\u00a0 Marker mutations are not typically added by SLiM\u2019s mutation-generating machinery; instead they are added explicitly with addNewMutation() or addNewDrawnMutation() at a known, constant position in the genome.\u00a0 This method provides a check for whether a marker mutation of a given type exists in a particular genome; because the position to check is known in advance, that check can be done much faster than the equivalent check with containsMutations() or countOfMutationsOfType(), using a binary search of the genome. If returnMutation is T (an option added in SLiM 3), this method returns the actual mutation found, rather than just T or F.\u00a0 More specifically, the first mutation found of mutType at position will be returned; if more than one such mutation exists in the target genome, which one is returned is not defined.\u00a0 If returnMutation is T and no mutation of mutType is found at position, NULL will be returned."
            },
            "containsMutations": {
                "signature": "(logical)containsMutations(object<Mutation>\u00a0mutations)",
                "description": " Returns a logical vector indicating whether each of the mutations in mutations is present in the genome; each element in the returned vector indicates whether the corresponding mutation is present (T) or absent (F).\u00a0 This method is provided for speed; it is much faster than the corresponding Eidos code."
            },
            "countOfMutationsOfType": {
                "signature": "(integer$)countOfMutationsOfType(io<MutationType>$\u00a0mutType)",
                "description": " Returns the number of mutations that are of the type specified by mutType, out of all of the mutations in the genome.\u00a0 If you need a vector of the matching Mutation objects, rather than just a count, use -mutationsOfType().\u00a0 This method is provided for speed; it is much faster than the corresponding Eidos code."
            },
            "mutationCountsInGenomes": {
                "signature": "(integer)mutationCountsInGenomes([No<Mutation>\u00a0mutations\u00a0=\u00a0NULL])",
                "description": " Return an integer vector with the frequency counts of all of the Mutation objects passed in mutations, within the target Genome vector.\u00a0 If the optional mutations argument is NULL (the default), frequency counts will be returned for all of the active Mutation objects in the simulation \u2013 the same Mutation objects, and in the same order, as would be returned by the mutations property of sim, in other words. See the +mutationFrequenciesInGenomes() method to obtain float frequencies instead of integer counts.\u00a0 See also the Species methods mutationCounts() and mutationFrequencies(), which may be more efficient for getting counts/frequencies for whole subpopulations or for the whole simulation."
            },
            "mutationFrequenciesInGenomes": {
                "signature": "(float)mutationFrequenciesInGenomes([No<Mutation>\u00a0mutations\u00a0=\u00a0NULL])",
                "description": " Return a float vector with the frequencies of all of the Mutation objects passed in mutations, within the target Genome vector.\u00a0 If the optional mutations argument is NULL (the default), frequencies will be returned for all of the active Mutation objects in the simulation \u2013 the same Mutation objects, and in the same order, as would be returned by the mutations property of sim, in other words. See the +mutationCountsInGenomes() method to obtain integer counts instead of float frequencies.\u00a0 See also the Species methods mutationCounts() and mutationFrequencies(), which may be more efficient for getting counts/frequencies for whole subpopulations or for the whole simulation."
            },
            "mutationsOfType": {
                "signature": "(object<Mutation>)mutationsOfType(io<MutationType>$\u00a0mutType)",
                "description": " Returns an object vector of all the mutations that are of the type specified by mutType, out of all of the mutations in the genome.\u00a0 If you just need a count of the matching Mutation objects, rather than a vector of the matches, use -countOfMutationsOfType(); if you need just the positions of matching Mutation objects, use -positionsOfMutationsOfType(); and if you are aiming for a sum of the selection coefficients of matching Mutation objects, use -sumOfMutationsOfType().\u00a0 This method is provided for speed; it is much faster than the corresponding Eidos code."
            },
            "nucleotides": {
                "signature": "(is)nucleotides([Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL], [string$\u00a0format\u00a0=\u00a0\"string\"])",
                "description": " Returns the nucleotide sequence for the genome.\u00a0 This is the current ancestral sequence, as would be returned by the Chromosome method ancestralNucleotides(), with the nucleotides for any nucleotide-based mutations in the genome overlaid.\u00a0 The range of the returned sequence may be constrained by a start position given in start and/or an end position given in end; nucleotides will be returned from start to end, inclusive.\u00a0 The default value of NULL for start and end represent the first and last base positions of the chromosome, respectively. The format of the returned sequence is controlled by the format parameter.\u00a0 A format of \"string\" will return the sequence as a singleton string (e.g., \"TATA\").\u00a0 A format of \"char\" will return a string vector with one element per nucleotide (e.g., \"T\", \"A\", \"T\", \"A\").\u00a0 A format of \"integer\" will return an integer vector with values A=0, C=1, G=2, T=3 (e.g., 3, 0, 3, 0).\u00a0 A format of \"codon\" will return an integer vector with values from 0 to 63, based upon successive nucleotide triplets in the sequence (which, for this format, must have a length that is a multiple of three); see the ancestralNucleotides() documentation for details.\u00a0 If the sequence returned is likely to be long, the \"string\" format will be the most memory-efficient, and may also be the fastest (but may be harder to work with). Several helper functions are provided for working with sequences, such as nucleotideCounts() to get the counts of A/C/G/T nucleotides in a sequence, nucleotideFrequencies() to get the same information as frequencies, and codonsToAminoAcids() to convert a codon sequence (such as provided by the codon format described above) to an amino acid sequence."
            },
            "output": {
                "signature": "(void)output([Ns$\u00a0filePath\u00a0=\u00a0NULL], [logical$\u00a0append\u00a0=\u00a0F])",
                "description": " Output the target genomes in SLiM\u2019s native format.\u00a0 This low-level output method may be used to output any sample of Genome objects (the Eidos function sample() may be useful for constructing custom samples, as may the SLiM class Individual).\u00a0 For output of a sample from a single Subpopulation, the outputSample() of Subpopulation may be more straightforward to use.\u00a0 If the optional parameter filePath is NULL (the default), output is directed to SLiM\u2019s standard output.\u00a0 Otherwise, the output is sent to the file specified by filePath, overwriting that file if append if F, or appending to the end of it if append is T. See outputMS() and outputVCF() for other output formats.\u00a0 Output is generally done in a late() event, so that the output reflects the state of the simulation at the end of a tick."
            },
            "outputMS": {
                "signature": "(void)outputMS([Ns$\u00a0filePath\u00a0=\u00a0NULL], [logical$\u00a0append\u00a0=\u00a0F], [logical$\u00a0filterMonomorphic\u00a0=\u00a0F])",
                "description": " Output the target genomes in MS format.\u00a0 This low-level output method may be used to output any sample of Genome objects (the Eidos function sample() may be useful for constructing custom samples, as may the SLiM class Individual).\u00a0 For output of a sample from a single Subpopulation, the outputMSSample() of Subpopulation may be more straightforward to use.\u00a0 If the optional parameter filePath is NULL (the default), output is directed to SLiM\u2019s standard output.\u00a0 Otherwise, the output is sent to the file specified by filePath, overwriting that file if append if F, or appending to the end of it if append is T.\u00a0 Positions in the output will span the interval [0,1]. If filterMonomorphic is F (the default), all mutations that are present in the sample will be included in the output.\u00a0 This means that some mutations may be included that are actually monomorphic within the sample (i.e., that exist in every sampled genome, and are thus apparently fixed).\u00a0 These may be filtered out with filterMonomorphic = T if desired; note that this option means that some mutations that do exist in the sampled genomes might not be included in the output, simply because they exist in every sampled genome. See output() and outputVCF() for other output formats.\u00a0 Output is generally done in a late() event, so that the output reflects the state of the simulation at the end of a tick."
            },
            "outputVCF": {
                "signature": "(void)outputVCF([Ns$\u00a0filePath\u00a0=\u00a0NULL], [logical$\u00a0outputMultiallelics\u00a0=\u00a0T], [logical$\u00a0append\u00a0=\u00a0F], [logical$\u00a0simplifyNucleotides\u00a0=\u00a0F], [logical$\u00a0outputNonnucleotides\u00a0=\u00a0T])",
                "description": " Output the target genomes in VCF format.\u00a0 The target genomes are treated as pairs comprising individuals for purposes of structuring the VCF output, so an even number of genomes is required.\u00a0 This low-level output method may be used to output any sample of Genome objects (the Eidos function sample() may be useful for constructing custom samples, as may the SLiM class Individual).\u00a0 For output of a sample from a single Subpopulation, the outputVCFSample() of Subpopulation may be more straightforward to use.\u00a0 If the optional parameter filePath is NULL (the default), output is directed to SLiM\u2019s standard output.\u00a0 Otherwise, the output is sent to the file specified by filePath, overwriting that file if append if F, or appending to the end of it if append is T. The parameters outputMultiallelics, simplifyNucleotides, and outputNonnucleotides affect the format of the output produced; see the reference documentation for further discussion. See outputMS() and output() for other output formats.\u00a0 Output is generally done in a late() event, so that the output reflects the state of the simulation at the end of a tick."
            },
            "positionsOfMutationsOfType": {
                "signature": "(integer)positionsOfMutationsOfType(io<MutationType>$\u00a0mutType)",
                "description": " Returns the positions of mutations that are of the type specified by mutType, out of all of the mutations in the genome.\u00a0 If you need a vector of the matching Mutation objects, rather than just positions, use -mutationsOfType().\u00a0 This method is provided for speed; it is much faster than the corresponding Eidos code."
            },
            "readFromMS": {
                "signature": "(object<Mutation>)readFromMS(string$\u00a0filePath, io<MutationType>$\u00a0mutationType)",
                "description": " Read new mutations from the MS format file at filePath and add them to the target genomes.\u00a0 The number of target genomes must match the number of genomes represented in the MS file.\u00a0 To read into all of the genomes in a given subpopulation pN, simply call pN.genomes.readFromMS(), assuming the subpopulation\u2019s size matches that of the MS file.\u00a0 A vector containing all of the mutations created by readFromMS() is returned. Each mutation is created at the position specified in the file, using the mutation type given by mutationType.\u00a0 Positions are expected to be in [0,1], and are scaled to the length of the chromosome by multiplying by the last valid base position of the chromosome (i.e., one less than the chromosome length).\u00a0 Selection coefficients are drawn from the mutation type.\u00a0 The population of origin for each mutation is set to -1, and the tick of origin is set to the current tick.\u00a0 In a nucleotide-based model, if mutationType is nucleotide-based, a random nucleotide different from the ancestral nucleotide at the position will be chosen with equal probability. The target genomes correspond, in order, to the call lines in the MS file.\u00a0 In sex-based models that simulate the X or Y chromosome, null genomes in the target vector will be skipped, and will not be used to correspond to any call line; however, care should be taken in this case that the lines in the MS file correspond to the target genomes in the manner desired."
            },
            "readFromVCF": {
                "signature": "(object<Mutation>)readFromVCF(string$\u00a0filePath, [Nio<MutationType>$\u00a0mutationType\u00a0=\u00a0NULL])",
                "description": " Read new mutations from the VCF format file at filePath and add them to the target genomes.\u00a0 The number of target genomes must match the number of genomes represented in the VCF file (i.e., two times the number of samples, if each sample is diploid).\u00a0 To read into all of the genomes in a given subpopulation pN, simply call pN.genomes.readFromVCF(), assuming the subpopulation\u2019s size matches that of the VCF file taking ploidy into account.\u00a0 A vector containing all of the mutations created by readFromVCF() is returned. SLiM\u2019s VCF parsing is quite primitive.\u00a0 The header is parsed only inasmuch as SLiM looks to see whether SLiM-specific VCF fields are defined or not; the rest of the header information is ignored.\u00a0 Call lines are assumed to follow the format: The CHROM, ID, QUAL, FILTER, and FORMAT fields are ignored, and information in the genotype fields beyond the GT genotype subfield are also ignored.\u00a0 SLiM\u2019s own VCF annotations are honored; in particular, mutations will be created using the given values of MID, S, PO, TO, and MT if those subfields are present, and DOM, if it is present, must match the dominance coefficient of the mutation type.\u00a0 The parameter mutationType (a MutationType object or id) will be used for any mutations that have no supplied mutation type id in the MT subfield; if mutationType would be used but is NULL an error will result.\u00a0 Mutation IDs supplied in MID will be used if no mutation IDs have been used in the simulation so far; if any have been used, it is difficult for SLiM to guarantee that there are no conflicts, so a warning will be emitted and the MID values will be ignored.\u00a0 If selection coefficients are not supplied with the S subfield, they will be drawn from the mutation type used for the mutation.\u00a0 If a population of origin is not supplied with the PO subfield, -1 will be used.\u00a0 If a tick of origin is not supplied with the TO subfield (or a generation of origin GO field, which was the SLiM convention before SLiM 4), the current tick will be used. REF and ALT must always be comprised of simple nucleotides (A/C/G/T) rather than values representing indels or other complex states.\u00a0 Beyond this, the handling of the REF and ALT fields depends upon several factors.\u00a0 First of all, these fields are ignored in non-nucleotide-based models, although they are still checked for conformance.\u00a0 In nucleotide-based models, when a header definition for SLiM\u2019s NONNUC tag is present (as when nucleotide-based output is generated by SLiM): Second, if a NONNUC field is present in the INFO field the call line is taken to represent a non-nucleotide-based mutation, and REF and ALT are again ignored.\u00a0 In this case the mutation type used must be non-nucleotide-based.\u00a0 Third, if NONNUC is not present the call line is taken to represent a nucleotide-based mutation.\u00a0 In this case, the mutation type used must be nucleotide-based.\u00a0 Also, in this case, the specified reference nucleotide must match the existing ancestral nucleotide at the given position.\u00a0 In nucleotide-based models, when a header definition for SLiM\u2019s NONNUC tag is not present (as when loading a non-SLiM-generated VCF file): The mutation type will govern the way nucleotides are handled.\u00a0 If the mutation type used for a mutation is nucleotide-based, the nucleotide provided in the VCF file for that allele will be used.\u00a0 If the mutation type is non-nucleotide-based, the nucleotide provided will be ignored. If multiple alleles using the same nucleotide at the same position are specified in the VCF file, a separate mutation will be created for each, mirroring SLiM\u2019s behavior with independent mutational lineages when writing VCF.\u00a0 The MULTIALLELIC flag is ignored by readFromVCF(); call lines for mutations at the same base position in the same genome will result in stacked mutations whether or not MULTIALLELIC is present. The target genomes correspond, in order, to the haploid or diploid calls provided for i0\u2026iN (the sample IDs) in the VCF file.\u00a0 In sex-based models that simulate the X or Y chromosome, null genomes in the target vector will be skipped, and will not be used to correspond to any of i0\u2026iN; however, care should be taken in this case that the genomes in the VCF file correspond to the target genomes in the manner desired."
            },
            "removeMutations": {
                "signature": "(void)removeMutations([No<Mutation>\u00a0mutations\u00a0=\u00a0NULL], [logical$\u00a0substitute\u00a0=\u00a0F])",
                "description": " Remove the mutations in mutations from the target genome(s), if they are present (if they are not present, they will be ignored).\u00a0 If NULL is passed for mutations (which is the default), then all mutations will be removed from the target genomes; in this case, substitute must be F (a specific vector of mutations to be substituted is required).\u00a0 Note that the Mutation objects removed remain valid, and will still be in the simulation\u2019s mutation registry (i.e., will be returned by the Species property mutations), until the next tick. Removing mutations will normally affect the fitness values calculated at the end of the current tick; if you want current fitness values to be affected, you can call the Species method recalculateFitness() \u2013 but see the documentation of that method for caveats. The optional parameter substitute was added in SLiM 2.2, with a default of F for backward compatibility.\u00a0 If substitute is T, Substitution objects will be created for all of the removed mutations so that they are recorded in the simulation as having fixed, just as if they had reached fixation and been removed by SLiM\u2019s own internal machinery.\u00a0 This will occur regardless of whether the mutations have in fact fixed, regardless of the convertToSubstitution property of the relevant mutation types, and regardless of whether all copies of the mutations have even been removed from the simulation (making it possible to create Substitution objects for mutations that are still segregating).\u00a0 It is up to the caller to perform whatever checks are necessary to preserve the integrity of the simulation\u2019s records.\u00a0 Typically substitute will only be set to T in the context of calls like sim.subpopulations.genomes.removeMutations(muts, T), such that the substituted mutations are guaranteed to be entirely removed from circulation.\u00a0 As mentioned above, substitute may not be T if mutations is NULL."
            },
            "sumOfMutationsOfType": {
                "signature": "(float$)sumOfMutationsOfType(io<MutationType>$\u00a0mutType)",
                "description": " Returns the sum of the selection coefficients of all mutations that are of the type specified by mutType, out of all of the mutations in the genome.\u00a0 This is often useful in models that use a particular mutation type to represent QTLs with additive effects; in that context, sumOfMutationsOfType() will provide the sum of the additive effects of the QTLs for the given mutation type.\u00a0 This method is provided for speed; it is much faster than the corresponding Eidos code.\u00a0 Note that this method also exists on Individual, for cases in which the sum across both genomes of an individual is desired."
            }
        },
        "properties": {
            "genomePedigreeID": {
                "type": "integer$",
                "description": " If pedigree tracking is turned on with initializeSLiMOptions(keepPedigrees=T), genomePedigreeID is a unique non-negative identifier for each genome in a simulation, never re-used throughout the duration of the simulation run.\u00a0 Furthermore, the genomePedigreeID of a given genome will be equal to either (2*pedigreeID) or (2*pedigreeID + 1) of the individual that the genome belongs to (the former for the first genome of the individual, the latter for the second genome of the individual); this invariant relationship is guaranteed.\u00a0 If pedigree tracking is not enabled, this property is unavailable."
            },
            "genomeType": {
                "type": "string$",
                "description": " The type of chromosome represented by this genome; one of \"A\", \"X\", or \"Y\"."
            },
            "individual": {
                "type": "object<Individual>$",
                "description": " The Individual object to which this genome belongs."
            },
            "isNullGenome": {
                "type": "logical$",
                "description": " T if the genome is a \u201cnull\u201d genome, F if it is an ordinary genome object.\u00a0 When a sex chromosome (X or Y) is simulated, the other sex chromosome also exists in the simulation, but it is a \u201cnull\u201d genome that does not carry any mutations.\u00a0 Instead, it is a placeholder, present to allow SLiM\u2019s code to operate in much the same way as it does when an autosome is simulated.\u00a0 Null genomes should not be accessed or manipulated."
            },
            "mutations": {
                "type": "object<Mutation>",
                "description": " All of the Mutation objects present in this genome."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use.\u00a0 Note that the Genome objects used by SLiM are new with every new individual, so the tag value of each new offspring generated in each tick will be initially undefined."
            }
        }
    },
    "GenomicElement": {
        "constructor": {},
        "methods": {
            "setGenomicElementType": {
                "signature": "(void)setGenomicElementType(io<GenomicElementType>$\u00a0genomicElementType)",
                "description": " Set the genomic element type used for a genomic element.\u00a0 The genomicElementType parameter should supply the new genomic element type for the element, either as a GenomicElementType object or as an integer identifier.\u00a0 The genomic element type for a genomic element is normally a constant in simulations, so be sure you know what you are doing."
            }
        },
        "properties": {
            "endPosition": {
                "type": "integer$",
                "description": " The last position in the chromosome contained by this genomic element."
            },
            "genomicElementType": {
                "type": "object<GenomicElementType>$",
                "description": " The GenomicElementType object that defines the behavior of this genomic element."
            },
            "startPosition": {
                "type": "integer$",
                "description": " The first position in the chromosome contained by this genomic element."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use."
            }
        }
    },
    "GenomicElementType": {
        "constructor": {},
        "methods": {
            "setMutationFractions": {
                "signature": "(void)setMutationFractions(io<MutationType>\u00a0mutationTypes, numeric\u00a0proportions)",
                "description": " Set the mutation type fractions contributing to a genomic element type.\u00a0 The mutationTypes vector should supply the mutation types used by the genomic element (either as MutationType objects or as integer identifiers), and the proportions vector should be of equal length, specifying the relative proportion of mutations that will be drawn from each corresponding type.\u00a0 This is normally a constant in simulations, so be sure you know what you are doing."
            },
            "setMutationMatrix": {
                "signature": "(void)setMutationMatrix(float\u00a0mutationMatrix)",
                "description": " Sets a new nucleotide mutation matrix for the genomic element type.\u00a0 This replaces the mutation matrix originally set by initializeGenomicElementType().\u00a0 This method may only be called in nucleotide-based models."
            }
        },
        "properties": {
            "color": {
                "type": "string$",
                "description": " The color used to display genomic elements of this type in SLiMgui.\u00a0 Outside of SLiMgui, this property still exists, but is not used by SLiM.\u00a0 Colors may be specified by name, or with hexadecimal RGB values of the form \"#RRGGBB\".\u00a0 If color is the empty string, \"\", SLiMgui\u2019s default color scheme is used; this is the default for new GenomicElementType objects."
            },
            "id": {
                "type": "integer$",
                "description": " The identifier for this genomic element type; for genomic element type g3, for example, this is 3."
            },
            "mutationFractions": {
                "type": "float",
                "description": " For each MutationType represented in this genomic element type, this property has the corresponding fraction of all mutations that will be drawn from that MutationType."
            },
            "mutationMatrix": {
                "type": "float",
                "description": " The nucleotide mutation matrix used for this genomic element type, set up by initializeGenomicElementType() and setMutationMatrix().\u00a0 This property is only defined in nucleotide-based models; it is unavailable otherwise."
            },
            "mutationTypes": {
                "type": "object<MutationType>",
                "description": " The MutationType instances used by this genomic element type."
            },
            "species": {
                "type": "object<Species>$",
                "description": " The species to which the target object belongs."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to genomic element types."
            }
        }
    },
    "Individual": {
        "constructor": {},
        "methods": {
            "containsMutations": {
                "signature": "(logical)containsMutations(object<Mutation>\u00a0mutations)",
                "description": " Returns a logical vector indicating whether each of the mutations in mutations is present in the individual (in either of its genomes); each element in the returned vector indicates whether the corresponding mutation is present (T) or absent (F).\u00a0 This method is provided for speed; it is much faster than the corresponding Eidos code."
            },
            "countOfMutationsOfType": {
                "signature": "(integer$)countOfMutationsOfType(io<MutationType>$\u00a0mutType)",
                "description": " Returns the number of mutations that are of the type specified by mutType, out of all of the mutations in the individual (in both of its genomes; a mutation that is present in both genomes counts twice).\u00a0 If you need a vector of the matching Mutation objects, rather than just a count, use the Genome method -mutationsOfType().\u00a0 This method is provided for speed; it is much faster than the corresponding Eidos code."
            },
            "relatedness": {
                "signature": "(float)relatedness(object<Individual>\u00a0individuals)",
                "description": " Returns a vector containing the degrees of relatedness between the receiver and each of the individuals in individuals.\u00a0 The relatedness between A and B is always 1.0 if A and B are actually the same individual; this facility works even if SLiM\u2019s optional pedigree tracking is not enabled (in which case all other relatedness values will be 0.0).\u00a0 Otherwise, if pedigree tracking is turned on with initializeSLiMOptions(keepPedigrees=T), this method will use the pedigree information to construct a relatedness estimate. More specifically, this method uses all available pedigree information from the grandparental and parental pedigree records of A and B to compute an estimate of the degree of consanguinity between A and B.\u00a0 Siblings have a relatedness of 0.5, as do parents to their children and vice versa; cousins have a relatedness of 0.125; and so forth.\u00a0 If, according to the pedigree information available, A and B have no blood relationship, the value returned is 0.0.\u00a0 Note that the value returned by relatedness() is what is called the \u201ccoefficient of relationship\u201d between the two individuals (Wright, 1922; https://doi.org/10.1086/279872), and ranges from 0.0 to 1.0. There is another commonly used metric of relatedness, called the \u201ckinship coefficient\u201d, that reflects the probability of identity by descent between two individuals A and B.\u00a0 In general, it is approximately equal to one-half of the coefficient of relationship; if an approximate estimate of the kinship coefficient is acceptable, especially in models in which individuals are expected to be outbred, you can simply divide relatedness() by two.\u00a0 However, it should be noted that Wright\u2019s coefficient of relationship is not a measure of the probability of identity by descent, and so it is not exactly double the kinship coefficient; they actually measure different things.\u00a0 More precisely, the relationship between them is r\u00a0=\u00a02\u03c6/sqrt((1+fA)(1+fB)), where r is Wright\u2019s coefficient of relatedness, \u03c6 is the kinship coefficient, and fA and fB are the inbreeding coefficients of A and B respectively. Note that this relatedness is simply pedigree-based relatedness, and does not necessarily correspond to genetic relatedness, because of the effects of factors like assortment and recombination.\u00a0 If a metric of actual genetic relatedness is desired, tree-sequence recording can be used after simulation is complete, to compute the exact genetic relatedness between individuals based upon the complete ancestry tree (a topic which is beyond the scope of this manual).\u00a0 Actual genetic relatedness cannot presently be calculated during a simulation run; the information is implicitly contained in the recorded tree-sequence tables, but calculating it is too computationally expensive to be reasonable. This method assumes that the grandparents (or the parents, if grandparental information is not available) are themselves unrelated and that they are not inbred; this assumption is necessary because we have no information about their parentage, since SLiM\u2019s pedigree tracking information only goes back two generations.\u00a0 Be aware that in a model where inbreeding or selfing occurs at all (including \u201cincidental selfing\u201d, where a hermaphroditic individual happens to choose itself as a mate), some level of \u201cbackground relatedness\u201d will be present and this assumption will be violated.\u00a0 In such circumstances, relatedness() will therefore tend to underestimate the degree of relatedness between individuals, and the greater the degree of inbreeding, the greater the underestimation will be.\u00a0 If inbreeding is allowed in a model \u2013 and particularly if it is common \u2013 the results of relatedness() should therefore not be taken as an estimate of absolute relatedness, but can still be useful as an estimate of relative relatedness (indicating that, say, A appears from the information available to be more closely related to B than it is to C). See also sharedParentCount() for a different metric of relatedness."
            },
            "setSpatialPosition": {
                "signature": "(void)setSpatialPosition(float\u00a0position)",
                "description": " Sets the spatial position of the individual (as accessed through the spatialPosition property).\u00a0 The length of position (the number of coordinates in the spatial position of an individual) depends upon the spatial dimensionality declared with initializeSLiMOptions().\u00a0 If the spatial dimensionality is zero (as it is by default), it is an error to call this method.\u00a0 The elements of position are set into the values of the x, y, and z properties (if those properties are encompassed by the spatial dimensionality of the simulation).\u00a0 In other words, if the declared dimensionality is \"xy\", calling individual.setSpatialPosition(c(1.0, 0.5)) property is equivalent to individual.x\u00a0=\u00a01.0; individual.y\u00a0=\u00a00.5; individual.z is not set (even if a third value is supplied in position) since it is not encompassed by the simulation\u2019s dimensionality in this example. Note that this is an Eidos class method, somewhat unusually, which allows it to work in a special way when called on a vector of individuals.\u00a0 When the target vector of individuals is non-singleton, this method can do one of two things.\u00a0 If position contains just a single point (i.e., is equal in length to the spatial dimensionality of the model), the spatial position of all of the target individuals will be set to the given point.\u00a0 Alternatively, if position contains one point per target individual (i.e., is equal in length to the number of individuals multiplied by the spatial dimensionality of the model), the spatial position of each target individual will be set to the corresponding point from position (where the point data is concatenated, not interleaved, just as it would be returned by accessing the spatialPosition property on the vector of target individuals).\u00a0 Calling this method with a position vector of any other length is an error."
            },
            "sharedParentCount": {
                "signature": "(integer)sharedParentCount(object<Individual>\u00a0individuals)",
                "description": " Returns a vector containing the number of parents shared between the receiver and each of the individuals in individuals.\u00a0 The number of shared parents between A and B is always 2 if A and B are actually the same individual; this facility works even if SLiM\u2019s optional pedigree tracking is not enabled (in which case all other relatedness values will be 0).\u00a0 Otherwise, if pedigree tracking is turned on with initializeSLiMOptions(keepPedigrees=T), this method will use the pedigree information to construct a relatedness estimate. More specifically, this method uses the parental pedigree IDs from the pedigree records of a pair of individuals to count the number of shared parents between them, such that full siblings (with all of the same parents) have a count of 2, and half siblings (with half of the same parents) have a count of 1.\u00a0 If possible parents of the two individuals are A, B, C, and D, then the shared parent count is as follows, for some illustrative examples.\u00a0 The first column showing the two parents of the first individual, the second column showing the two parents of the second individual; note that the two parents of an individual can be the same due to cloning or selfing: This method does not estimate consanguinity.\u00a0 For example, if one individual is itself a parent of the other individual, that is irrelevant for this method.\u00a0 Similarly, in simulations of sex chromosomes, the sexes of the parents are irrelevant, even if no genetic material would have been inherited from a given parent.\u00a0 See relatedness() for an assessment of pedigree-based relatedness that does estimate the consanguinity of individuals.\u00a0 The sharedParentCount() method is preferable if your exact question is simply whether individuals are full siblings, half siblings, or non-siblings; in other cases, relatedness() is probably more useful."
            },
            "sumOfMutationsOfType": {
                "signature": "(float$)sumOfMutationsOfType(io<MutationType>$\u00a0mutType)",
                "description": " Returns the sum of the selection coefficients of all mutations that are of the type specified by mutType, out of all of the mutations in the genomes of the individual.\u00a0 This is often useful in models that use a particular mutation type to represent QTLs with additive effects; in that context, sumOfMutationsOfType() will provide the sum of the additive effects of the QTLs for the given mutation type.\u00a0 This method is provided for speed; it is much faster than the corresponding Eidos code.\u00a0 Note that this method also exists on Genome, for cases in which the sum for just one genome is desired."
            },
            "uniqueMutationsOfType": {
                "signature": "(object<Mutation>)uniqueMutationsOfType(io<MutationType>$\u00a0mutType)",
                "description": " Returns an object vector of all the mutations that are of the type specified by mutType, out of all of the mutations in the individual.\u00a0 Mutations present in both genomes will occur only once in the result of this method, and the mutations will be given in sorted order by position, so this method is similar to sortBy(unique(individual.genomes.mutationsOfType(mutType)), \"position\").\u00a0 It is not identical to that call, only because if multiple mutations exist at the exact same position, they may be sorted differently by this method than they would be by sortBy().\u00a0 If you just need a count of the matching Mutation objects, rather than a vector of the matches, use -countOfMutationsOfType().\u00a0 This method is provided for speed; it is much faster than the corresponding Eidos code.\u00a0 Indeed, it is faster than just individual.genomes.mutationsOfType(mutType), and gives uniquing and sorting on top of that, so it is advantageous unless duplicate entries for homozygous mutations are actually needed."
            }
        },
        "properties": {
            "age": {
                "type": "integer$",
                "description": " The age of the individual, measured in cycles.\u00a0 A newly generated offspring individual will have an age of 0 in the same tick in which it was created.\u00a0 The age of every individual is incremented by one at the same point that its species cycle counter is incremented, at the end of the tick cycle, if and only if its species was active in that tick.\u00a0 The age of individuals may be changed; usually this only makes sense when setting up the initial state of a model, however."
            },
            "color": {
                "type": "string$",
                "description": " The color used to display the individual in SLiMgui.\u00a0 Outside of SLiMgui, this property still exists, but is not used by SLiM.\u00a0 Colors may be specified by name, or with hexadecimal RGB values of the form \"#RRGGBB\" (see the Eidos manual).\u00a0 If color is the empty string, \"\", SLiMgui\u2019s default (fitness-based) color scheme is used; this is the default for new Individual objects.\u00a0 Note that named colors will be converted to RGB internally, so the value of this property will always be a hexadecimal RGB color string (or \"\")."
            },
            "fitnessScaling": {
                "type": "float$",
                "description": " A float scaling factor applied to the individual\u2019s fitness (i.e., the fitness value computed for the individual will be multiplied by this value).\u00a0 This provides a simple, fast way to modify the fitness of an individual; conceptually it is similar to returning a fitness effect for the individual from a fitnessEffect() callback, but without the complexity and performance overhead of implementing such a callback.\u00a0 To scale the fitness of all individuals in a subpopulation by the same factor, see the fitnessScaling property of Subpopulation. The value of fitnessScaling is reset to 1.0 every tick, so that any scaling factor set lasts for only a single tick.\u00a0 This reset occurs immediately after fitness values are calculated, in both WF and nonWF models."
            },
            "genomes": {
                "type": "object<Genome>",
                "description": " The pair of Genome objects associated with this individual.\u00a0 If only one of the two genomes is desired, the genome1 or genome2 property may be used."
            },
            "genomesNonNull": {
                "type": "object<Genome>",
                "description": " The pair of Genome objects associated with this individual, as with the genomes property, if both are not null genomes.\u00a0 If one or both are null genomes, the null genomes are excluded from the returned vector.\u00a0 This is a convenience shorthand, sometimes useful in models that involve null genomes."
            },
            "genome1": {
                "type": "object<Genome>$",
                "description": " The first Genome object associated with this individual.\u00a0 This property is particularly useful when you want the first genome from each of a vector of individuals, as often arises in haploid models."
            },
            "genome2": {
                "type": "object<Genome>$",
                "description": " The second Genome object associated with this individual.\u00a0 This property is particularly useful when you want the second genome from each of a vector of individuals, as often arises in haploid models."
            },
            "index": {
                "type": "integer$",
                "description": " The index of the individual in the individuals vector of its Subpopulation."
            },
            "meanParentAge": {
                "type": "float$",
                "description": " The average age of the parents of this individual, measured in cycles.\u00a0 Parentless individuals will have a meanParentAge of 0.0.\u00a0 The mean parent age is determined when a new offspring is generated, from the age property of the parent or parents involved in generating the offspring.\u00a0 For addRecombinant() that is somewhat complex; see that method for details."
            },
            "migrant": {
                "type": "logical$",
                "description": " Set to T if the individual is a recent migrant, F otherwise.\u00a0 The definition of \u201crecent\u201d depends upon the model type (WF or nonWF). In WF models, this flag is set at the point when a new child is generated if it is a migrant (i.e., if its source subpopulation is not the same as its subpopulation), and remains valid, with the same value, for the rest of the individual\u2019s lifetime. In nonWF models, this flag is F for all new individuals, is set to F in all individuals at the end of the reproduction tick cycle stage, and is set to T on all individuals moved to a new subpopulation by takeMigrants() or a survival() callback; the T value set by takeMigrants() or survival() will remain until it is reset at the end of the next reproduction tick cycle stage."
            },
            "pedigreeID": {
                "type": "integer$",
                "description": " If pedigree tracking is turned on with initializeSLiMOptions(keepPedigrees=T), pedigreeID is a unique non-negative identifier for each individual in a simulation, never re-used throughout the duration of the simulation run.\u00a0 If pedigree tracking is not enabled, this property is unavailable."
            },
            "pedigreeParentIDs": {
                "type": "integer",
                "description": " If pedigree tracking is turned on with initializeSLiMOptions(keepPedigrees=T), pedigreeParentIDs contains the values of pedigreeID that were possessed by the parents of an individual; it is thus a vector of two values.\u00a0 If pedigree tracking is not enabled, this property is unavailable.\u00a0 Parental values may be -1 if insufficient ticks have elapsed for that information to be available (because the simulation just started, or because a subpopulation is new)."
            },
            "pedigreeGrandparentIDs": {
                "type": "integer",
                "description": " If pedigree tracking is turned on with initializeSLiMOptions(keepPedigrees=T), pedigreeGrandparentIDs contains the values of pedigreeID that were possessed by the grandparents of an individual; it is thus a vector of four values.\u00a0 If pedigree tracking is not enabled, this property is unavailable.\u00a0 Grandparental values may be -1 if insufficient ticks have elapsed for that information to be available (because the simulation just started, or because a subpopulation is new)."
            },
            "reproductiveOutput": {
                "type": "integer$",
                "description": " If pedigree tracking is turned on with initializeSLiMOptions(keepPedigrees=T), reproductiveOutput contains the number of offspring for which this individual has been a parent.\u00a0 If pedigree tracking is not enabled, this property is unavailable.\u00a0 If an individual is a parent by cloning or selfing, or as both parents for a biparental mating, this value is incremented by two.\u00a0 Involvement of an individual as a parent for an addRecombinant() call does not change this property\u2019s value, since the reproductive contribution in that case is unclear; one must conduct separate bookkeeping for that case if necessary."
            },
            "sex": {
                "type": "string$",
                "description": " The sex of the individual.\u00a0 This will be \"H\" if sex is not enabled in the simulation (i.e., for hermaphrodites), otherwise \"F\" or \"M\" as appropriate."
            },
            "spatialPosition": {
                "type": "float",
                "description": " The spatial position of the individual.\u00a0 The length of the spatialPosition property (the number of coordinates in the spatial position of an individual) depends upon the spatial dimensionality declared with initializeSLiMOptions().\u00a0 If the spatial dimensionality is zero (as it is by default), it is an error to access this property.\u00a0 The elements of this property are identical to the values of the x, y, and z properties (if those properties are encompassed by the spatial dimensionality of the simulation).\u00a0 In other words, if the declared dimensionality is \"xy\", the individual.spatialPosition property is equivalent to c(individual.x,\u00a0individual.y); individual.z is not used since it is not encompassed by the simulation\u2019s dimensionality."
            },
            "subpopulation": {
                "type": "object<Subpopulation>$",
                "description": " The Subpopulation object to which the individual belongs."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value (as opposed to tagF, which is of type float).\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to individuals.\u00a0 Note that the Individual objects used by SLiM are new for every new offspring, so the tag value of each new offspring generated in each tick will be initially undefined."
            },
            "tagF": {
                "type": "float$",
                "description": " A user-defined float value (as opposed to tag, which is of type integer).\u00a0 The value of tagF is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tagF is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to individuals. Note that at present, although many classes in SLiM have an integer-type tag property, only Individual has a float-type tagF property, because attaching model state to individuals seems to be particularly common and useful.\u00a0 If a tagF property would be helpful on another class, it would be easy to add. See the description of the tag property above for additional comments."
            },
            "tagL0": {
                "type": "logical$",
                "description": " A user-defined logical value (see also tag and tagF).\u00a0 The value of tagL0 is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tagL0 is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to individuals."
            },
            "tagL1": {
                "type": "logical$",
                "description": " A user-defined logical value (see also tag and tagF).\u00a0 The value of tagL1 is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tagL1 is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to individuals."
            },
            "tagL2": {
                "type": "logical$",
                "description": " A user-defined logical value (see also tag and tagF).\u00a0 The value of tagL2 is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tagL2 is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to individuals."
            },
            "tagL3": {
                "type": "logical$",
                "description": " A user-defined logical value (see also tag and tagF).\u00a0 The value of tagL3 is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tagL3 is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to individuals."
            },
            "tagL4": {
                "type": "logical$",
                "description": " A user-defined logical value (see also tag and tagF).\u00a0 The value of tagL4 is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tagL4 is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to individuals."
            },
            "uniqueMutations": {
                "type": "object<Mutation>",
                "description": " All of the Mutation objects present in this individual.\u00a0 Mutations present in both genomes will occur only once in this property, and the mutations will be given in sorted order by position, so this property is similar to sortBy(unique(individual.genomes.mutations), \"position\").\u00a0 It is not identical to that call, only because if multiple mutations exist at the exact same position, they may be sorted differently by this method than they would be by sortBy().\u00a0 This method is provided primarily for speed; it executes much faster than the Eidos equivalent above.\u00a0 Indeed, it is faster than just individual.genomes.mutations, and gives uniquing and sorting on top of that, so it is advantageous unless duplicate entries for homozygous mutations are actually needed."
            },
            "x": {
                "type": "float$",
                "description": " A user-defined float value.\u00a0 The value of x is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of x is not used by SLiM unless the optional \u201ccontinuous space\u201d facility is enabled with the dimensionality parameter to initializeSLiMOptions(), in which case x will be understood to represent the x coordinate of the individual in space.\u00a0 If continuous space is not enabled, you may use x as an additional tag value of type float."
            },
            "xy": {
                "type": "float",
                "description": " This property provides joint read-only access to the x and y properties; they are returned as a two-element float vector.\u00a0 This can be useful in complex spatial models in which the spatiality of interactions/maps differs from the overall dimensionality of the model.\u00a0 See the documentation for the separate properties x and y for further comments."
            },
            "xyz": {
                "type": "float",
                "description": " This property provides joint read-only access to the x, y, and z properties; they are returned as a three-element float vector.\u00a0 This can be useful in complex spatial models in which the spatiality of interactions/maps differs from the overall dimensionality of the model.\u00a0 See the documentation for the separate properties x, y, and z for further comments."
            },
            "xz": {
                "type": "float",
                "description": " This property provides joint read-only access to the x and z properties; they are returned as a two-element float vector.\u00a0 This can be useful in complex spatial models in which the spatiality of interactions/maps differs from the overall dimensionality of the model.\u00a0 See the documentation for the separate properties x and z for further comments."
            },
            "y": {
                "type": "float$",
                "description": " A user-defined float value.\u00a0 The value of y is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of y is not used by SLiM unless the optional \u201ccontinuous space\u201d facility is enabled with the dimensionality parameter to initializeSLiMOptions(), in which case y will be understood to represent the y coordinate of the individual in space (if the dimensionality is \"xy\" or \"xyz\").\u00a0 If continuous space is not enabled, or the dimensionality is not \"xy\" or \"xyz\", you may use y as an additional tag value of type float."
            },
            "yz": {
                "type": "float",
                "description": " This property provides joint read-only access to the y and z properties; they are returned as a two-element float vector.\u00a0 This can be useful in complex spatial models in which the spatiality of interactions/maps differs from the overall dimensionality of the model.\u00a0 See the documentation for the separate properties y and z for further comments."
            },
            "z": {
                "type": "float$",
                "description": " A user-defined float value.\u00a0 The value of z is initially undefined (i.e., has an effectively random value that could be different every time you run your model); if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of z is not used by SLiM unless the optional \u201ccontinuous space\u201d facility is enabled with the dimensionality parameter to initializeSLiMOptions(), in which case z will be understood to represent the z coordinate of the individual in space (if the dimensionality is \"xyz\").\u00a0 If continuous space is not enabled, or the dimensionality is not \"xyz\", you may use z as an additional tag value of type float."
            }
        }
    },
    "InteractionType": {
        "constructor": {},
        "methods": {
            "clippedIntegral": {
                "signature": "(float)clippedIntegral(No<Individual>\u00a0receivers)",
                "description": " Returns a vector containing the integral of the interaction function as experienced by each of the individuals in receivers.\u00a0 For each given individual, the interaction function is clipped to the edges of the spatial bounds of the subpopulation that individual inhabits; the individual\u2019s spatial position must be within bounds or an error is raised.\u00a0 A periodic boundary will, correctly, not clip the interaction function.\u00a0 The interaction function is also clipped to the interaction\u2019s maximum distance; that distance must be less than half of the extent of the spatial bounds in each dimension (so that, for a given dimension, the interaction function is clipped by the spatial bounds on only one side), otherwise an error is raised.\u00a0 Note that receiver constraints are not applied; an individual might not actually receive any interactions because of those constraints, but it is still considered to have the same interaction function integral.\u00a0 If receivers is NULL, the maximal integral is returned, as would be experienced by an individual farther than the maximum distance from any edge.\u00a0 The evaluate() method must have been previously called for the receiver subpopulation, and positions saved at evaluation time will be used.\u00a0 If the InteractionType is non-spatial, this method may not be called. The computed value of the integral is not exact; it is calculated by an approximate numerical method designed to be fast, but the error should be fairly small (typically less than 1% from the true value).\u00a0 A large amount of computation will occur the first time this method is called (perhaps taking more than a second, depending upon hardware), but subsequent calls should be very fast.\u00a0 This method does not invoke interaction() callbacks; the calculated integrals are only for the interaction function itself, and so will not be accurate if interaction() callbacks modify the relationship between distance and interaction strength.\u00a0 For this reason, the overhead of the first call will not reoccur when individuals move or when the interaction is re-evaluated; for typical models, the initial overhead will be incurred only once.\u00a0 The initial overhead will reoccur, however, if the interaction function itself, or the maximum interaction distance, are changed; frequent change of those parameters may render the performance of this method unacceptable. The integral values returned by clippedIntegral() can be useful for computing interaction metrics that are scaled by the amount of \u201cinteraction field\u201d (to coin a term) that is present for a given individual, producing metrics of interaction density.\u00a0 Notably, the localPopulationDensity() method automatically incorporates the mechanics of clippedIntegral() into the calculations it performs; see that method\u2019s documentation for further discussion of this concept.\u00a0 This approach can also be useful with the interactingNeighborCount() method, provided that the interaction function is of type \"f\" (since the neighbor count does not depend upon interaction strength)."
            },
            "distance": {
                "signature": "(float)distance(object<Individual>$\u00a0receiver, [No<Individual>\u00a0exerters\u00a0=\u00a0NULL])",
                "description": " Returns a vector containing distances between receiver and the individuals in exerters.\u00a0 If exerters is NULL (the default), then a vector of the distances from receiver to all individuals in its subpopulation (including itself) is returned; this case may be handled differently internally, for greater speed, so supplying NULL is preferable to supplying the vector of all individuals in the subpopulation explicitly.\u00a0 Otherwise, all individuals in exerters must belong to a single subpopulation (but not necessarily the same subpopulation as receiver).\u00a0 The evaluate() method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.\u00a0 If the InteractionType is non-spatial, this method may not be called. Importantly, distances are calculated according to the spatiality of the InteractionType (as declared in initializeInteractionType()), not the dimensionality of the model as a whole (as declared in initializeSLiMOptions()).\u00a0 The distances returned are therefore the distances that would be used to calculate interaction strengths.\u00a0 However, distance() will return finite distances for all pairs of individuals, even if the individuals are non-interacting due to the maximum interaction distance or the interaction constraints; the distance() between an individual and itself will thus be 0.\u00a0 See interactionDistance() for an alternative distance definition."
            },
            "distanceFromPoint": {
                "signature": "(float)distanceFromPoint(float\u00a0point, object<Individual>\u00a0exerters)",
                "description": " Returns a vector containing distances between the point given by the spatial coordinates in point, which may be thought of as the \u201creceiver\u201d, and individuals in exerters.\u00a0 The point vector is interpreted as providing coordinates precisely as specified by the spatiality of the interaction type; if the interaction type\u2019s spatiality is \"xz\", for example, then point[0] is assumed to be an x value, and point[1] is assumed to be a z value.\u00a0 Be careful; this means that in general it is not safe to pass an individual\u2019s spatialPosition property for point, for example (although it is safe if the spatiality of the interaction matches the dimensionality of the simulation).\u00a0 A coordinate for a periodic spatial dimension must be within the spatial bounds for that dimension, since coordinates outside of periodic bounds are meaningless (pointPeriodic() may be used to ensure this); coordinates for non-periodic spatial dimensions are not restricted.\u00a0 All individuals in exerters must belong to a single subpopulation; the evaluate() method must have been previously called for that subpopulation, and positions saved at evaluation time will be used.\u00a0 If the InteractionType is non-spatial, this method may not be called.\u00a0 The vector point must be exactly as long as the spatiality of the InteractionType. Importantly, distances are calculated according to the spatiality of the InteractionType (as declared in initializeInteractionType()) not the dimensionality of the model as a whole (as declared in initializeSLiMOptions()).\u00a0 The distances are therefore interaction distances: the distances that are used to calculate interaction strengths.\u00a0 However, the maximum interaction distance and interaction constraints are not used. This method replaces the distanceToPoint() method that existed prior to SLiM 4."
            },
            "drawByStrength": {
                "signature": "(object)drawByStrength(object<Individual>\u00a0receiver, [integer$\u00a0count\u00a0=\u00a01], [No<Subpopulation>$\u00a0exerterSubpop\u00a0=\u00a0NULL], [logical$\u00a0returnDict\u00a0=\u00a0F])",
                "description": " Returns an object<Individual> vector containing up to count individuals drawn from exerterSubpop, or if that is NULL (the default), then from the subpopulation of receiver, which must be singleton in the default mode of operation (but see below).\u00a0 The probability of drawing particular individuals is proportional to the strength of interaction they exert upon receiver (which is zero for receiver itself).\u00a0 All exerters must belong to a single subpopulation (but not necessarily the same subpopulation as receiver).\u00a0 The evaluate() method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used. This method may be used with either spatial or non-spatial interactions, but will be more efficient with spatial interactions that set a short maximum interaction distance.\u00a0 Draws are done with replacement, so the same individual may be drawn more than once; sometimes using unique() on the result of this call is therefore desirable.\u00a0 If more than one draw will be needed, it is much more efficient to use a single call to drawByStrength(), rather than drawing individuals one at a time.\u00a0 Note that if no individuals exert a non-zero interaction strength upon receiver, the vector returned will be zero-length; it is important to consider this possibility. Beginning in SLiM 4.1, this method has a vectorized mode of operation in which the receiver parameter may be non-singleton.\u00a0 To switch the method to this mode, pass T for returnDict, rather than the default of F (the operation of which is described above).\u00a0 In this mode, the return value is a Dictionary object instead of a vector of Individual objects.\u00a0 This dictionary uses integer keys that range from 0 to N-1, where N is the number of individuals passed in receiver; these keys thus correspond directly to the indices of the individuals in receiver, and there is one entry in the dictionary for each receiver.\u00a0 The value in the dictionary, for a given integer key, is an object<Individual> vector with the individuals drawn for the corresponding receiver, exactly as described above for the non-vectorized case.\u00a0 The results for each receiver can therefore be obtained from the returned dictionary with getValue(), passing the index of the receiver.\u00a0 The speed of this mode of operation will probably be similar to the speed of making N separate non-vectorized calls to drawByStrength(), when running single-threaded.\u00a0 When running multi-threaded, however, a substantial performance improvement may be realized by using the vectorized version of this method, since the queries can then be executed in parallel.\u00a0 In this mode of operation, all receivers must belong to the same subpopulation."
            },
            "evaluate": {
                "signature": "(void)evaluate(io<Subpopulation>\u00a0subpops)",
                "description": " Snapshots model state in preparation for the use of the interaction, for the receiver and exerter subpopulations specified by subpops.\u00a0 The subpopulations may be supplied either as integer IDs, or as Subpopulation objects.\u00a0 This method will discard all previously cached data for the subpopulation(s), and will cache the current spatial positions of all individuals they contain (so that the spatial positions of those individuals may then change without disturbing the state of the interaction at the moment of evaluation).\u00a0 It will also cache which individuals in the subpopulation are eligible to act as exerters, according to the configured exerter constraints, but it will not cache such eligibility information for receiver constraints (which are applied at the time a spatial query is made).\u00a0 Particular interaction distances and strengths are not computed by evaluate(), and interaction() callbacks will not be called in response to this method; that work is deferred until required to satisfy a query (at which point the tick and cycle counters may have advanced, so be careful with the tick ranges used in defining interaction() callbacks). You must explicitly call evaluate() at an appropriate time in the tick cycle before the interaction is used, but after any relevant changes have been made to the population.\u00a0 SLiM will invalidate any existing interactions after any portion of the tick cycle in which new individuals have been born or existing individuals have died.\u00a0 In a WF model, this occurs just before late() events execute (see the WF tick cycle diagram in chapter 23), so late() events are often the appropriate place to put evaluate() calls, but first() or early() events can work too if the interaction is not needed until that point in the tick cycle anyway. In nonWF models, on the other hand, new offspring are produced just before early() events and then individuals die just before late() events (see the nonWF tick cycle diagram in chapter 24), so interactions will be invalidated twice during each tick cycle.\u00a0 This means that in a nonWF model, an interaction that influences reproduction should usually be evaluated in a first() event, while an interaction that influences fitness or mortality should usually be evaluated in an early() event (and an interaction that affects both may need to be evaluated at both times). If an interaction is never evaluated for a given subpopulation, it is guaranteed that there will be essentially no memory or computational overhead associated with the interaction for that subpopulation.\u00a0 Furthermore, attempting to query an interaction for a receiver or exerter in a subpopulation that has not been evaluated is guaranteed to raise an error."
            },
            "interactingNeighborCount": {
                "signature": "(integer)interactingNeighborCount(object<Individual>\u00a0receivers, [No<Subpopulation>$\u00a0exerterSubpop\u00a0=\u00a0NULL])",
                "description": " Returns the number of interacting individuals for each individual in receivers, within the maximum interaction distance according to the distance metric of the InteractionType, from among the exerters in exerterSubpop (or, if that is NULL, then from among all individuals in the receiver\u2019s subpopulation).\u00a0 More specifically, this method counts the number of individuals which can exert an interaction upon each receiver (which does not include the receiver itself).\u00a0 All of the receivers must belong to a single subpopulation, and all of the exerters must belong to a single subpopulation, but those two subpopulations do not need to be the same.\u00a0 The evaluate() method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used. This method is similar to nearestInteractingNeighbors() (when passed a large count so as to guarantee that all interacting individuals are returned), but this method returns only a count of the interacting individuals, not a vector containing the individuals. Note that this method uses interaction eligibility as a criterion; it will not count neighbors that do not exert an interaction upon a given receiver (due to the configured receiver or exerter constraints).\u00a0 (It also does not count a receiver as a neighbor of itself.)\u00a0 If a count of all neighbors is desired, rather than just interacting neighbors, use neighborCount().\u00a0 If the InteractionType is non-spatial, this method may not be called."
            },
            "interactionDistance": {
                "signature": "(float)interactionDistance(object<Individual>$\u00a0receiver, [No<Individual>\u00a0exerters\u00a0=\u00a0NULL])",
                "description": " Returns a vector containing interaction-dependent distances between receiver and individuals in exerters.\u00a0 If exerters is NULL (the default), then a vector of the interaction-dependent distances from receiver to all individuals in its subpopulation (including receiver itself) is returned; this case may be handled much more efficiently than if a vector of all individuals in the subpopulation is explicitly provided.\u00a0 Otherwise, all individuals in exerters must belong to a single subpopulation (but not necessarily the same subpopulation as receiver).\u00a0 The evaluate() method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.\u00a0 If the InteractionType is non-spatial, this method may not be called. Importantly, distances are calculated according to the spatiality of the InteractionType (as declared in initializeInteractionType()), not the dimensionality of the model as a whole (as declared in initializeSLiMOptions()).\u00a0 The distances returned are therefore the distances that would be used to calculate interaction strengths.\u00a0 In addition, interactionDistance() will return INF as the distance between receiver and any individual which does not exert an interaction upon receiver; the interactionDistance() between an individual and itself will thus be INF, and likewise for pairs excluded from interacting by receiver constraints, exerter constraints, or the maximum interaction distance of the interaction type.\u00a0 See distance() for an alternative distance definition."
            },
            "localPopulationDensity": {
                "signature": "(float)localPopulationDensity(object<Individual>\u00a0receivers, [No<Subpopulation>$\u00a0exerterSubpop\u00a0=\u00a0NULL])",
                "description": " Returns a vector of the local population density present at the location of each individual in receivers, which does not need to be a singleton; indeed, it can be a vector of all of the individuals in a given subpopulation.\u00a0 However, all receivers must be in the same subpopulation.\u00a0 The local population density is computed from exerters in exerterSubpop, or if that is NULL (the default), then from the receiver\u2019s subpopulation.\u00a0 The evaluate() method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used. Population density is estimated using interaction strengths, effectively doing a kernel density estimate using the interaction function as the kernel.\u00a0 What is returned is computed as the total interaction strength present at a given point, divided by the integral of the interaction function around that point after clipping by the spatial bounds of the exerter subpopulation (what one might think of as the amount of \u201cinteraction field\u201d around the point).\u00a0 This provides an estimate of local population density, in units of individuals per unit area, as a weighted average over the area covered by the interaction function, where the weight of each exerter in the average is the value of the interaction function at that exerter\u2019s position.\u00a0 This can also be thought of as a measure of the amount of interaction happening per unit of interaction field in the space surrounding the point. To calculate the clipped integral of the interaction function, this method uses the same numerical estimator used by the clippedIntegral() method of InteractionType, and all of the caveats described for that method apply here also; notably, all individuals must be within spatial bounds, the maximum interaction distance must be less than half the spatial extent of the subpopulation, and interaction() callbacks are not used (and so, for this method, are not allowed to be active).\u00a0 See the documentation for clippedIntegral() for further discussion of the details of these calculations. To calculate the total interaction strength around the position of a receiver, this method uses the same machinery as the totalOfNeighborStrengths() method of InteractionType, except that \u2013 in contrast to other InteractionType methods \u2013 the interaction strength exerted by the receiver itself is included in the total (if the exerter subpopulation is the receiver\u2019s own subpopulation).\u00a0 This is because population density at the location of an individual includes the individual itself.\u00a0 If this is not desirable, the totalOfNeighborStrengths() method should probably be used. To see the point of this method, consider a receiver located near the edge of the spatial bounds of its subpopulation.\u00a0 Some portion of the interaction function that surrounds that receiver falls outside the spatial bounds of its subpopulation, and will therefore never contain an interacting exerter.\u00a0 If, for example, interaction strengths are used as a measure of competition, this receiver will therefore have an advantage, because it will never feel any competition from the portion of its range that falls outside spatial bounds.\u00a0 However, that portion of its range is presumably also not available to the receiver itself, for foraging or hunting, in which case this advantage is not biologically realistic, but is instead just an undesirable \u201cedge effect\u201d artifact.\u00a0 Dividing by the integral of the interaction function, clipped to the spatial bounds, provides a way to compensate for this edge effect.\u00a0 A nice side effect of using local population densities instead of total interaction strengths is that the maximum interaction strength passed to setInteractionFunction() no longer matters; it cancels out when the total interaction strength is divided by the receiver\u2019s clipped integral.\u00a0 However, the shape of the interaction function does still matter; it determines the relative weights used for exerters at different distances from the position of the receiver."
            },
            "nearestInteractingNeighbors": {
                "signature": "(object)nearestInteractingNeighbors(object<Individual>\u00a0receiver, [integer$\u00a0count\u00a0=\u00a01], [No<Subpopulation>$\u00a0exerterSubpop\u00a0=\u00a0NULL], [logical$\u00a0returnDict\u00a0=\u00a0F])",
                "description": " Returns an object<Individual> vector containing up to count interacting individuals that are spatially closest to receiver, according to the distance metric of the InteractionType, from among the exerters in exerterSubpop (or, if that is NULL, then from among all individuals in the receiver\u2019s subpopulation).\u00a0 More specifically, this method returns only individuals which can exert an interaction upon receiver, which must be singleton in the default mode of operation (but see below).\u00a0 To obtain all of the interacting individuals within the maximum interaction distance of receiver, simply pass a value for count that is greater than or equal to the size of the exerter subpopulation.\u00a0 Note that if fewer than count interacting individuals are within the maximum interaction distance, the vector returned may be shorter than count, or even zero-length; it is important to check for this possibility even when requesting a single neighbor.\u00a0 If only the number of interacting individuals is needed, use interactingNeighborCount() instead.\u00a0 The evaluate() method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.\u00a0 If the InteractionType is non-spatial, this method may not be called. Note that this method uses interaction eligibility as a criterion; it will not return neighbors that cannot exert an interaction upon the receiver (due to the configured receiver or exerter constraints).\u00a0 (It will also never return the receiver as a neighbor of itself.)\u00a0 To find all neighbors of a receiver, whether they can interact with it or not, use nearestNeighbors(). Beginning in SLiM 4.1, this method has a vectorized mode of operation in which the receiver parameter may be non-singleton.\u00a0 To switch the method to this mode, pass T for returnDict, rather than the default of F (the operation of which is described above).\u00a0 In this mode, the return value is a Dictionary object instead of a vector of Individual objects.\u00a0 This dictionary uses integer keys that range from 0 to N-1, where N is the number of individuals passed in receiver; these keys thus correspond directly to the indices of the individuals in receiver, and there is one entry in the dictionary for each receiver.\u00a0 The value in the dictionary, for a given integer key, is an object<Individual> vector with the interacting neighbors found for the corresponding receiver, exactly as described above for the non-vectorized case.\u00a0 The results for each receiver can therefore be obtained from the returned dictionary with getValue(), passing the index of the receiver.\u00a0 The speed of this mode of operation will probably be similar to the speed of making N separate non-vectorized calls to nearestInteractingNeighbors(), when running single-threaded.\u00a0 When running multi-threaded, however, a substantial performance improvement may be realized by using the vectorized version of this method, since the queries can then be executed in parallel.\u00a0 In this mode of operation, all receivers must belong to the same subpopulation."
            },
            "nearestNeighbors": {
                "signature": "(object)nearestNeighbors(object<Individual>\u00a0receiver, [integer$\u00a0count\u00a0=\u00a01], [No<Subpopulation>$\u00a0exerterSubpop\u00a0=\u00a0NULL], [logical$\u00a0returnDict\u00a0=\u00a0F])",
                "description": " Returns an object<Individual> vector containing up to count individuals that are spatially closest to receiver, according to the distance metric of the InteractionType, from among the exerters in exerterSubpop (or, if that is NULL, then from among all individuals in the receiver\u2019s subpopulation).\u00a0 In the default mode of operation, receiver must be singleton (but see below).\u00a0 To obtain all of the individuals within the maximum interaction distance of receiver, simply pass a value for count that is greater than or equal to the size of individual\u2019s subpopulation.\u00a0 Note that if fewer than count individuals are within the maximum interaction distance, the vector returned may be shorter than count, or even zero-length; it is important to check for this possibility even when requesting a single neighbor.\u00a0 The evaluate() method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.\u00a0 If the InteractionType is non-spatial, this method may not be called. Note that this method does not use interaction eligibility as a criterion; it will return neighbors that could not interact with the receiver due to the configured receiver or exerter constraints.\u00a0 (It will never return the receiver as a neighbor of itself, however.)\u00a0 To find only neighbors that are eligible to exert an interaction upon the receiver, use nearestInteractingNeighbors(). Beginning in SLiM 4.1, this method has a vectorized mode of operation in which the receiver parameter may be non-singleton.\u00a0 To switch the method to this mode, pass T for returnDict, rather than the default of F (the operation of which is described above).\u00a0 In this mode, the return value is a Dictionary object instead of a vector of Individual objects.\u00a0 This dictionary uses integer keys that range from 0 to N-1, where N is the number of individuals passed in receiver; these keys thus correspond directly to the indices of the individuals in receiver, and there is one entry in the dictionary for each receiver.\u00a0 The value in the dictionary, for a given integer key, is an object<Individual> vector with the neighbors found for the corresponding receiver, exactly as described above for the non-vectorized case.\u00a0 The results for each receiver can therefore be obtained from the returned dictionary with getValue(), passing the index of the receiver.\u00a0 The speed of this mode of operation will probably be similar to the speed of making N separate non-vectorized calls to nearestNeighbors(), when running single-threaded.\u00a0 When running multi-threaded, however, a substantial performance improvement may be realized by using the vectorized version of this method, since the queries can then be executed in parallel.\u00a0 In this mode of operation, all receivers must belong to the same subpopulation."
            },
            "nearestNeighborsOfPoint": {
                "signature": "(object<Individual>)nearestNeighborsOfPoint(float\u00a0point, io<Subpopulation>$\u00a0exerterSubpop, [integer$\u00a0count\u00a0=\u00a01])",
                "description": " Returns up to count individuals in exerterSubpop that are spatially closest to point, according to the distance metric of the InteractionType.\u00a0 The subpopulation may be supplied either as an integer ID, or as a Subpopulation object.\u00a0 To obtain all of the individuals within the maximum interaction distance of point, simply pass a value for count that is greater than or equal to the size of exerterSubpop.\u00a0 Note that if fewer than count individuals are within the maximum interaction distance, the vector returned may be shorter than count, or even zero-length; it is important to check for this possibility even when requesting a single neighbor.\u00a0 The evaluate() method must have been previously called for exerterSubpop, and positions saved at evaluation time will be used.\u00a0 If the InteractionType is non-spatial, this method may not be called."
            },
            "neighborCount": {
                "signature": "(integer)neighborCount(object<Individual>\u00a0receivers, [No<Subpopulation>$\u00a0exerterSubpop\u00a0=\u00a0NULL])",
                "description": " Returns the number of neighbors for each individual in receivers, within the maximum interaction distance according to the distance metric of the InteractionType, from among the individuals in exerterSubpop (or, if that is NULL, then from among all individuals in the receiver\u2019s subpopulation).\u00a0 All of the receivers must belong to a single subpopulation, and all of the exerters must belong to a single subpopulation, but those two subpopulations do not need to be the same.\u00a0 The evaluate() method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used. This method is similar to nearestNeighbors() (when passed a large count so as to guarantee that all neighbors are returned), but this method returns only a count of the individuals, not a vector containing the individuals. Note that this method does not use interaction eligibility as a criterion; it will count neighbors that cannot exert an interaction upon a receiver (due to the configured receiver or exerter constraints).\u00a0 (It still does not count a receiver as a neighbor of itself, however.)\u00a0 If a count of only interacting neighbors is desired, use interactingNeighborCount().\u00a0 If the InteractionType is non-spatial, this method may not be called."
            },
            "neighborCountOfPoint": {
                "signature": "(integer$)neighborCountOfPoint(float\u00a0point, io<Subpopulation>$\u00a0exerterSubpop)",
                "description": " Returns the number of individuals in exerterSubpop that are within the maximum interaction distance according to the distance metric of the InteractionType.\u00a0 The subpopulation may be supplied either as an integer ID, or as a Subpopulation object.\u00a0 The evaluate() method must have been previously called for exerterSubpop, and positions saved at evaluation time will be used.\u00a0 If the InteractionType is non-spatial, this method may not be called. This method is similar to nearestNeighborsOfPoint() (when passed a large count so as to guarantee that all neighbors are returned), but this method returns only a count of the individuals, not a vector containing the individuals."
            },
            "setConstraints": {
                "signature": "(void)setConstraints(string$\u00a0who, [Ns$\u00a0sex\u00a0=\u00a0NULL], [Ni$\u00a0tag\u00a0=\u00a0NULL], [Ni$\u00a0minAge\u00a0=\u00a0NULL], [Ni$\u00a0maxAge\u00a0=\u00a0NULL], [Nl$\u00a0migrant\u00a0=\u00a0NULL], [Nl$\u00a0tagL0\u00a0=\u00a0NULL], [Nl$\u00a0tagL1\u00a0=\u00a0NULL], [Nl$\u00a0tagL2\u00a0=\u00a0NULL], [Nl$\u00a0tagL3\u00a0=\u00a0NULL], [Nl$\u00a0tagL4\u00a0=\u00a0NULL])",
                "description": " Sets constraints upon which individuals can be receivers and/or exerters, making the target InteractionType measure interactions between only subsets of the population.\u00a0 The parameter who specifies upon whom the specified constraints apply; it may be \"exerter\" to set constraints upon exerters, \"receiver\" to set constraints upon receivers, or \"both\" to set constraints upon both.\u00a0 If \"both\" is used, the same constraints are set for both exerters and receivers; different constraints can be set for exerters versus receivers by making a separate call to setConstraints() for each.\u00a0 Constraints only affect queries that involve the concept of interaction; for example, they will affect the result of nearestInteractingNeighbors(), but not the result of nearestNeighbors().\u00a0 The constraints specified by a given call to setConstraints() override all previously set constraints for the category specified (receivers, exerters, or both). There is a general policy for the remaining arguments: they are NULL by default, and if NULL is used, it specifies \u201cno constraint\u201d for that property (removing any currently existing constraint for that property).\u00a0 The sex parameter constrains the sex of individuals; it may be \"M\" or \u201cF\" (or \"*\" as another way of specifying no constraint, for historical reasons).\u00a0 If sex is \"M\" or \"F\", the individuals to which the constraint is applied (potential receivers/exerters) must belong to a sexual species.\u00a0 The tag parameter constrains the tag property of individuals; if this set, the individuals to which the constraint is applied must have defined tag values.\u00a0 The minAge and maxAge properties constrain the age property of individuals to the given minimum and/or maximum values; these constraints can only be used in nonWF models.\u00a0 The migrant property constraints the migrant property of individuals (T constrains to only migrants, F to only non-migrants).\u00a0 Finally, the tagL0, tagL1, tagL2, tagL3, and tagL4 properties constrain the corresponding logical properties of individuals, requiring them to be either T or F as specified; the individuals to which these constraints are applied must have defined values for the constrained property or properties.\u00a0 Again, NULL should be supplied (as it is by default) for any property which you do not wish to constrain. These constraints may be used in any combination, as desired.\u00a0 For example, calling setConstraints(\"receivers\", sex=\"M\", minAge=5, tagL0=T) constrains the interaction type\u2019s operation so that receivers must be males, with an age of at least 5, with a tagL0 property value of T.\u00a0 For that configuration the potential receivers used with the interaction type must be sexual (since sex is specified), must be in a nonWF model (since minAge is specified), and must have a defined value for their tagL0 property (since that property is constrained).\u00a0 Note that the sexSegregation parameter to initializeInteractionType() is a shortcut which does the same thing as the corresponding calls to setConstraints(). Exerter constraints are applied at evaluate() time, whereas receiver constraints are applied at query time; see the InteractionType class documentation for further discussion.\u00a0 The interaction constraints for an interaction type are normally a constant in simulations; in any case, they cannot be changed when an interaction has already been evaluated, so either they should be set prior to evaluation, or unevaluate() should be called first."
            },
            "setInteractionFunction": {
                "signature": "(void)setInteractionFunction(string$\u00a0functionType, ...)",
                "description": " Set the function used to translate spatial distances into interaction strengths for an interaction type.\u00a0 The functionType may be \"f\", in which case the ellipsis ... should supply a numeric$ fixed interaction strength; \"l\", in which case the ellipsis should supply a numeric$ maximum strength for a linear function; \"e\", in which case the ellipsis should supply a numeric$ maximum strength and a numeric$ lambda (rate) parameter for a negative exponential function; \"n\", in which case the ellipsis should supply a numeric$ maximum strength and a numeric$ sigma (standard deviation) parameter for a Gaussian function; \"c\", in which case the ellipsis should supply a numeric$ maximum strength and a numeric$ scale parameter for a Cauchy distribution function; or \"t\", in which case the ellipsis should supply a numeric$ maximum strength, a numeric$ degrees of freedom, and a numeric$ scale parameter for a t-distribution function.\u00a0 See the InteractionType class documentation for discussions of these interaction functions.\u00a0 Non-spatial interactions must use function type \"f\", since no distance values are available in that case. The interaction function for an interaction type is normally a constant in simulations; in any case, it cannot be changed when an interaction has already been evaluated, so either it should be set prior to evaluation, or unevaluate() should be called first."
            },
            "strength": {
                "signature": "(float)strength(object<Individual>$\u00a0receiver, [No<Individual>\u00a0exerters\u00a0=\u00a0NULL])",
                "description": " Returns a vector containing the interaction strengths exerted upon receiver by the individuals in exerters.\u00a0 If exerters is NULL (the default), then a vector of the interaction strengths exerted by all individuals in the subpopulation of receiver (including receiver itself, with a strength of 0.0) is returned; this case may be handled much more efficiently than if a vector of all individuals in the subpopulation is explicitly provided.\u00a0 Otherwise, all individuals in exerters must belong to a single subpopulation (but not necessarily the same subpopulation as receiver).\u00a0 The evaluate() method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used. If the strengths of interactions exerted by a single individual upon multiple individuals are needed instead (the inverse of what this method provides), multiple calls to this method will be necessary, one per pairwise interaction queried; the interaction engine is not optimized for the inverse case, and so it will likely be quite slow to compute.\u00a0 If the interaction is reciprocal and has the same receiver and exerter constraints, the opposite query should provide identical results in a single efficient call (because then the interactions exerted are equal to the interactions received); otherwise, the best approach might be to define a second interaction type representing the inverse interaction that you wish to be able to query efficiently."
            },
            "testConstraints": {
                "signature": "(lo<Individual>)testConstraints(object<Individual>\u00a0individuals, string$\u00a0constraints, [logical$\u00a0returnIndividuals\u00a0=\u00a0F])",
                "description": " Tests the individuals in the parameter individuals against the interaction constraints specified by constraints.\u00a0 The value of constraints may be \"receiver\" to use the receiver constraints, or \"exerter\" to use the exerter constraints.\u00a0 If returnIndividuals is F (the default), a logical vector will be returned, with T values indicating that the corresponding individual satisfied the constraints, F values indicating that it did not.\u00a0 If returnIndividuals is T, an object vector of class Individual will be returned containing only those elements of individuals that satisfied the constraints (in the same order as individuals).\u00a0 Note that unlike most queries, the InteractionType does not need to have been evaluated before calling this method, and the individuals passed in need not belong to a single population or even a single species. This method can be useful for narrowing a vector of individuals down to just those that satisfy constraints.\u00a0 Outside the context of InteractionType, similar functionality is provided by the Subpopulation method subsetIndividuals().\u00a0 Note that the use of testConstraints() is somewhat rare; usually, queries are evaluated across a vector of individuals, each of which might or might not satisfy the defined constraints.\u00a0 Individuals that do not satisfy constraints do not participate in interactions, so their interaction strength with other individuals will simply be zero. See the setConstraints() method to set up constraints, as well as the sexSegregation parameter to initializeInteractionType().\u00a0 Note that if the constraints tested involve tag values (including tagL0 / tagL1 / tagL2 / tagL3 / tagL4), the corresponding property or properties of the tested individuals must be defined (i.e., must have been set to a value), or an error will result because the constraints cannot be applied."
            },
            "totalOfNeighborStrengths": {
                "signature": "(float)totalOfNeighborStrengths(object<Individual>\u00a0receivers, [No<Subpopulation>$\u00a0exerterSubpop\u00a0=\u00a0NULL])",
                "description": " Returns a vector of the total interaction strength felt by each individual in receivers by the exerters in exerterSubpop (or, if that is NULL, then by all individuals in the receiver\u2019s subpopulation).\u00a0 The receivers parameter does not need to be a singleton; indeed, it can be a vector of all of the individuals in a given subpopulation.\u00a0 All of the receivers must belong to a single subpopulation, and all of the exerters must belong to a single subpopulation, but those two subpopulations do not need to be the same.\u00a0 The evaluate() method must have been previously called for the receiver and exerter subpopulations, and positions saved at evaluation time will be used.\u00a0 If the InteractionType is non-spatial, this method may not be called. For one individual, this is essentially the same as calling nearestInteractingNeighbors() with a large count so as to obtain the complete vector of all interacting neighbors, calling strength() for each of those interactions to get each interaction strength, and adding those interaction strengths together with sum().\u00a0 This method is much faster than that implementation, however, since all of that work is done as a single operation.\u00a0 Also, totalOfNeighborStrengths() can total up interactions for more than one receiver in a single vectorized call. Similarly, for one individual this is essentially the same as calling strength() to get the interaction strengths between a receiver and all individuals in the exerter subpopulation, and then calling sum().\u00a0 Again, this method should be much faster, since this algorithm looks only at neighbors, whereas calling strength() directly assesses interaction strengths with all other individuals.\u00a0 This will make a particularly large difference when the subpopulation size is large and the maximum distance of the InteractionType is small. See localPopulationDensity() for a related method that calculates the total interaction strength divided by the amount of \u201cinteraction field\u201d present for an individual (i.e., the integral of the interaction function clipped to the spatial bounds of the subpopulation) to provide an estimate of the \u201cinteraction density\u201d felt by an individual."
            },
            "unevaluate": {
                "signature": "(void)unevaluate(void)",
                "description": " Discards all evaluation of this interaction, for all subpopulations.\u00a0 The state of the InteractionType is reset to a state prior to evaluation.\u00a0 This can be useful if the model state has changed in such a way that the evaluation already conducted is no longer valid.\u00a0 For example, if the maximum distance, the interaction function, or the receiver or exerter constraints of the InteractionType need to be changed with immediate effect, or if the data used by an interaction() callback has changed in such a way that previously calculated interaction strengths are no longer correct, unevaluate() allows the interaction to begin again from scratch. In WF models, all interactions are automatically reset to an unevaluated state at the moment when the new offspring generation becomes the parental generation (at step 4 in the tick cycle). In nonWF models, all interactions are automatically reset to an unevaluated state twice per tick: immediately after reproduction() callbacks have completed (after step 1 in the tick cycle), and immediately before viability/survival selection (before step 4 in the tick cycle). Given this automatic invalidation, most simulations have no reason to call unevaluate()."
            }
        },
        "properties": {
            "id": {
                "type": "integer$",
                "description": " The identifier for this interaction type; for interaction type i3, for example, this is 3."
            },
            "maxDistance": {
                "type": "float$",
                "description": " The maximum distance over which this interaction will be evaluated.\u00a0 For inter-individual distances greater than maxDistance, the interaction strength will be zero."
            },
            "reciprocal": {
                "type": "logical$",
                "description": " The reciprocality of the interaction, as specified in initializeInteractionType().\u00a0 This will be T for reciprocal interactions (those for which the interaction strength of B upon A is equal to the interaction strength of A upon B), and F otherwise."
            },
            "sexSegregation": {
                "type": "string$",
                "description": " The sex-segregation of the interaction, as specified in initializeInteractionType() or with setConstraints().\u00a0 For non-sexual simulations, this will be \"**\".\u00a0 For sexual simulations, this string value indicates the sex of individuals feeling the interaction, and the sex of individuals exerting the interaction; see initializeInteractionType() for details."
            },
            "spatiality": {
                "type": "string$",
                "description": " The spatial dimensions used by the interaction, as specified in initializeInteractionType().\u00a0 This will be \"\" (the empty string) for non-spatial interactions, or \"x\", \"y\", \"z\", \"xy\", \"xz\", \"yz\", or \"xyz\", for interactions using those spatial dimensions respectively.\u00a0 The specified dimensions are used to calculate the distances between individuals for this interaction.\u00a0 The value of this property is always the same as the value given to initializeInteractionType()."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to interaction types."
            }
        }
    },
    "LogFile": {
        "constructor": {},
        "methods": {
            "addCustomColumn": {
                "signature": "(void)addCustomColumn(string$\u00a0columnName, string$\u00a0source, [*\u00a0context\u00a0=\u00a0NULL])",
                "description": " Adds a new data column with its name provided by columnName.\u00a0 The new column will be logged each time that a row is generated, either by automatic logging or by a call to logRow().\u00a0 The value for the column, when a given row is generated, will be produced by the code supplied in source, which is expected to return either NULL (which will write out NA), or a singleton value of any non-object type. The context parameter will be set up as a pseudo-parameter, named context, when source is called, allowing the same source code to be used to generate values for multiple data columns; you might, for example, provide the particular Subpopulation object here that you wish source to use for its calculations.\u00a0 This is optional; if the default value of NULL is used, then context will be NULL when source is called. See addMeanSDColumns() for a useful variant."
            },
            "addCycle": {
                "signature": "(void)addCycle([No<Species>$\u00a0species\u00a0=\u00a0NULL])",
                "description": " Adds a new data column that provides the cycle counter for species (the same as the value of the cycle property of that species).\u00a0 The new column will be logged each time that a row is generated, either by automatic logging or by a call to logRow().\u00a0 In single-species models, species may be NULL to indicate that single species.\u00a0 The column will simply be named cycle in single-species models; an underscore and the name of the species will be appended in multispecies models."
            },
            "addCycleStage": {
                "signature": "(void)addCycleStage(void)",
                "description": " Adds a new data column that provides the cycle stage, named cycle_stage.\u00a0 The new column will be logged each time that a row is generated, either by automatic logging or by a call to logRow().\u00a0 The stage is provided as a string, and will typically be \"first\", \"early\", \"late\", or \"end\" (the latter used for the point in time at which end-of-tick automatic logging occurs).\u00a0 Other possible values are discussed in the documentation for the cycleStage property of Community, which this column reflects."
            },
            "addKeysAndValuesFrom": {
                "signature": "(void)addKeysAndValuesFrom(object$\u00a0source)",
                "description": " This Dictionary method has an override in LogFile to make it illegal to call, since LogFile manages its Dictionary entries."
            },
            "addMeanSDColumns": {
                "signature": "(void)addMeanSDColumns(string$\u00a0columnName, string$\u00a0source, [*\u00a0context\u00a0=\u00a0NULL])",
                "description": " Adds two new data columns with names of columnName_mean and columnName_sd.\u00a0 The new columns will be logged each time that a row is generated, either by automatic logging or by a call to logRow().\u00a0 When a given row is generated, the code supplied in source is expected to return either a zero-length vector of any type including NULL (which will write out NA to both columns), or a non-zero-length vector of integer or float values.\u00a0 In the latter case, the result vector will be summarized in the two columns by its mean and standard deviation respectively.\u00a0 If the result vector has exactly one value, the standard deviation will be written as NA.\u00a0 The context parameter is set up as a pseudo-parameter when source is called, as described in addCustomColumn()."
            },
            "addPopulationSexRatio": {
                "signature": "(void)addPopulationSexRatio([No<Species>$\u00a0species\u00a0=\u00a0NULL])",
                "description": " Adds a new data column that provides the population sex ratio M:(M+F) for species.\u00a0 The new column will be logged each time that a row is generated, either by automatic logging or by a call to logRow().\u00a0 In single-species models, species may be NULL to indicate that single species.\u00a0 The column will simply be named sex_ratio in single-species models; an underscore and the name of the species will be appended in multispecies models.\u00a0 If the species is hermaphroditic, NA will be written."
            },
            "addPopulationSize": {
                "signature": "(void)addPopulationSize([No<Species>$\u00a0species\u00a0=\u00a0NULL])",
                "description": " Adds a new data column that provides the total population size for species.\u00a0 The new column will be logged each time that a row is generated, either by automatic logging or by a call to logRow().\u00a0 In single-species models, species may be NULL to indicate that single species.\u00a0 The column will simply be named num_individuals in single-species models; an underscore and the name of the species will be appended in multispecies models."
            },
            "addSubpopulationSexRatio": {
                "signature": "(void)addSubpopulationSexRatio(io<Subpopulation>$\u00a0subpop)",
                "description": " Adds a new data column that provides the sex ratio M:(M+F) of the subpopulation subpop, named pX_sex_ratio.\u00a0 The new column will be logged each time that a row is generated, either by automatic logging or by a call to logRow().\u00a0 If the subpopulation exists but has a size of zero, NA will be written."
            },
            "addSubpopulationSize": {
                "signature": "(void)addSubpopulationSize(io<Subpopulation>$\u00a0subpop)",
                "description": " Adds a new data column that provides the size of the subpopulation subpop, named pX_num_individuals.\u00a0 The new column will be logged each time that a row is generated, either by automatic logging or by a call to logRow().\u00a0 If the subpopulation exists but has a size of zero, 0 will be written."
            },
            "addSuppliedColumn": {
                "signature": "(void)addSuppliedColumn(string$\u00a0columnName)",
                "description": " Adds a new data column with its name provided by columnName.\u00a0 The new column will be logged each time that a row is generated, either by automatic logging or by a call to logRow().\u00a0 The value for the column is initially undefined, and will be written as NA.\u00a0 A different value may (optionally) be provided by calling setSuppliedValue() with a value for columnName.\u00a0 That value will be used for the column the next time a row is generated (whether automatically or by a call to logRow()), and the column\u2019s value will subsequently be undefined again.\u00a0 In other words, for any given logged row the default of NA may be kept, or a different value may be supplied.\u00a0 This allows the value for the column to be set at any point during the tick cycle, which can be convenient if the column\u2019s value depends upon transient state that is no longer available at the time the row is logged."
            },
            "addTick": {
                "signature": "(void)addTick(void)",
                "description": " Adds a new data column, named tick, that provides the tick number for the simulation.\u00a0 The new column will be logged each time that a row is generated, either by automatic logging or by a call to logRow()."
            },
            "clearKeysAndValues": {
                "signature": "(void)clearKeysAndValues(void)",
                "description": " This Dictionary method has an override in LogFile to make it illegal to call, since LogFile manages its Dictionary entries."
            },
            "flush": {
                "signature": "(void)flush(void)",
                "description": " Flushes all buffered data to the output file, synchronously.\u00a0 This will make the contents of the file on disk be up-to-date with the running simulation.\u00a0 Flushing frequently may entail a small performance penalty.\u00a0 More importantly, if .gz compression has been requested with compress=T the size of the resulting file will be larger \u2013 potentially much larger \u2013 if flush() is called frequently.\u00a0 Note that automatic periodic flushing can be requested with the flushInterval parameter to createLogFile()."
            },
            "logRow": {
                "signature": "(void)logRow(void)",
                "description": " This logs a new row of data, by evaluating all of the generators added to the LogFile with add...() calls.\u00a0 Note that the new row may be buffered, and thus may not be written out to disk immediately; see flush().\u00a0 This method may be used instead of, or in conjunction with, automatic logging. You can get the LogFile instance, in order to call logRow() on it, from community.logFiles, or you can remember it in a global constant with defineConstant()."
            },
            "setLogInterval": {
                "signature": "(void)setLogInterval([Ni$\u00a0logInterval\u00a0=\u00a0NULL])",
                "description": " Sets the automatic logging interval.\u00a0 A logInterval of NULL stops automatic logging immediately.\u00a0 Other values request that a new row should be logged (as if logRow() were called) at the end of every logInterval ticks (just before the tick count increment, in both WF and nonWF models), starting at the end of the tick in which setLogInterval() was called."
            },
            "setFilePath": {
                "signature": "(void)setFilePath(string$\u00a0filePath, [Ns\u00a0initialContents\u00a0=\u00a0NULL], [logical$\u00a0append\u00a0=\u00a0F], [Nl$\u00a0compress\u00a0=\u00a0NULL], [Ns$\u00a0sep\u00a0=\u00a0NULL])",
                "description": " Redirects the LogFile to write new rows to a new filePath.\u00a0 Any rows that have been buffered but not flushed will be written to the previous file first, as if flush() had been called.\u00a0 With this call, new initialContents may be supplied, which will either replace any existing file or will be appended to it, depending upon the value of append.\u00a0 New values may be supplied for compress and sep; the meaning of these parameters is identical to their meaning in createLogFile(), except that a value of NULL for these means \u201cdo not change this setting from its previous value\u201d.\u00a0 In effect, then, this method lets you start a completely new log file at a new path, without having to create and configure a new LogFile object.\u00a0 The new file will be created (or appended) synchronously, with the specified initial contents."
            },
            "setSuppliedValue": {
                "signature": "(void)setSuppliedValue(string$\u00a0columnName, +$\u00a0value)",
                "description": " Registers a value, passed in value, to be used for the supplied column named columnName when a row is next logged.\u00a0 This column must have been added with addSuppliedColumn().\u00a0 A value of NULL may be passed to log NA, but logging NA is the default behavior for supplied columns in any case.\u00a0 Otherwise, the value must be a singleton, and its type should match the values previously supplied for the column (otherwise the log file may be difficult to parse, since the values within the column will not be of one consistent type).\u00a0 See addSuppliedColumn() for further details."
            },
            "setValue": {
                "signature": "(void)setValue(is$\u00a0key, *\u00a0value)",
                "description": " This Dictionary method has an override in LogFile to make it illegal to call, since LogFile manages its Dictionary entries."
            },
            "willAutolog": {
                "signature": "(logical$)willAutolog(void)",
                "description": " Returns T if the log file is configured to log a new row automatically at the end of the current tick; otherwise, returns F.\u00a0 This is useful for calculating a value that will be logged only in ticks when the value is needed."
            }
        },
        "properties": {
            "filePath": {
                "type": "string$",
                "description": " The path of the log file being written to.\u00a0 This may be changed with setFilePath()."
            },
            "logInterval": {
                "type": "integer$",
                "description": " The interval for automatic logging; a new row of data will be logged every logInterval ticks.\u00a0 This may be set with the logInterval parameter to createLogFile() and changed with setLogInterval().\u00a0 If automatic logging has been disabled, this property will be 0."
            },
            "precision": {
                "type": "integer$",
                "description": " The precision of float output.\u00a0 To be exact, precision specifies the preferred number of significant digits that will be output for float values.\u00a0 The default is 6; values in [1,22] are legal, but 17 is probably the largest value that makes sense given the limits of double-precision floating point."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use."
            }
        }
    },
    "Mutation": {
        "constructor": {},
        "methods": {
            "setMutationType": {
                "signature": "(void)setMutationType(io<MutationType>$\u00a0mutType)",
                "description": " Set the mutation type of the mutation to mutType (which may be specified as either an integer identifier or a MutationType object).\u00a0 This implicitly changes the dominance coefficient of the mutation to that of the new mutation type, since the dominance coefficient is a property of the mutation type.\u00a0 On the other hand, the selection coefficient of the mutation is not changed, since it is a property of the mutation object itself; it can be changed explicitly using the setSelectionCoeff() method if so desired. The mutation type of a mutation is normally a constant in simulations, so be sure you know what you are doing.\u00a0 Changing this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the Species method recalculateFitness() \u2013 but see the documentation of that method for caveats. In nucleotide-based models, a restriction applies: nucleotide-based mutations may not be changed to a non-nucleotide-based mutation type, and non-nucleotide-based mutations may not be changed to a nucleotide-based mutation type."
            },
            "setSelectionCoeff": {
                "signature": "(void)setSelectionCoeff(float$\u00a0selectionCoeff)",
                "description": " Set the selection coefficient of the mutation to selectionCoeff.\u00a0 The selection coefficient will be changed for all individuals that possess the mutation, since they all share a single Mutation object (note that the dominance coefficient will remain unchanged, as it is determined by the mutation type). This is normally a constant in simulations, so be sure you know what you are doing; often setting up a mutationEffect() callback is preferable, in order to modify the selection coefficient in a more limited and controlled fashion.\u00a0 Changing this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the Species method recalculateFitness() \u2013 but see the documentation of that method for caveats."
            }
        },
        "properties": {
            "id": {
                "type": "integer$",
                "description": " The identifier for this mutation.\u00a0 Each mutation created during a run receives an immutable identifier that will be unique across the duration of the run.\u00a0 These identifiers are not re-used during a run, except that if a population file is loaded from disk, the loaded mutations will receive their original identifier values as saved in the population file."
            },
            "isFixed": {
                "type": "logical$",
                "description": " T if the mutation has fixed (in the SLiM sense of having been converted to a Substitution object), F otherwise.\u00a0 Since fixed/substituted mutations are removed from the simulation, you will only see this flag be T if you have held onto a mutation beyond its usual lifetime."
            },
            "isSegregating": {
                "type": "logical$",
                "description": " T if the mutation is segregating (in the SLiM sense of not having been either lost or converted to a Substitution object), F otherwise.\u00a0 Since both lost and fixed/substituted mutations are removed from the simulation, you will only see this flag be F if you have held onto a mutation beyond its usual lifetime.\u00a0 Note that if isSegregating is F, isFixed will let you determine whether the mutation is no longer segregating because it was lost, or because it fixed."
            },
            "mutationType": {
                "type": "object<MutationType>$",
                "description": " The MutationType from which this mutation was drawn."
            },
            "nucleotide": {
                "type": "string$",
                "description": " A string representing the nucleotide associated with this mutation; this will be \"A\", \"C\", \"G\", or \"T\".\u00a0 If the mutation is not nucleotide-based, this property is unavailable."
            },
            "nucleotideValue": {
                "type": "integer$",
                "description": " An integer representing the nucleotide associated with this mutation; this will be 0 (A), 1 (C), 2 (G), or 3 (T).\u00a0 If the mutation is not nucleotide-based, this property is unavailable."
            },
            "originTick": {
                "type": "integer$",
                "description": " The tick in which this mutation arose."
            },
            "position": {
                "type": "integer$",
                "description": " The position in the chromosome of this mutation."
            },
            "selectionCoeff": {
                "type": "float$",
                "description": " The selection coefficient of the mutation, drawn from the distribution of fitness effects of its MutationType.\u00a0 If a mutation has a selectionCoeff of s, the multiplicative fitness effect of the mutation in a homozygote is 1+s; in a heterozygote it is 1+hs, where h is the dominance coefficient kept by the mutation type. Note that this property has a quirk: it is stored internally in SLiM using a single-precision float, not the double-precision float type normally used by Eidos.\u00a0 This means that if you set a mutation mut\u2019s selection coefficient to some number x, mut.selectionCoeff==x may be F due to floating-point rounding error.\u00a0 Comparisons of floating-point numbers for exact equality is often a bad idea, but this is one case where it may fail unexpectedly.\u00a0 Instead, it is recommended to use the id or tag properties to identify particular mutations."
            },
            "subpopID": {
                "type": "integer$",
                "description": " The identifier of the subpopulation in which this mutation arose.\u00a0 This property can be used to track the ancestry of mutations through their subpopulation of origin. If you don\u2019t care which subpopulation a mutation originated in, the subpopID may be used as an arbitrary integer \u201ctag\u201d value for any purpose you wish; SLiM does not do anything with the value of subpopID except propagate it to Substitution objects and report it in output.\u00a0 (It must still be >= 0, however, since SLiM object identifiers are limited to nonnegative integers)."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use."
            }
        }
    },
    "MutationType": {
        "constructor": {},
        "methods": {
            "drawSelectionCoefficient": {
                "signature": "(float)drawSelectionCoefficient([integer$\u00a0n\u00a0=\u00a01])",
                "description": " Draws and returns a vector of n selection coefficients using the currently defined distribution of fitness effects (DFE) for the target mutation type.\u00a0 If the DFE is type \"s\", this method will result in synchronous execution of the DFE\u2019s script."
            },
            "setDistribution": {
                "signature": "(void)setDistribution(string$\u00a0distributionType, ...)",
                "description": " Set the distribution of fitness effects for a mutation type.\u00a0 The distributionType may be \"f\", in which case the ellipsis ... should supply a numeric$ fixed selection coefficient; \"e\", in which case the ellipsis should supply a numeric$ mean selection coefficient for the exponential distribution; \"g\", in which case the ellipsis should supply a numeric$ mean selection coefficient and a numeric$ alpha shape parameter for a gamma distribution; \"n\", in which case the ellipsis should supply a numeric$ mean selection coefficient and a numeric$ sigma (standard deviation) parameter for a normal distribution; \"p\", in which case the ellipsis should supply a numeric$ mean selection coefficient and a numeric$ scale parameter for a Laplace distribution; \"w\", in which case the ellipsis should supply a numeric$ \u03bb scale parameter and a numeric$ k shape parameter for a Weibull distribution; or \"s\", in which case the ellipsis should supply a string$ Eidos script parameter.\u00a0 The DFE for a mutation type is normally a constant in simulations, so be sure you know what you are doing."
            }
        },
        "properties": {
            "color": {
                "type": "string$",
                "description": " The color used to display mutations of this type in SLiMgui.\u00a0 Outside of SLiMgui, this property still exists, but is not used by SLiM.\u00a0 Colors may be specified by name, or with hexadecimal RGB values of the form \"#RRGGBB\".\u00a0 If color is the empty string, \"\", SLiMgui\u2019s default (selection-coefficient\u2013based) color scheme is used; this is the default for new MutationType objects."
            },
            "colorSubstitution": {
                "type": "string$",
                "description": " The color used to display substitutions of this type in SLiMgui (see the discussion for the colorSubstitution property of the Chromosome class for details).\u00a0 Outside of SLiMgui, this property still exists, but is not used by SLiM.\u00a0 Colors may be specified by name, or with hexadecimal RGB values of the form \"#RRGGBB\".\u00a0 If colorSubstitution is the empty string, \"\", SLiMgui\u2019s default (selection-coefficient\u2013based) color scheme is used; this is the default for new MutationType objects."
            },
            "convertToSubstitution": {
                "type": "logical$",
                "description": " This property governs whether mutations of this mutation type will be converted to Substitution objects when they reach fixation. In WF models this property is T by default, since conversion to Substitution objects provides large speed benefits; it should be set to F only if necessary, and only on the mutation types for which it is necessary.\u00a0 This might be needed, for example, if you are using a mutationEffect() callback to implement an epistatic relationship between mutations; a mutation epistatically influencing the fitness of other mutations through a mutationEffect() callback would need to continue having that influence even after reaching fixation, but if the simulation were to replace the fixed mutation with a Substitution object the mutation would no longer be considered in fitness calculations (unless the callback explicitly consulted the list of Substitution objects kept by the simulation).\u00a0 Other script-defined behaviors in mutationEffect(), interaction(), mateChoice(), modifyChild(), and recombination() callbacks might also necessitate the disabling of substitution for a given mutation type; this is an important consideration to keep in mind. In contrast, for nonWF models this property is F by default, because even mutations with no epistatis or other indirect fitness effects will continue to influence the survival probabilities of individuals.\u00a0 For nonWF models, only neutral mutation types with no epistasis or other side effects can safely be converted to substitutions upon fixation.\u00a0 When such a pure-neutral mutation type is defined in a nonWF model, this property should be set to T to tell SLiM that substitution is allowed; this may have very large positive effects on performance, so it is important to remember when modeling background neutral mutations. SLiM consults this flag at the end of each tick when deciding whether to substitute each fixed mutation.\u00a0 If this flag is T, all eligible fixed mutations will be converted at the end of the current tick, even if they were previously left unconverted because of the previous value of the flag.\u00a0 Setting this flag to F will prevent future substitutions, but will not cause any existing Substitution objects to be converted back into Mutation objects."
            },
            "distributionParams": {
                "type": "fs",
                "description": " The parameters that configure the chosen distribution of fitness effects.\u00a0 This will be of type string for DFE type \"s\", and type float for all other DFE types."
            },
            "distributionType": {
                "type": "string$",
                "description": " The type of distribution of fitness effects; one of \"f\", \"g\", \"e\", \"n\", \"w\", or \"s\":"
            },
            "dominanceCoeff": {
                "type": "float$",
                "description": " The dominance coefficient used for mutations of this type when heterozygous.\u00a0 Changing this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the Species method recalculateFitness() \u2013 but see the documentation of that method for caveats. Note that the dominance coefficient is not bounded.\u00a0 A dominance coefficient greater than 1.0 may be used to achieve an overdominance effect.\u00a0 By making the selection coefficient very small and the dominance coefficient very large, an overdominance scenario in which both homozygotes have the same fitness may be approximated, to a nearly arbitrary degree of precision. Note that this property has a quirk: it is stored internally in SLiM using a single-precision float, not the double-precision float type normally used by Eidos.\u00a0 This means that if you set a mutation type muttype\u2019s dominance coefficient to some number x, muttype.dominanceCoeff==x may be F due to floating-point rounding error.\u00a0 Comparisons of floating-point numbers for exact equality is often a bad idea, but this is one case where it may fail unexpectedly.\u00a0 Instead, it is recommended to use the id or tag properties to identify particular mutation types."
            },
            "haploidDominanceCoeff": {
                "type": "float$",
                "description": " The dominance coefficient used for mutations of this type when they occur opposite a null genome (as in sex-chromosome models and models involving haploids).\u00a0 This defaults to 1.0, and is used only in models where null genomes are present; the dominanceCoeff property is the dominance coefficient used in most circumstances.\u00a0 Changing this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the Species method recalculateFitness() \u2013 but see the documentation of that method for caveats. As with the dominanceCoeff property, this is stored internally using a single-precision float; see the documentation for dominanceCoeff for discussion."
            },
            "id": {
                "type": "integer$",
                "description": " The identifier for this mutation type; for mutation type m3, for example, this is 3."
            },
            "mutationStackGroup": {
                "type": "integer$",
                "description": " The group into which this mutation type belongs for purposes of mutation stacking policy.\u00a0 This is equal to the mutation type\u2019s id by default.\u00a0 See mutationStackPolicy, below, for discussion. In nucleotide-based models, the stacking group for nucleotide-based mutation types is always -1, and cannot be changed.\u00a0 Non-nucleotide-based mutation types may also be set to share the -1 stacking group, if they should participate in the same stacking policy as nucleotide-based mutations, but that would be quite unusual."
            },
            "mutationStackPolicy": {
                "type": "string$",
                "description": " This property and the mutationStackGroup property together govern whether mutations of this mutation type\u2019s stacking group can \u201cstack\u201d \u2013 can occupy the same position in a single individual.\u00a0 A set of mutation types with the same value for mutationStackGroup is called a \u201cstacking group\u201d, and all mutation types in a given stacking group must have the same mutationStackPolicy value, which defines the stacking behavior of all mutations of the mutation types in the stacking group.\u00a0 In other words, one stacking group might allow its mutations to stack, while another stacking group might not, but the policy within each stacking group must be unambiguous. This property is \"s\" by default, indicating that mutations in this stacking group should be allowed to stack without restriction.\u00a0 If the policy is set to \"f\", the first mutation of stacking group at a given site is retained; further mutations of this stacking group at the same site are discarded with no effect.\u00a0 This can be useful for modeling one-way changes; once a gene is disabled by a premature stop codon, for example, you might wish to assume, for simplicity, that further mutations cannot alter that fact.\u00a0 If the policy is set to \"l\", the last mutation of this stacking group at a given site is retained; earlier mutation of this stacking group at the same site are discarded.\u00a0 This can be useful for modeling an \u201cinfinite-alleles\u201d scenario in which every new mutation at a site generates a completely new allele, rather than retaining the previous mutations at the site. The mutation stacking policy applies only within the given mutation type\u2019s stacking group; mutations of different stacking groups are always allowed to stack in SLiM.\u00a0 The policy applies to all mutations added to the model after the policy is set, whether those mutations are introduced by calls such as addMutation(), addNewMutation(), or addNewDrawnMutation(), or are added by SLiM\u2019s own mutation-generation machinery.\u00a0 However, no attempt is made to enforce the policy for mutations already existing at the time the policy is set; typically, therefore, the policy is set in an initialize() callback so that it applies throughout the simulation.\u00a0 The policy is also not enforced upon the mutations loaded from a file with readFromPopulationFile(); such mutations were governed by whatever stacking policy was in effect when the population file was generated. In nucleotide-based models, the stacking policy for nucleotide-based mutation types is always \"l\", and cannot be changed.\u00a0 This ensures that new nucleotide mutations always replace the previous nucleotide at a site, and that more than one nucleotide mutation is never present at the same position in a single genome."
            },
            "nucleotideBased": {
                "type": "logical$",
                "description": " If the mutation type was created with initializeMutationType(), it is not nucleotide-based, and this property is F.\u00a0 If it was created with initializeMutationTypeNuc(), it is nucleotide-based, and this property is T.\u00a0 See those methods for further discussion."
            },
            "species": {
                "type": "object<Species>$",
                "description": " The species to which the target object belongs."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to mutation types."
            }
        }
    },
    "Plot": {
        "constructor": {},
        "methods": {
            "abline": {
                "signature": "(void)abline([Nif\u00a0a\u00a0=\u00a0NULL], [Nif\u00a0b\u00a0=\u00a0NULL], [Nif\u00a0h\u00a0=\u00a0NULL], [Nif\u00a0v\u00a0=\u00a0NULL], [string\u00a0color\u00a0=\u00a0\"red\"], [numeric\u00a0lwd\u00a0=\u00a01.0])",
                "description": " Adds one or more straight lines to the plot.\u00a0 There are three supported modes of operation for this method.\u00a0 In the first mode, the lines are specified by a and b, representing the intercepts and slopes of the lines, respectively; in this case, a and b may be the same length, or one of them may be a singleton to provide a single value used for all of the lines specified by the other.\u00a0 In the second mode, the lines are specified by h, representing the y-values of horizontal lines.\u00a0 In the third mode, the lines are specified by v, representing the x-values of vertical lines.\u00a0 These modes are mutually exclusive and cannot be mixed within one call to abline().\u00a0 The new lines will be plotted on top of any previously added data. The lines will be drawn in colors and line widths specified by color and lwd, each of which may be either a singleton (to provide one value used for all lines) or a vector equal in length to the number of lines plotted (to provide one value per line). See also lines(), for a more common approach to line plotting.\u00a0 The abline() method is different, and more specialized; the lines plotted by it span the full extent of the plot area, and their coordinates are not considered when dynamically resizing the axes of the plot (i.e., when createPlot() is not passed explicit, non-NULL values for xrange or yrange).\u00a0 This is typically useful for plotting things such as expected values and fit lines."
            },
            "addLegend": {
                "signature": "(void)addLegend([Ns$\u00a0position\u00a0=\u00a0NULL], [Ni$\u00a0inset\u00a0=\u00a0NULL], [Nif$\u00a0labelSize\u00a0=\u00a0NULL], [Nif$\u00a0lineHeight\u00a0=\u00a0NULL], [Nif$\u00a0graphicsWidth\u00a0=\u00a0NULL], [Nif$\u00a0exteriorMargin\u00a0=\u00a0NULL], [Nif$\u00a0interiorMargin\u00a0=\u00a0NULL])",
                "description": " Adds a legend to the plot.\u00a0 The legend will be displayed within the plot at the location specified by position, which must be \"topRight\", \"topLeft\", \"bottomRight\", or \"bottomLeft\", or NULL (the default) requesting that SLiMgui choose the position.\u00a0 The position of the legend will be inset from the chosen corner by a margin inset, measured in pixels; the default of NULL allows SLiMgui to choose the inset. The internal layout of the legend is a bit complex, and can be controlled by five parameters; in all cases, the default value of NULL requests that SLiMgui provide a reasonable default.\u00a0 The labelSize parameter specifies the font size used for the text labels for each legend entry (measured in \u201cpoints\u201d, the standard metric of font sizes).\u00a0 The lineHeight parameter specifies the vertical size, in pixels, of one entry line.\u00a0 The graphicsWidth parameter species the width, in pixels, of the column used to display the \u201cgraphics\u201d (whether a line segment, a point symbol, a swatch, or a combination of those) associated with each entry.\u00a0 The exteriorMargin parameter specifies the width/height of margins, in pixels, outside of the entries (between the entries and the legend\u2019s frame).\u00a0 Finally, the interiorMargin parameter specifies the width/height of margins, in pixels, vertically between entries, and also between the \u201cgraphics\u201d column and the label.\u00a0 It is easy to produce a legend that looks terrible, using these layout metrics; SLiMgui does only minimal sanity-checking of their values, to provide maximal flexibility. The legend is initially empty; entries for it can be added with legendLineEntry(), legendPointEntry(), and legendSwatchEntry()."
            },
            "axis": {
                "signature": "(void)axis(integer$\u00a0side, [Nif\u00a0at\u00a0=\u00a0NULL], [ls\u00a0labels\u00a0=\u00a0T])",
                "description": " Configures an axis of the plot.\u00a0 The side parameter controls which axis is being configured; at present, it may be 1 for the x-axis (at the bottom of the plot), or 2 for the y-axis (at the left of the plot). The positions of tick marks (and of any associated labels) are controlled by at; if at is NULL (the default) these positions will be computed automatically based upon the range of the data in the plot, otherwise at must be a vector of numeric positions.\u00a0 Note that the coordinate system of the plot is controlled not by this method, but by the xrange and yrange parameters of createPlot(); at controls only the positions of axis ticks within that coordinate system. The labels parameter controls the text labels displayed for ticks; it may be T (the default) to label ticks with their numeric positions, F to suppress all tick labels, or a vector of type string, equal in length to at, providing the label for each position in at.\u00a0 Label values may be the empty string, \"\", if a label at a given position is not desired, and if labels is T, some ticks may not receive a label for readability."
            },
            "legendLineEntry": {
                "signature": "(void)legendLineEntry(string$\u00a0label, [string$\u00a0color\u00a0=\u00a0\"red\"], [numeric$\u00a0lwd\u00a0=\u00a01.0])",
                "description": " Adds a legend entry with text label to the plot.\u00a0 The entry will be displayed as a line segment drawn in color color, using line width lwd, mirroring the appearance produced by lines() for the same parameters.\u00a0 If one or more other legend entries already exist with the same label, the new entry will be drawn on top of the previously set entries for that label (allowing legend entries that display both a line and a point, for example)."
            },
            "legendPointEntry": {
                "signature": "(void)legendPointEntry(string$\u00a0label, [integer$\u00a0symbol\u00a0=\u00a00], [string$\u00a0color\u00a0=\u00a0\"red\"], [string$\u00a0border\u00a0=\u00a0\"black\"], [numeric$\u00a0lwd\u00a0=\u00a01.0], [numeric$\u00a0size\u00a0=\u00a01.0])",
                "description": " Adds a legend entry with text label to the plot.\u00a0 The entry will be displayed as a point symbol specified by symbol, color, border, lwd, and size, mirroring the appearance produced by points() for the same parameters; see points() for further details.\u00a0 If one or more other legend entries already exist with the same label, the new entry will be drawn on top of the previously set entries for that label (allowing legend entries that display both a line and a point, for example)."
            },
            "legendSwatchEntry": {
                "signature": "(void)legendSwatchEntry(string$\u00a0label, [string$\u00a0color\u00a0=\u00a0\"red\"])",
                "description": " Adds a legend entry with text label to the plot.\u00a0 The entry will be displayed as a swatch drawn in color color.\u00a0 If one or more other legend entries already exist with the same label, the new entry will be drawn on top of the previously set entries for that label (allowing legend entries that display both a line and a point, for example)."
            },
            "lines": {
                "signature": "(void)lines(numeric\u00a0x, numeric\u00a0y, [string$\u00a0color\u00a0=\u00a0\"red\"], [numeric$\u00a0lwd\u00a0=\u00a01.0])",
                "description": " Adds line data given by x and y to the plot.\u00a0 The data will be plotted as a series of connected line segments, following the (x, y) positions given; note that the x and y vectors must be the same length.\u00a0 The new line data will be plotted on top of any previously added data. The lines will be drawn in color color, using line width lwd.\u00a0 Unlike points() and text(), color and lwd must be singletons, since each point (except the two ends) is shared by two line segments; if you wish to vary the color and width for each line segment, separate calls to lines() are necessary.\u00a0 See also abline()."
            },
            "points": {
                "signature": "(void)points(numeric\u00a0x, numeric\u00a0y, [integer\u00a0symbol\u00a0=\u00a00], [string\u00a0color\u00a0=\u00a0\"red\"], [string\u00a0border\u00a0=\u00a0\"black\"], [numeric\u00a0lwd\u00a0=\u00a01.0], [numeric\u00a0size\u00a0=\u00a01.0])",
                "description": " Adds point data given by x and y to the plot.\u00a0 The data will be plotted as a set of point symbols, centered at the (x, y) positions given; note that the x and y vectors must be the same length.\u00a0 The new point data will be plotted on top of any previously added data. The symbol plotted for each point depends upon the value of symbol.\u00a0 In general, symbols will be drawn in color color, with a line width lwd used for lines (if any) in the symbol, and an overall size scaled by size.\u00a0 Symbols 21\u201325 involve both a filled shape and a border line around that shape; for those symbols, the border line will use the color provided by border, while the filled shape will use color color.\u00a0 All of these parameters (symbol, color, border, lwd, and size) may either be a singleton value applied to all points, or a vector with one value per corresponding point."
            },
            "text": {
                "signature": "(void)text(numeric\u00a0x, numeric\u00a0y, string\u00a0labels, [string\u00a0color\u00a0=\u00a0\"black\"], [numeric\u00a0size\u00a0=\u00a010.0], [Nif\u00a0adj\u00a0=\u00a0NULL])",
                "description": " Adds text data given by x, y, and labels to the plot.\u00a0 The string values in labels will be plotted at the (x, y) positions given; note that x, y, and labels must all be the same length.\u00a0 The new text data will be plotted on top of any previously added data. The text will be drawn in color color, at the font size given by size (measured in \u201cpoints\u201d, the standard metric of font sizes); the font family and style cannot be controlled at this time.\u00a0 Both of these parameters (color and size) may either be a singleton value applied to all points, or a vector with one value per corresponding point. The exact position of the text, relative to each point (x, y), is adjusted by the optional parameter adj.\u00a0 The value of adj, if specified, must be a vector of length 2, where adj[0] adjusts the x position and adj[1] adjusts the y position of the text.\u00a0 Relative to a given x position, a value of 0.0 aligns the left edge of the text to it; a value of 0.5 aligns the center of the text to it; and a value of 1.0 aligns the right edge of the text to it.\u00a0 Similarly, relative to a given y position, a value of 0.0 aligns the bottom edge of the text to it; a value of 0.5 aligns the center of the text to it; and a value of 1.0 aligns the top edge of the text to it.\u00a0 Intermediate values will produce intermediate alignments, and values of adj outside of [0.0, 1.0] are also allowed.\u00a0 The default value of adj, NULL, is equivalent to c(0.5,\u00a00.5), aligning the center of the text to (x, y) both horizontally and vertically."
            },
            "write": {
                "signature": "(void)write(string$\u00a0filePath)",
                "description": " Writes the plot to the given filesystem path filePath as a PDF file.\u00a0 It is suggested, but not required, that filePath should end in a .pdf or .PDF filename extension.\u00a0 If the file cannot be written, an error will result."
            }
        },
        "properties": {
            "title": {
                "type": "string$",
                "description": " The title of the plot, as originally passed to createPlot().\u00a0 See also the plotWithTitle() method of SLiMgui."
            }
        }
    },
    "SLiMEidosBlock": {
        "constructor": {},
        "methods": {},
        "properties": {
            "active": {
                "type": "integer$",
                "description": " If this evaluates to logical F (i.e., is equal to 0), the script block is inactive and will not be called.\u00a0 The value of active for all registered script blocks is reset to -1 at the beginning of each tick, prior to script events being called, thus activating all blocks (except callbacks associated with a species that is not active in that tick, which are deactivated as part of the deactivation of the species).\u00a0 Any integer value other than -1 may be used instead of -1 to represent that a block is active; for example, active may be used as a counter to make a block execute a fixed number of times in each tick.\u00a0 This value is not cached by SLiM; if it is changed, the new value takes effect immediately.\u00a0 For example, a callback might be activated and inactivated repeatedly during a single tick."
            },
            "end": {
                "type": "integer$",
                "description": " The last tick in which the script block is active."
            },
            "id": {
                "type": "integer$",
                "description": " The identifier for this script block; for script s3, for example, this is 3.\u00a0 A script block for which no id was given will have an id of -1."
            },
            "source": {
                "type": "string$",
                "description": " The source code string of the script block."
            },
            "speciesSpec": {
                "type": "object<Species>",
                "description": " The species specifier for the script block.\u00a0 The species specifier for a callback block indicates the callback\u2019s associated species; the callback is called to modify the default behavior for that species.\u00a0 If the script block has no species specifier, this property\u2019s value is a zero-length object vector of class Species.\u00a0 This property is read-only; normally it is set by preceding the definition of a callback with a species specifier, of the form species <species-name>."
            },
            "start": {
                "type": "integer$",
                "description": " The first tick in which the script block is active."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use."
            },
            "ticksSpec": {
                "type": "object<Species>",
                "description": " The ticks specifier for the script block.\u00a0 The ticks specifier for an event block indicates the event\u2019s associated species; the event executes only in ticks when that species is active.\u00a0 If the script block has no ticks specifier, this property\u2019s value is a zero-length object vector of class Species.\u00a0 This property is read-only; normally it is set by preceding the definition of an event with a ticks specifier, of the form ticks <species-name>."
            },
            "type": {
                "type": "string$",
                "description": " The type of the script block; this will be \"first\", \"early\", or \"late\" for the three types of Eidos events, or \"initialize\", \"fitnessEffect\", \"interaction\", \"mateChoice\", \"modifyChild\", \"mutation\", \"mutationEffect\", \"recombination\", \"reproduction\", or \"survival\" for the respective types of Eidos callbacks."
            }
        }
    },
    "SLiMgui": {
        "constructor": {},
        "methods": {
            "createPlot": {
                "signature": "(No<Plot>$)createPlot(string$\u00a0title, [Nif\u00a0xrange\u00a0=\u00a0NULL], [Nif\u00a0yrange\u00a0=\u00a0NULL], [string$\u00a0xlab\u00a0=\u00a0\"x\"], [string$\u00a0ylab\u00a0=\u00a0\"y\"], [Nif$\u00a0width\u00a0=\u00a0NULL], [Nif$\u00a0height\u00a0=\u00a0NULL], [logical$\u00a0horizontalGrid\u00a0=\u00a0F], [logical$\u00a0verticalGrid\u00a0=\u00a0F], [logical$\u00a0fullBox\u00a0=\u00a0T], [numeric$\u00a0axisLabelSize\u00a0=\u00a015], [numeric$\u00a0tickLabelSize\u00a0=\u00a010])",
                "description": " Creates and returns a new custom plot referred to by title, or restarts and returns the existing plot with that title; if the plot cannot be created (notably, when running under SLiMguiLegacy rather than SLiMgui), NULL is returned.\u00a0 The range for the x and y axes of the plot can optionally be provided in xrange and yrange, as vectors of length 2 containing the minimum and maximum values for the corresponding axis; the default of NULL for these parameters requests that the axis ranges be determined heuristically based upon the data subsequently added to the plot.\u00a0 Labels for the x and y axes can be provided in xlab and ylab; if no axis label is desired, the empty string \"\" may be passed.\u00a0 The width and height of the window itself can optionally be set with width and height, in units of pixels (perhaps 70\u2013100 pixels per inch, depending on your screen\u2019s pixel density); the default of NULL for these parameters requests SLiMgui\u2019s default plot window size.\u00a0 The display of horizontal grid lines, vertical grid lines, and a full box around the plot area can be controlled with horizontalGrid, verticalGrid, and fullBox respectively, and the size (in points) of axis and tick labels can be controlled with axisLabelSize and tickLabelSize respectively. Once the plot has been created, data can be added to it using Plot methods such as lines(), points(), and text().\u00a0 As with other plot windows in SLiMgui, the \u201caction button\u201d can be used to access plot configuration options, and to copy or save the final plot as a raster image or a PDF file."
            },
            "logFileData": {
                "signature": "(Nfs)logFileData(object<LogFile>$\u00a0logFile, is$\u00a0column)",
                "description": " Returns a vector containing data from the LogFile object logFile, taken from a specified column (identified in column either by the column\u2019s name or by its zero-based index).\u00a0 If the data are all numeric, they will be returned as a float vector.\u00a0 Otherwise \u2013 if the data are non-numeric \u2013 they will be returned as a string vector.\u00a0 If the specified column does not exist in the log file, NULL will be returned. This functionality is provided as a method on the SLiMgui class, rather than on LogFile, because in SLiMgui logged data is kept in memory anyway, for display in the debugging output viewer window.\u00a0 When running at the command line logged data is not kept in memory, and thus is not available."
            },
            "openDocument": {
                "signature": "(void)openDocument(string$\u00a0filePath)",
                "description": " Open the document at filePath in SLiMgui, if possible.\u00a0 Supported document types include SLiM model files (typically with a .slim path extension), text files (typically with a .txt path extension, and opened as untitled model files), and PNG, JPG/JPEG, BMP, and GIF image file formats (typically .png / .jpg / .jpeg / .bmp / .gif, respectively).\u00a0 (Note that in SLiMguiLegacy, PDF files (.pdf) are supported but these other image file formats are not.)\u00a0 This method can be particularly useful for opening images created by the simulation itself, often by sublaunching a plotting process in R or another environment."
            },
            "pauseExecution": {
                "signature": "(void)pauseExecution(void)",
                "description": " Pauses a model that is playing in SLiMgui.\u00a0 This is essentially equivalent to clicking the \u201cPlay\u201d button to stop the execution of the model.\u00a0 Execution can be resumed by the user, by clicking the \u201cPlay\u201d button again; unlike calling stop() or simulationFinished(), the simulation is not terminated.\u00a0 This method can be useful for debugging or exploratory purposes, to pause the model at a point of interest.\u00a0 Execution is paused at the end of the currently executing tick, not mid-tick. If the model is being profiled, or is executing forward to a tick number entered in the tick field, pauseExecution() will do nothing; by design, pauseExecution() only pauses execution when SLiMgui is doing a simple \u201cPlay\u201d of the model."
            },
            "plotWithTitle": {
                "signature": "(No<Plot>$)plotWithTitle(string$\u00a0title)",
                "description": " Returns an existing plot that was created by createPlot() with title; if such a plot does not exist, NULL is returned.\u00a0 Note that other SLiMgui plots cannot be accessed through this method; only plots created by createPlot() are available in Eidos."
            }
        },
        "properties": {
            "pid": {
                "type": "integer$",
                "description": " The Un*x process identifier (commonly called the \u201cpid\u201d) of the running SLiMgui application.\u00a0 This can be useful for scripts that wish to use system calls to influence the SLiMgui application."
            }
        }
    },
    "SpatialMap": {
        "constructor": {
            "signature": "(object<SpatialMap>$)SpatialMap(string$\u00a0name, object<SpatialMap>$\u00a0map)",
            "description": " Creates a new SpatialMap object that is a copy of map, named name."
        },
        "methods": {
            "add": {
                "signature": "(object<SpatialMap>$)add(ifo<SpatialMap>\u00a0x)",
                "description": " Adds x to the spatial map.\u00a0 One possibility is that x is a singleton integer or float value; in this case, x is added to each grid value of the target spatial map.\u00a0 Another possibility is that x is an integer or float vector/matrix/array of the same dimensions as the target spatial map\u2019s grid; in this case, each value of x is added to the corresponding grid value of the target spatial map.\u00a0 The third possibility is that x is itself a (singleton) spatial map; in this case, each grid value of x is added to the corresponding grid value of the target spatial map (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).\u00a0 The target spatial map is returned, to allow easy chaining of operations."
            },
            "blend": {
                "signature": "(object<SpatialMap>$)blend(ifo<SpatialMap>\u00a0x, float$\u00a0xFraction)",
                "description": " Blends x into the spatial map, giving x a weight of xFraction and the existing values in the target spatial map a weight of 1 - xFraction, such that the resulting values in the target spatial map are then given by x\u00a0*\u00a0xFraction + target\u00a0*\u00a0(1\u00a0-\u00a0xFraction).\u00a0 The value of xFraction must be in [0.0, 1.0]. One possibility is that x is a singleton integer or float value; in this case, x is blended with each grid value of the target spatial map.\u00a0 Another possibility is that x is an integer or float vector/matrix/array of the same dimensions as the target spatial map\u2019s grid; in this case, each value of x is blended with the corresponding grid value of the target spatial map.\u00a0 The third possibility is that x is itself a (singleton) spatial map; in this case, each grid value of x is blended with the corresponding grid value of the target spatial map (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).\u00a0 The target spatial map is returned, to allow easy chaining of operations."
            },
            "changeColors": {
                "signature": "(void)changeColors([Nif\u00a0valueRange\u00a0=\u00a0NULL], [Ns\u00a0colors\u00a0=\u00a0NULL])",
                "description": " Changes the color scheme for the target spatial map.\u00a0 The meaning of valueRange and colors are identical to their meaning in defineSpatialMap(), but are also described here. The valueRange and colors parameters travel together; either both are NULL, or both are specified.\u00a0 They control how map values will be transformed into colors, by SLiMgui and by the mapColor() method.\u00a0 The valueRange parameter establishes the color-mapped range of spatial map values, as a vector of length two specifying a minimum and maximum; this does not need to match the actual range of values in the map.\u00a0 The colors parameter then establishes the corresponding colors for values within the interval defined by valueRange: values less than or equal to valueRange[0] will map to colors[0], values greater than or equal to valueRange[1] will map to the last colors value, and intermediate values will shade continuously through the specified vector of colors, with interpolation between adjacent colors to produce a continuous spectrum.\u00a0 This is much simpler than it sounds in this description; see the recipes in chapter 15 for an illustration of its use. If valueRange and colors are both NULL, a default grayscale color scheme will be used in SLiMgui, but an error will result if mapColor() is called."
            },
            "changeValues": {
                "signature": "(void)changeValues(ifo<SpatialMap>\u00a0x)",
                "description": " Changes the grid values used for the target spatial map.\u00a0 The parameter x should be either a SpatialMap object from which values are taken directly, or a vector, matrix, or array of numeric values as described in the documentation for defineSpatialMap().\u00a0 Other characteristics of the spatial map, such as its color mapping (if defined), its spatial bounds, and its spatiality, will remain unchanged.\u00a0 The grid resolution of the spatial map is allowed to change with this method.\u00a0 This method is useful for changing the values of a spatial map over time, such as to implement changes to the landscape\u2019s characteristics due to seasonality, climate change, processes such as fire or urbanization, and so forth.\u00a0 As with the original map values provided to defineSpatialMap(), it is often useful to read map values from a PNG image file using the Eidos class Image."
            },
            "divide": {
                "signature": "(object<SpatialMap>$)divide(ifo<SpatialMap>\u00a0x)",
                "description": " Divides the spatial map by x.\u00a0 One possibility is that x is a singleton integer or float value; in this case, each grid value of the target spatial map is divided by x.\u00a0 Another possibility is that x is an integer or float vector/matrix/array of the same dimensions as the target spatial map\u2019s grid; in this case, each grid value of the target spatial map is divided by the corresponding value of x.\u00a0 The third possibility is that x is itself a (singleton) spatial map; in this case, each grid value of the target spatial map is divided by the corresponding grid value of x (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).\u00a0 The target spatial map is returned, to allow easy chaining of operations."
            },
            "exp": {
                "signature": "(object<SpatialMap>$)exp(void)",
                "description": " Exponentiates the values of the spatial map.\u00a0 More precisely, each grid value x of the target spatial map is exponentiated \u2013 replaced by the value ex.\u00a0 The target spatial map is returned, to allow easy chaining of operations."
            },
            "gridValues": {
                "signature": "(float)gridValues(void)",
                "description": " Returns the values for the spatial map\u2019s grid as a vector (for a 1D map), a matrix (for a 2D map), or an array (for a 3D map).\u00a0 The form and orientation of the returned values is such that it could be used to create a new spatial map, with defineSpatialMap(), which would be identical to the original."
            },
            "interpolate": {
                "signature": "(object<SpatialMap>$)interpolate(integer$\u00a0factor, [string$\u00a0method\u00a0=\u00a0\"linear\"])",
                "description": " Increases the resolution of the spatial map by factor, changing the dimensions of the spatial map\u2019s grid of values (while leaving its spatial bounds unchanged), by interpolating new values between the existing values.\u00a0 The parameter factor must be an integer in [2, 10001], somewhat arbitrarily.\u00a0 The target spatial map is returned, to allow easy chaining of operations. For a 1D spatial map, factor-1 new values will be inserted between every pair of values in the original value grid.\u00a0 A factor of 2 would therefore insert one new value between each pair of existing values, thereby increasing the map\u2019s resolution by a factor of two.\u00a0 Note that if the spatial map\u2019s original grid dimension was N, the new grid dimension with a factor of k would be k(N\u22121)+1, not kN, because new values are inserted only between existing values.\u00a0 For 2D and 3D spatial maps, essentially the same process is conducted along each axis of the map\u2019s spatiality, increasing the resolution of the map by factor in every dimension. If method is \"linear\" (the default), linear (or bilinear or trilinear, for 2D/3D maps) interpolation will be used to interpolate the values for the new grid points.\u00a0 Alternatively, if method is \"nearest\", the nearest value in the old grid will be used for new grid points; with this method, it is recommended that factor be odd, not even, to avoid artifacts due to rounding of coordinates midway between the original grid positions.\u00a0 If method is \"cubic\", cubic (or bicubic, for 2D maps) will be used; this generally produces smoother interpolation with fewer artifacts than \"linear\", but it is not supported for 3D maps.\u00a0 The choice of interpolation method used here is independent of the map\u2019s interpolate property.\u00a0 Note that while the \"nearest\" and \"linear\" interpolation methods will leave the range of values in the map unchanged, \"cubic\" interpolation may produce interpolated values that are outside the original range of values (by design).\u00a0 Periodic boundaries are currently supported only for \"nearest\", \"linear\", and 1D \"cubic\" interpolation."
            },
            "mapColor": {
                "signature": "(string)mapColor(numeric\u00a0value)",
                "description": " Uses the spatial map\u2019s color-translation machinery (as defined by the valueRange and colors parameters to defineSpatialMap()) to translate each element of value into a corresponding color string.\u00a0 If the spatial map does not have color-translation capabilities, an error will result.\u00a0 See the documentation for defineSpatialMap() for information regarding the details of color translation.\u00a0 See the Eidos manual for further information on color strings."
            },
            "mapImage": {
                "signature": "(object<Image>$)mapImage([Ni$\u00a0width\u00a0=\u00a0NULL], [Ni$\u00a0height\u00a0=\u00a0NULL], [logical$\u00a0centers\u00a0=\u00a0F], [logical$\u00a0color\u00a0=\u00a0T])",
                "description": " Returns an Image object sampled from the spatial map.\u00a0 The image will be width pixels wide and height pixels tall; the intrinsic size of the spatial map itself will be used if one of these parameters is NULL.\u00a0 The image will be oriented in the same way as it is displayed in SLiMgui (which conceptually entails a transformation from matrix coordinates, which store values by column, to standard image coordinates, which store values by row; see the Eidos manual\u2019s documentation of Image for details).\u00a0 This method may only be called for 2D spatial maps at present. The sampling of the spatial map can be done in one of two ways, as controlled by the centers parameter.\u00a0 If centers is T, a (width+1) \u00d7 (height+1) grid of lines that delineates width \u00d7 height rectangular pixels will be overlaid on top of the spatial map, and values will be sampled from the spatial map at the center of each of these pixels.\u00a0 If centers is F (the default), a width \u00d7 height grid of lines will be overlaid on top of the spatial map, and values will be sampled from the spatial map at the vertices of the grid.\u00a0 If interpolation is not enabled for the spatial map, these two options will both recover the original matrix of values used to define the spatial map (assuming, here and below, that width and height are NULL).\u00a0 If interpolation is enabled for the spatial map, however, centers == F will recover the original values, but will not capture the \u201ctypical\u201d value of each pixel in the image; centers == T, on the other hand, will not recover the original values, but will capture the \u201ctypical\u201d value of each pixel in the image (i.e., the value at the center of each pixel, as produced by interpolation). If color is T (the default), the valueRange and colors parameters supplied to defineSpatialMap() will be used to translate map values to RGB color values as described in the documentation of that method, providing the same appearance as in SLiMgui; of course those parameters must have been supplied, otherwise an error will result.\u00a0 If color is F, on the other hand, a grayscale image will be produced that directly reflects the map values without color translation.\u00a0 In this case, this method needs to translate map values, which can have any float value, into grayscale pixel values that are integers in [0, 255].\u00a0 To do so, the map values are multiplied by 255.0, clamped to [0.0, 255.0], and then rounded to the nearest integer.\u00a0 This translation scheme essentially assumes that map values are in [0, 1]; for spatial maps that were defined using the floatK channel of a grayscale PNG image, this should recover the original image\u2019s pixel values.\u00a0 (If a different translation scheme is desired, color=T with the desired valueRange and colors should be used.)"
            },
            "mapValue": {
                "signature": "(float)mapValue(float\u00a0point)",
                "description": " Uses the spatial map\u2019s mapping machinery (as defined by the gridSize, values, and interpolate parameters to defineSpatialMap()) to translate the coordinates of point into a corresponding map value.\u00a0 The length of point must be equal to the spatiality of the spatial map; in other words, for a spatial map with spatiality \"xz\", point must be of length 2, specifying the x and z coordinates of the point to be evaluated.\u00a0 Interpolation will automatically be used if it was enabled for the spatial map.\u00a0 Point coordinates are clamped into the range defined by the spatial boundaries, even if the spatial boundaries are periodic; use pointPeriodic() to wrap the point coordinates first if desired.\u00a0 See the documentation for defineSpatialMap() for information regarding the details of value mapping. The point parameter may also contain more than one point to be looked up.\u00a0 In this case, the length of point must be an exact multiple of the spatiality of the spatial map; for a spatial map with spatiality \"xz\", for example, the length of point must be an exact multiple of 2, and successive pairs of elements from point (elements 0 and 1, then elements 2 and 3, etc.) will be taken as the x and z coordinates of the points to be evaluated.\u00a0 This allows mapValue() to be used in a vectorized fashion. The spatialMapValue() method of Subpopulation provides essentially the same functionality as this method; it may be more convenient to use, for some usage cases, and it checks that the spatial map is actually added to the subpopulation in question, providing an additional consistency check.\u00a0 However, either method may be used."
            },
            "multiply": {
                "signature": "(object<SpatialMap>$)multiply(ifo<SpatialMap>\u00a0x)",
                "description": " Multiplies the spatial map by x.\u00a0 One possibility is that x is a singleton integer or float value; in this case, each grid value of the target spatial map is multiplied by x.\u00a0 Another possibility is that x is an integer or float vector/matrix/array of the same dimensions as the target spatial map\u2019s grid; in this case, each grid value of the target spatial map is multiplied by the corresponding value of x.\u00a0 The third possibility is that x is itself a (singleton) spatial map; in this case, each grid value of the target spatial map is multiplied by the corresponding grid value of x (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).\u00a0 The target spatial map is returned, to allow easy chaining of operations."
            },
            "power": {
                "signature": "(object<SpatialMap>$)power(ifo<SpatialMap>\u00a0x)",
                "description": " Raises the spatial map to the power x.\u00a0 One possibility is that x is a singleton integer or float value; in this case, each grid value of the target spatial map is raised to the power x.\u00a0 Another possibility is that x is an integer or float vector/matrix/array of the same dimensions as the target spatial map\u2019s grid; in this case, each grid value of the target spatial map is raised to the power of the corresponding value of x.\u00a0 The third possibility is that x is itself a (singleton) spatial map; in this case, each grid value of the target spatial map is raised to power of the corresponding grid value of x (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).\u00a0 The target spatial map is returned, to allow easy chaining of operations."
            },
            "range": {
                "signature": "(float)range(void)",
                "description": " Returns the range of values contained in the spatial map.\u00a0 The result is a float vector of length 2; the first element is the minimum map value, and the second element is the maximum map value."
            },
            "rescale": {
                "signature": "(object<SpatialMap>$)rescale([numeric$\u00a0min\u00a0=\u00a00.0], [numeric$\u00a0max\u00a0=\u00a01.0])",
                "description": " Rescales the values of the spatial map to the range [min, max].\u00a0 By default, the rescaling is to the range [0.0, 1.0].\u00a0 It is required that min be less than max, and that both be finite.\u00a0 Note that the final range may not be exactly [min, max] due to numerical error.\u00a0 The target spatial map is returned, to allow easy chaining of operations."
            },
            "sampleImprovedNearbyPoint": {
                "signature": "(float)sampleImprovedNearbyPoint(float\u00a0point, float$\u00a0maxDistance, string$\u00a0functionType, ...)",
                "description": " This variant of sampleNearbyPoint() samples a Metropolis\u2013Hastings move on the spatial map.\u00a0 See sampleNearbyPoint() for discussion of the basic idea.\u00a0 This method proposes a nearby point drawn from the given kernel.\u00a0 If the drawn point has a larger map value than the original point, the new point is returned.\u00a0 If the drawn point has a smaller map value than the original point, it is returned with a probability equal to the ratio between its map value and the original map value, otherwise the original point is returned.\u00a0 The distribution of individuals that move (or not) to new locations governed by this method will converge upon the map itself, in a similar manner to how MCMC converges upon the posterior distribution (assuming no other forces, such as birth or death, influence the distribution of individuals).\u00a0 Movement governed by this method is \u201cimproved\u201d in the sense that individuals will tend to remain where they are unless the new sampled point is an improvement for them \u2013 a higher map value.\u00a0 Note that unlike sampleNearbyPoint(), this method requires that all map values are non-negative. The kernel is specified with a kernel type, functionType, followed by zero or more ellipsis arguments; see smooth() for further information.\u00a0 For this method, at present only kernel types \"f\", \"l\", \"e\", \"n\", and \"t\" are supported, and type \"t\" is not presently supported for 3D kernels.\u00a0 The parameters that define the kernel\u2019s shape \u2013 the ellipsis arguments that follow functionType \u2013 may each, independently, be either a singleton or a vector with length equal to the number of points, providing a separate value for each point being processed.\u00a0 In this way, all of the nearby points can be drawn from the same kernel, or each from a separately defined kernel.\u00a0 Since maxDistance and functionType are required to be singletons, however, their values cannot vary from point to point in the present design."
            },
            "sampleNearbyPoint": {
                "signature": "(float)sampleNearbyPoint(float\u00a0point, float$\u00a0maxDistance, string$\u00a0functionType, ...)",
                "description": " For a spatial point supplied in point, returns a nearby point sampled from a kernel weighted by the spatial map\u2019s values.\u00a0 Only points within the maximum distance of the kernel, maxDistance, will be chosen, and the probability that a given point is chosen will be proportional to the density of the kernel at that point multiplied by the value of the map at that point (interpolated, if interpolation is enabled for the map).\u00a0 Negative values of the map will be treated as zero.\u00a0 The point returned will be within spatial bounds, respecting periodic boundaries if in effect (so there is no need to call pointPeriodic() on the result). The kernel is specified with a kernel type, functionType, followed by zero or more ellipsis arguments; see smooth() for further information.\u00a0 For this method, at present only kernel types \"f\", \"l\", \"e\", \"n\", and \"t\" are supported, and type \"t\" is not presently supported for 3D kernels.\u00a0 The parameters that define the kernel\u2019s shape \u2013 the ellipsis arguments that follow functionType \u2013 may each, independently, be either a singleton or a vector with length equal to the number of points, providing a separate value for each point being processed.\u00a0 In this way, all of the nearby points can be drawn from the same kernel, or each from a separately defined kernel.\u00a0 Since maxDistance and functionType are required to be singletons, however, their values cannot vary from point to point in the present design. This method can be used to find points in the vicinity of individuals that are favorable \u2013 possessing more resources, or better environmental conditions, etc.\u00a0 It can also be used to guide the dispersal or foraging behavior of individuals.\u00a0 See sampleImprovedNearbyPoint() for a variant that may be useful for directed movement across a landscape.\u00a0 Note that the algorithm for sampleNearbyPoint() works by rejection sampling, and so will be very inefficient if the maximum value of the map (anywhere, across the entire map) is much larger than the typical value of the map where individuals are.\u00a0 The algorithm for sampleImprovedNearbyPoint() is different, and does not exhibit this performance issue."
            },
            "smooth": {
                "signature": "(object<SpatialMap>$)smooth(float$\u00a0maxDistance, string$\u00a0functionType, ...)",
                "description": " Smooths (or blurs, one could say) the values of the spatial map by convolution with a kernel.\u00a0 The kernel is specified with a maximum distance maxDistance (beyond which the kernel cuts off to a value of zero), a kernel type functionType that should be \"f\", \"l\", \"e\", \"n\", \"c\", or \"t\", and additional parameters in the ellipsis ... that depend upon the kernel type and further specify its shape.\u00a0 The target spatial map is returned, to allow easy chaining of operations. The kernel specification is similar to that for the setInteractionType() method of InteractionType, but omits the maximum value of the kernel.\u00a0 Specifically, functionType may be \"f\", in which case no ellipsis arguments should be supplied; \"l\", similarly with no ellipsis arguments; \"e\", in which case the ellipsis should supply a numeric$ lambda (rate) parameter for a negative exponential function; \"n\", in which case the ellipsis should supply a numeric$ sigma (standard deviation) parameter for a Gaussian function; \"c\", in which case the ellipsis should supply a numeric$ scale parameter for a Cauchy distribution function; or \"t\", in which case the ellipsis should supply a numeric$ degrees of freedom and a numeric$ scale parameter for a t-distribution function.\u00a0 See the InteractionType class documentation for discussions of these kernel types. Distance metrics specified to this method, such as maxDistance and the additional kernel shape parameters, are measured in the distance scale of the spatial map \u2013 the same distance scale in which the spatial bounds of the map are specified.\u00a0 The operation is performed upon the grid values of the spatial map; distances are internally translated into the scale of the value grid.\u00a0 For non-periodic boundaries, clipping at the edge of the spatial map is done; in a 2D map with no periodic boundaries, for example, the weights of edge and corner grid values are adjusted for their partial (one-half and one-quarter) coverage.\u00a0 For periodic boundaries, the smoothing operation will automatically wrap around based upon the assumption that the grid values at the two connected edges of the periodic boundary have identical values (which they should, since by definition they represent the same position in space). The density scale of the kernel has no effect and will be normalized; this is the reason that smooth(), unlike InteractionType, does not require specification of the maximum value of the kernel.\u00a0 This normalization prevents the kernel from increasing or decreasing the average spatial map value (apart from possible edge effects)."
            },
            "subtract": {
                "signature": "(object<SpatialMap>$)subtract(ifo<SpatialMap>\u00a0x)",
                "description": " Subtracts x from the spatial map.\u00a0 One possibility is that x is a singleton integer or float value; in this case, x is subtracted from each grid value of the target spatial map.\u00a0 Another possibility is that x is an integer or float vector/matrix/array of the same dimensions as the target spatial map\u2019s grid; in this case, each value of x is subtracted from the corresponding grid value of the target spatial map.\u00a0 The third possibility is that x is itself a (singleton) spatial map; in this case, each grid value of x is subtracted from the corresponding grid value of the target spatial map (and thus the two spatial maps must match in their spatiality, their spatial bounds, and their grid dimensions).\u00a0 The target spatial map is returned, to allow easy chaining of operations."
            }
        },
        "properties": {
            "gridDimensions": {
                "type": "integer",
                "description": " The dimensions of the spatial map\u2019s grid of values, in the order of the components of the map\u2019s spatiality.\u00a0 For example, a map with spatiality \"xz\" and a grid of values that is 500 in the \"x\" dimension by 300 in the \"z\" dimension would return c(500, 300) for this property."
            },
            "interpolate": {
                "type": "logical$",
                "description": " Whether interpolation between grid values is enabled (T) or disabled (F).\u00a0 The initial value of this property is set by defineSpatialMap(), but it can be changed.\u00a0 The interpolation performed is linear; for cubic interpolation, use the interpolate() method."
            },
            "name": {
                "type": "string$",
                "description": " The name of the spatial map, usually as provided to defineSpatialMap().\u00a0 The names of spatial maps must be unique within any given subpopulation, but the same name may be reused for different spatial maps in different subpopulations.\u00a0 The name is used to identify a map for methods such as spatialMapValue(), and is also used for display in SLiMgui."
            },
            "spatialBounds": {
                "type": "float",
                "description": " The spatial bounds to which the spatial map is aligned.\u00a0 These bounds come from the subpopulation that originally created the map, with the defineSpatialMap() method, and cannot be subsequently changed.\u00a0 All subpopulations that use a given spatial map must match that map\u2019s spatial bounds, so that the map does not stretch or shrink relative to its initial configuration.\u00a0 The components of the spatial bounds of a map correspond to the components of the map\u2019s spatiality; for example, a map with spatiality \"xz\" will have bounds (x0, z0, x1, z1); bounds for \"y\" are not included, since that dimension is not used by the spatial map."
            },
            "spatiality": {
                "type": "string$",
                "description": " The spatiality of the map: the subset of the model\u2019s dimensions that are used by the spatial map.\u00a0 The spatiality of a map is configured by defineSpatialMap() and cannot subsequently be changed.\u00a0 For example, a 3D model (with dimensionality \"xyz\") might define a 2D spatial map with spatiality \"xz\", providing spatial values that do not depend upon the \"y\" dimension.\u00a0 Often, however, the spatiality of a map will match the dimensionality of the model."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to spatial maps."
            }
        }
    },
    "Species": {
        "constructor": {},
        "methods": {
            "addSubpop": {
                "signature": "(object<Subpopulation>$)addSubpop(is$\u00a0subpopID, integer$\u00a0size, [float$\u00a0sexRatio\u00a0=\u00a00.5], [logical$\u00a0haploid\u00a0=\u00a0F])",
                "description": " Add a new subpopulation with id subpopID and size individuals (see the SLiM manual for further details).\u00a0 The subpopID parameter may be either an integer giving the ID of the new subpopulation, or a string giving the name of the new subpopulation (such as \"p5\" to specify an ID of 5).\u00a0 Only if sex is enabled for the species, the initial sex ratio may optionally be specified as sexRatio (as the male fraction, M:M+F); if it is not specified, a default of 0.5 is used.\u00a0 The new subpopulation will be defined as a global variable immediately by this method, and will also be returned by this method.\u00a0 Subpopulations added by this method will initially consist of individuals with empty genomes. In order to model subpopulations that split from an already existing subpopulation, use addSubpopSplit(). Only in nonWF models, the haploid parameter may be T; in this case, the second genome of each new individual will be a null genome, rather than an empty genome.\u00a0 For even greater control in nonWF models, you can call addSubpop() with an initial size of 0 and then stock the population with new individuals created however you wish in the next tick\u2019s reproduction() callback."
            },
            "addSubpopSplit": {
                "signature": "(object<Subpopulation>$)addSubpopSplit(is$\u00a0subpopID, integer$\u00a0size, io<Subpopulation>$\u00a0sourceSubpop, [float$\u00a0sexRatio\u00a0=\u00a00.5])",
                "description": " Split off a new subpopulation with id subpopID and size individuals derived from subpopulation sourceSubpop.\u00a0 The subpopID parameter may be either an integer giving the ID of the new subpopulation, or a string giving the name of the new subpopulation (such as \"p5\" to specify an ID of 5).\u00a0 The sourceSubpop parameter may specify the source subpopulation either as a Subpopulation object or by integer identifier.\u00a0 Only if sex is enabled for the species, the initial sex ratio may optionally be specified as sexRatio (as the male fraction, M:M+F); if it is not specified, a default of 0.5 is used.\u00a0 The new subpopulation will be defined as a global variable immediately by this method, and will also be returned by this method. Subpopulations added by this method will consist of individuals that are clonal copies of individuals from the source subpopulation, randomly chosen with probabilities proportional to fitness.\u00a0 The fitness of all of these initial individuals is considered to be 1.0, to avoid a doubled round of selection in the initial tick, given that fitness values were already used to choose the individuals to clone.\u00a0 Once this initial set of individuals has mated to produce offspring, the model is effectively of parental individuals in the source subpopulation mating randomly according to fitness, as usual in SLiM, with juveniles migrating to the newly added subpopulation.\u00a0 Effectively, then, then new subpopulation is created empty, and is filled by migrating juveniles from the source subpopulation, in accordance with SLiM\u2019s usual model of juvenile migration."
            },
            "countOfMutationsOfType": {
                "signature": "(integer$)countOfMutationsOfType(io<MutationType>$\u00a0mutType)",
                "description": " Returns the number of mutations that are of the type specified by mutType, out of all of the mutations that are currently active in the species.\u00a0 If you need a vector of the matching Mutation objects, rather than just a count, use -mutationsOfType().\u00a0 This method is often used to determine whether an introduced mutation is still active (as opposed to being either lost or fixed).\u00a0 This method is provided for speed; it is much faster than the corresponding Eidos code."
            },
            "individualsWithPedigreeIDs": {
                "signature": "(object<Individual>)individualsWithPedigreeIDs(integer\u00a0pedigreeIDs, [Nio<Subpopulation>\u00a0subpops\u00a0=\u00a0NULL])",
                "description": " Looks up individuals by pedigree ID, optionally within specific subpopulations.\u00a0 Pedigree tracking must be turned on with initializeSLiMOptions(keepPedigrees=T) to use this method, otherwise an error will result.\u00a0 This method is vectorized; more than one pedigree id may be passed in pedigreeID, in which case the returned vector will contain all of the individuals for which a match was found (in the same order in which they were supplied).\u00a0 If a given id is not found, the returned vector will contain no entry for that id (so the length of the returned vector may not match the length of pedigreeIDs).\u00a0 If none of the given ids were found, the returned vector will be object<Individual>(0), an empty object vector of class Individual.\u00a0 If you have more than one pedigree ID to look up, calling this method just once, in vectorized fashion, may be much faster than calling it once for each ID, due to internal optimizations. To find individuals within all subpopulations, pass the default of NULL for subpops.\u00a0 If you are interested only in matches within a specific subpopulation, pass that subpopulation for subpops; that will make the search faster.\u00a0 Similarly, if you know that a particular subpopulation is the most likely to contain matches, you should supply that subpopulation first in the subpops vector so that it will be searched first; the supplied subpopulations are searched in order.\u00a0 Subpopulations may be supplied either as integer IDs, or as Subpopulation objects."
            },
            "killIndividuals": {
                "signature": "(void)killIndividuals(object<Individual>\u00a0individuals)",
                "description": " Immediately kills the individuals in individuals.\u00a0 This removes them from their subpopulation and gives them an index value of -1.\u00a0 The Individual objects are not freed immediately, since references to them could still exist in local Eidos variables; instead, the individuals are kept in a temporary \u201cgraveyard\u201d until they can be freed safely.\u00a0 It therefore continues to be safe to use them and their genomes, except that accessing their subpopulation property will raise an error since they no longer have a subpopulation. Note that the indices and order of individuals and genomes in all source subpopulations will change unpredictably as a side effect of this method.\u00a0 All evaluated interactions are invalidated as a side effect of calling this method. Note that this method is only for use in nonWF models, in which mortality is managed manually by the model script.\u00a0 In WF models, mortality is managed automatically by the SLiM core when the new offspring generation becomes the parental generation and the previous parental generation dies; mortality does not otherwise occur in WF models.\u00a0 In nonWF models, mortality normally occurs during the survival stage of the tick cycle, based upon the fitness values calculated by SLiM, and survival() callbacks can influence the outcome of that survival stage.\u00a0 Calls to killIndividuals(), on the other hand, can be made at any time during first(), early(), or late() events, and the result cannot be modified by survival() callbacks; the given individuals are simply immediately killed.\u00a0 This method therefore provides an alternative, and relatively rarely used, mortality mechanism that is disconnected from fitness."
            },
            "mutationCounts": {
                "signature": "(integer)mutationCounts(Nio<Subpopulation>\u00a0subpops, [No<Mutation>\u00a0mutations\u00a0=\u00a0NULL])",
                "description": " Return an integer vector with the frequency counts of all of the Mutation objects passed in mutations, within the Subpopulation objects in subpops.\u00a0 The subpops argument is required, but you may pass NULL to get population-wide frequency counts.\u00a0 Subpopulations may be supplied either as integer IDs, or as Subpopulation objects.\u00a0 If the optional mutations argument is NULL (the default), frequency counts will be returned for all of the active Mutation objects in the species \u2013 the same Mutation objects, and in the same order, as would be returned by the mutations property of sim, in other words."
            },
            "mutationFrequencies": {
                "signature": "(float)mutationFrequencies(Nio<Subpopulation>\u00a0subpops, [No<Mutation>\u00a0mutations\u00a0=\u00a0NULL])",
                "description": " Return a float vector with the frequencies of all of the Mutation objects passed in mutations, within the Subpopulation objects in subpops.\u00a0 The subpops argument is required, but you may pass NULL to get population-wide frequencies.\u00a0 Subpopulations may be supplied either as integer IDs, or as Subpopulation objects.\u00a0 If the optional mutations argument is NULL (the default), frequencies will be returned for all of the active Mutation objects in the species \u2013 the same Mutation objects, and in the same order, as would be returned by the mutations property of sim, in other words."
            },
            "mutationsOfType": {
                "signature": "(object<Mutation>)mutationsOfType(io<MutationType>$\u00a0mutType)",
                "description": " Returns an object vector of all the mutations that are of the type specified by mutType, out of all of the mutations that are currently active in the species.\u00a0 If you just need a count of the matching Mutation objects, rather than a vector of the matches, use -countOfMutationsOfType().\u00a0 This method is often used to look up an introduced mutation at a later point in the simulation, since there is no way to keep persistent references to objects in SLiM.\u00a0 This method is provided for speed; it is much faster than the corresponding Eidos code."
            },
            "outputFixedMutations": {
                "signature": "(void)outputFixedMutations([Ns$\u00a0filePath\u00a0=\u00a0NULL], [logical$\u00a0append\u00a0=\u00a0F])",
                "description": " Output all fixed mutations \u2013 all Substitution objects, in other words \u2013 in a SLiM native format.\u00a0 If the optional parameter filePath is NULL (the default), output will be sent to Eidos\u2019s output stream.\u00a0 Otherwise, output will be sent to the filesystem path specified by filePath, overwriting that file if append if F, or appending to the end of it if append is T.\u00a0 Mutations which have fixed but have not been turned into Substitution objects \u2013 typically because convertToSubstitution has been set to F for their mutation type \u2013 are not output; they are still considered to be segregating mutations by SLiM. In SLiM 3.3 and later, the output format includes the nucleotides associated with any nucleotide-based mutations. Output is generally done in a late() event, so that the output reflects the state of the simulation at the end of a tick."
            },
            "outputFull": {
                "signature": "(void)outputFull([Ns$\u00a0filePath\u00a0=\u00a0NULL], [logical$\u00a0binary\u00a0=\u00a0F], [logical$\u00a0append\u00a0=\u00a0F], [logical$\u00a0spatialPositions\u00a0=\u00a0T], [logical$\u00a0ages\u00a0=\u00a0T], [logical$\u00a0ancestralNucleotides\u00a0=\u00a0T], [logical$\u00a0pedigreeIDs\u00a0=\u00a0F])",
                "description": " Output the state of the entire population.\u00a0 If the optional parameter filePath is NULL (the default), output will be sent to Eidos\u2019s output stream.\u00a0 Otherwise, output will be sent to the filesystem path specified by filePath, overwriting that file if append if F, or appending to the end of it if append is T.\u00a0 When writing to a file, a logical flag, binary, may be supplied as well.\u00a0 If binary is T, the population state will be written as a binary file instead of a text file (binary data cannot be written to the standard output stream).\u00a0 The binary file is usually smaller, and in any case will be read much faster than the corresponding text file would be read.\u00a0 Binary files are not guaranteed to be portable between platforms; in other words, a binary file written on one machine may not be readable on a different machine (but in practice it usually will be, unless the platforms being used are fairly unusual).\u00a0 If binary is F (the default), a text file will be written. Beginning with SLiM 2.3, the spatialPositions parameter may be used to control the output of the spatial positions of individuals in species for which continuous space has been enabled using the dimensionality option of initializeSLiMOptions().\u00a0 If spatialPositions is F, the output will not contain spatial positions, and will be identical to the output generated by SLiM 2.1 and later.\u00a0 If spatialPositions is T, spatial position information will be output if it is available.\u00a0 If the species does not have continuous space enabled, the spatialPositions parameter will be ignored.\u00a0 Positional information may be output for all output destinations \u2013 the Eidos output stream, a text file, or a binary file. Beginning with SLiM 3.0, the ages parameter may be used to control the output of the ages of individuals in nonWF simulations.\u00a0 If ages is F, the output will not contain ages, preserving backward compatibility with the output format of SLiM 2.1 and later.\u00a0 If ages is T, ages will be output for nonWF models.\u00a0 In WF simulations, the ages parameter will be ignored. Beginning with SLiM 3.3, the ancestralNucleotides parameter may be used to control the output of the ancestral nucleotide sequence in nucleotide-based models.\u00a0 If ancestralNucleotides is F, the output will not contain ancestral nucleotide information, and so the ancestral sequence will not be restored correctly if the saved file is loaded with readPopulationFile().\u00a0 This option is provided because the ancestral sequence may be quite large, for models with a long chromosome (e.g., 1 GB if the chromosome is 109 bases long, when saved in text format, or 0.25 GB when saved in binary format).\u00a0 If the model is not nucleotide-based (as enabled with the nucleotideBased parameter to initializeSLiMOptions()), the ancestralNucleotides parameter will be ignored.\u00a0 Note that in nucleotide-based models the output format will always include the nucleotides associated with any nucleotide-based mutations; the ancestralNucleotides flag governs only the ancestral sequence. Beginning with SLiM 3.5, the pedigreeIDs parameter may be used to request that pedigree IDs be written out (and read in by readFromPopulationFile(), subsequently).\u00a0 This option is turned off (F) by default, to preserve backward compatibility; if it is turned on (T), different file version values will be used, and backward compatibility with previous versions of SLiM will be lost.\u00a0 This option may only be used if SLiM\u2019s optional pedigree tracking has been enabled with initializeSLiMOptions(keepPedigrees=T). Output is generally done in a late() event, so that the output reflects the state of the simulation at the end of a tick."
            },
            "outputMutations": {
                "signature": "(void)outputMutations(object<Mutation>\u00a0mutations, [Ns$\u00a0filePath\u00a0=\u00a0NULL], [logical$\u00a0append\u00a0=\u00a0F])",
                "description": " Output all of the given mutations.\u00a0 This can be used to output all mutations of a given mutation type, for example.\u00a0 If the optional parameter filePath is NULL (the default), output will be sent to Eidos\u2019s output stream.\u00a0 Otherwise, output will be sent to the filesystem path specified by filePath, overwriting that file if append if F, or appending to the end of it if append is T. In SLiM 3.3 and later, the output format includes the nucleotides associated with any nucleotide-based mutations. Output is generally done in a late() event, so that the output reflects the state of the simulation at the end of a tick."
            },
            "readFromPopulationFile": {
                "signature": "(integer$)readFromPopulationFile(string$\u00a0filePath, [No$\u00a0subpopMap\u00a0=\u00a0NULL])",
                "description": " Read from a population initialization file, whether in text or binary format as previously specified to outputFull(), and return the tick counter value represented by the file\u2019s contents (i.e., the tick at which the file was generated).\u00a0 Although this is most commonly used to set up initial populations (often in an Eidos event set to run in tick 1, immediately after simulation initialization), it may be called in any early() or late() Eidos event; the current state of all populations in the target species will be wiped and replaced by the state in the file at filePath.\u00a0 All Eidos variables that are of type object and have element type Subpopulation, Genome, Mutation, Individual, or Substitution will be removed as a side effect of this method if they contain any element that belongs to the target species, because those objects will no longer exist in the SLiM simulation; if you want to preserve any of that state, you should output it or save it to a file prior to this call.\u00a0 New symbols will be defined to refer to the new Subpopulation objects loaded from the file. If the file being read was written by a version of SLiM prior to 2.3, then for backward compatibility fitness values will be calculated immediately for any new subpopulations created by this call, which will trigger the calling of any activated and applicable mutationEffect() and fitnessEffect() callbacks.\u00a0 When reading files written by SLiM 2.3 or later, fitness values are not calculated as a side effect of this call (because the simulation will often need to evaluate interactions or modify other state prior to doing so). In SLiM 2.3 and later when using the WF model, calling readFromPopulationFile() from any context other than a late() event causes a warning; calling from a late() event is almost always correct in WF models, so that fitness values can be automatically recalculated by SLiM at the usual time in the tick cycle without the need to force their recalculation (see comments on recalculateFitness()). In SLiM 3.0 when using the nonWF model, calling readFromPopulationFile() from any context other than an early() event causes a warning; calling from an early() event is almost always correct in nonWF models, so that fitness values can be automatically recalculated by SLiM at the usual time in the tick cycle without the need to force their recalculation (see comments on recalculateFitness()). As of SLiM 2.1, this method changes the tick and cycle counters to the tick and cycle read from the file.\u00a0 If you do not want these counters to be changed, you can change them back after reading, by setting community.tick and sim.cycle to whatever values you wish.\u00a0 Note that restoring a saved past state and running forward again will not yield the same simulation results, because the random number generator\u2019s state will not be the same; to ensure reproducibility from a given time point, setSeed() can be used to establish a new seed value.\u00a0 Any changes made to structure of the species (mutation types, genomic element types, etc.) will not be wiped and re-established by readFromPopulationFile(); this method loads only the population\u2019s state, not the species configuration, so care should be taken to ensure that the species structure meshes coherently with the loaded data.\u00a0 Indeed, state such as the selfing and cloning rates of subpopulations, values set into tag properties, and values set onto objects with setValue() will also be lost, since it is not saved out by outputFull().\u00a0 Only information saved by outputFull() will be restored; all other state associated with the species \u2013 subpopulations, individuals, genomes, mutations, and substitutions \u2013 will be lost, and should be re-established by the model if it is still needed. As of SLiM 2.3, this method will read and restore the spatial positions of individuals if that information is present in the output file and the species has enabled continuous space (see outputFull() for details).\u00a0 If spatial positions are present in the output file but the species has not enabled continuous space (or the number of spatial dimensions does not match), an error will result.\u00a0 If the species has enabled continuous space but spatial positions are not present in the output file, the spatial positions of the individuals read will be undefined, but an error is not raised. As of SLiM 3.0, this method will read and restore the ages of individuals if that information is present in the output file and the simulation is based upon the nonWF model.\u00a0 If ages are present but the simulation uses a WF model, an error will result; the WF model does not use age information.\u00a0 If ages are not present but the simulation uses a nonWF model, an error will also result; the nonWF model requires age information. As of SLiM 3.3, this method will restore the nucleotides of nucleotide-based mutations, and will restore the ancestral nucleotide sequence, if that information is present in the output file.\u00a0 Loading an output file that contains nucleotide information in a non-nucleotide-based model, and vice versa, will produce an error. As of SLiM 3.5, this method will read and restore the pedigree IDs of individuals and genomes if that information is present in the output file (as requested with outputFull(pedigreeIDs=T)) and if SLiM\u2019s optional pedigree tracking has been enabled with initializeSLiMOptions(keepPedigrees=T). This method can also be used to read tree-sequence (.trees) files saved by treeSeqOutput() or generated by the Python pyslim package.\u00a0 Note that the user metadata for a tree-sequence file can be read separately with the treeSeqMetadata() function.\u00a0 Beginning with SLiM 4, the subpopMap parameter may be supplied to re-order the populations of the input tree sequence when it is loaded in to SLiM.\u00a0 This parameter must have a value that is a Dictionary; the keys of this dictionary should be SLiM population identifiers as string values (e.g., \"p2\"), and the values should be indexes of populations in the input tree sequence; a key/value pair of \"p2\", 4 would mean that the fifth population in the input (the one at zero-based index 4) should become p2 on loading into SLiM.\u00a0 If subpopMap is non-NULL, all populations in the tree sequence must be explicitly mapped, even if their index will not change and even if they will not be used by SLiM; the only exception is for unused slots in the population table, which can be explicitly remapped but do not have to be.\u00a0 For instance, suppose we have a tree sequence in which population 0 is unused, population 1 is not a SLiM population (for example, an ancestral population produced by msprime), and population 2 is a SLiM population, and we want to load this in with population 2 as p0 in SLiM.\u00a0 To do this, we could supply a value of Dictionary(\"p0\", 2, \"p1\", 1, \"p2\", 0) for subpopMap, or we could leave out slot 0 since it is unused, with Dictionary(\"p0\", 2, \"p1\", 1).\u00a0 Although this facility cannot be used to remove populations in the tree sequence, note that it may add populations that will be visible when treeSeqOutput() is called (although these will not be SLiM populations); if, in this example, we had used Dictionary(\"p0\", 0, \"p1\", 1, \"p5\", 2) and then we wrote the result out with treeSeqOutput(), the resulting tree sequence would have six populations, although three of them would be empty and would not be used by SLiM.\u00a0 The use of subpopMap makes it easier to load simulation data that was generated in Python, since that typically uses an id of 0.\u00a0 The subpopMap parameter may not be used with file formats other than tree-sequence files, at the present time; setting up the correct subpopulation ids is typically easier when working with those other formats.\u00a0 Note the tskit command-line interface can be used, like python3 -m tskit populations file.trees, to find out the number of subpopulations in a tree-sequence file and their IDs. When loading a tree sequence, a crosscheck of the loaded data will be performed to ensure that the tree sequence was well-formed and was loaded correctly.\u00a0 When running a Release build of SLiM, however, this crosscheck will only occur the first time that readFromPopulationFile() is called to load a tree sequence; subsequent calls will not perform this crosscheck, for greater speed when running models that load saved population state many times (such as models that are conditional on fixation).\u00a0 If you suspect that a tree sequence file might be corrupted or read incorrectly, running a Debug build of SLiM enables crosschecks after every load."
            },
            "recalculateFitness": {
                "signature": "(void)recalculateFitness([Ni$\u00a0tick\u00a0=\u00a0NULL])",
                "description": " Force an immediate recalculation of fitness values for all individuals in all subpopulations.\u00a0 Normally fitness values are calculated at a fixed point in each tick, and those values are cached and used until the next recalculation.\u00a0 If simulation parameters are changed in script in a way that affects fitness calculations, and if you wish those changes to take effect immediately rather than taking effect at the next automatic recalculation, you may call recalculateFitness() to force an immediate recalculation and recache. The optional parameter tick provides the tick for which mutationEffect() and fitnessEffect() callbacks should be selected; if it is NULL (the default), the current tick value for the simulation, community.tick, is used.\u00a0 If you call recalculateFitness() in an early() event in a WF model, you may wish this to be community.tick - 1 in order to utilize the mutationEffect() and fitnessEffect() callbacks for the previous tick, as if the changes that you have made to fitness-influencing parameters were already in effect at the end of the previous tick when the new generation was first created and evaluated (usually it is simpler to just make such changes in a late() event instead, however, in which case calling recalculateFitness() is probably not necessary at all since fitness values will be recalculated immediately afterwards).\u00a0 Regardless of the value supplied for tick here, community.tick inside callbacks will report the true tick number, so if your callbacks consult that parameter in order to create tick-specific fitness effects you will need to handle the discrepancy somehow.\u00a0 (Similar considerations apply for nonWF models that call recalculateFitness() in a late() event, which is also not advisable in general.) After this call, the fitness values used for all purposes in SLiM will be the newly calculated values.\u00a0 Calling this method will trigger the calling of any enabled and applicable mutationEffect() and fitnessEffect() callbacks, so this is quite a heavyweight operation; you should think carefully about what side effects might result (which is why fitness recalculation does not just occur automatically after changes that might affect fitness values)."
            },
            "registerFitnessEffectCallback": {
                "signature": "(object<SLiMEidosBlock>$)registerFitnessEffectCallback(Nis$\u00a0id, string$\u00a0source, [Nio<Subpopulation>$\u00a0subpop\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])",
                "description": " Register a block of Eidos source code, represented as the string singleton source, as an Eidos fitnessEffect() callback in the current simulation (specific to the target species), with an optional subpopulation subpop (which may be an integer identifier, or NULL, the default, to indicate all subpopulations), and optional start and end ticks all limiting its applicability.\u00a0 The script block will be given identifier id (specified as an integer, or as a string symbolic name such as \"s5\"); this may be NULL if there is no need to be able to refer to the block later.\u00a0 The registered callback is added to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible to execute in the current tick.\u00a0 The new SLiMEidosBlock will be defined as a global variable immediately by this method, and will also be returned by this method."
            },
            "registerMateChoiceCallback": {
                "signature": "(object<SLiMEidosBlock>$)registerMateChoiceCallback(Nis$\u00a0id, string$\u00a0source, [Nio<Subpopulation>$\u00a0subpop\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])",
                "description": " Register a block of Eidos source code, represented as the string singleton source, as an Eidos mateChoice() callback in the current simulation (specific to the target species), with optional subpopulation subpop (which may be an integer identifier, or NULL, the default, to indicate all subpopulations) and optional start and end ticks all limiting its applicability.\u00a0 The script block will be given identifier id (specified as an integer, or as a string symbolic name such as \"s5\"); this may be NULL if there is no need to be able to refer to the block later.\u00a0 The registered callback is added to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible to execute in the current tick.\u00a0 The new SLiMEidosBlock will be defined as a global variable immediately by this method, and will also be returned by this method."
            },
            "registerModifyChildCallback": {
                "signature": "(object<SLiMEidosBlock>$)registerModifyChildCallback(Nis$\u00a0id, string$\u00a0source, [Nio<Subpopulation>$\u00a0subpop\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])",
                "description": " Register a block of Eidos source code, represented as the string singleton source, as an Eidos modifyChild() callback in the current simulation (specific to the target species), with optional subpopulation subpop (which may be an integer identifier, or NULL, the default, to indicate all subpopulations) and optional start and end ticks all limiting its applicability.\u00a0 The script block will be given identifier id (specified as an integer, or as a string symbolic name such as \"s5\"); this may be NULL if there is no need to be able to refer to the block later.\u00a0 The registered callback is added to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible to execute in the current tick.\u00a0 The new SLiMEidosBlock will be defined as a global variable immediately by this method, and will also be returned by this method."
            },
            "registerMutationCallback": {
                "signature": "(object<SLiMEidosBlock>$)registerMutationCallback(Nis$\u00a0id, string$\u00a0source, [Nio<MutationType>$\u00a0mutType\u00a0=\u00a0NULL], [Nio<Subpopulation>$\u00a0subpop\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])",
                "description": " Register a block of Eidos source code, represented as the string singleton source, as an Eidos mutation() callback in the current simulation (specific to the target species), with an optional mutation type mutType (which may be an integer mutation type identifier, or NULL, the default, to indicate all mutation types), optional subpopulation subpop (which may also be an integer identifier, or NULL, the default, to indicate all subpopulations), and optional start and end ticks all limiting its applicability.\u00a0 The script block will be given identifier id (specified as an integer, or as a string symbolic name such as \"s5\"); this may be NULL if there is no need to be able to refer to the block later.\u00a0 The registered callback is added to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible to execute in the current tick.\u00a0 The new SLiMEidosBlock will be defined as a global variable immediately by this method, and will also be returned by this method."
            },
            "registerMutationEffectCallback": {
                "signature": "(object<SLiMEidosBlock>$)registerMutationEffectCallback(Nis$\u00a0id, string$\u00a0source, io<MutationType>$\u00a0mutType, [Nio<Subpopulation>$\u00a0subpop\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])",
                "description": " Register a block of Eidos source code, represented as the string singleton source, as an Eidos mutationEffect() callback in the current simulation (specific to the target species), with a required mutation type mutType (which may be an integer mutation type identifier), optional subpopulation subpop (which may also be an integer identifier, or NULL, the default, to indicate all subpopulations), and optional start and end ticks all limiting its applicability.\u00a0 The script block will be given identifier id (specified as an integer, or as a string symbolic name such as \"s5\"); this may be NULL if there is no need to be able to refer to the block later.\u00a0 The registered callback is added to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible to execute in the current tick.\u00a0 The new SLiMEidosBlock will be defined as a global variable immediately by this method, and will also be returned by this method."
            },
            "registerRecombinationCallback": {
                "signature": "(object<SLiMEidosBlock>$)registerRecombinationCallback(Nis$\u00a0id, string$\u00a0source, [Nio<Subpopulation>$\u00a0subpop\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])",
                "description": " Register a block of Eidos source code, represented as the string singleton source, as an Eidos recombination() callback in the current simulation (specific to the target species), with optional subpopulation subpop (which may be an integer identifier, or NULL, the default, to indicate all subpopulations) and optional start and end ticks all limiting its applicability.\u00a0 The script block will be given identifier id (specified as an integer, or as a string symbolic name such as \"s5\"); this may be NULL if there is no need to be able to refer to the block later.\u00a0 The registered callback is added to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible to execute in the current tick.\u00a0 The new SLiMEidosBlock will be defined as a global variable immediately by this method, and will also be returned by this method."
            },
            "registerReproductionCallback": {
                "signature": "(object<SLiMEidosBlock>$)registerReproductionCallback(Nis$\u00a0id, string$\u00a0source, [Nio<Subpopulation>$\u00a0subpop\u00a0=\u00a0NULL], [Ns$\u00a0sex\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])",
                "description": " Register a block of Eidos source code, represented as the string singleton source, as an Eidos reproduction() callback in the current simulation (specific to the target species), with optional subpopulation subpop (which may be an integer identifier, or NULL, the default, to indicate all subpopulations), optional sex-specificity sex (which may be \"M\" or \"F\" in sexual species to make the callback specific to males or females respectively, or NULL for no sex-specificity), and optional start and end ticks all limiting its applicability.\u00a0 The script block will be given identifier id (specified as an integer, or as a string symbolic name such as \"s5\"); this may be NULL if there is no need to be able to refer to the block later.\u00a0 The registered callback is added to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible to execute in the current tick.\u00a0 The new SLiMEidosBlock will be defined as a global variable immediately by this method, and will also be returned by this method."
            },
            "registerSurvivalCallback": {
                "signature": "(object<SLiMEidosBlock>$)registerSurvivalCallback(Nis$\u00a0id, string$\u00a0source, [Nio<Subpopulation>$\u00a0subpop\u00a0=\u00a0NULL], [Ni$\u00a0start\u00a0=\u00a0NULL], [Ni$\u00a0end\u00a0=\u00a0NULL])",
                "description": " Register a block of Eidos source code, represented as the string singleton source, as an Eidos survival() callback in the current simulation (specific to the target species), with optional subpopulation subpop (which may be an integer identifier, or NULL, the default, to indicate all subpopulations) and optional start and end ticks all limiting its applicability.\u00a0 The script block will be given identifier id (specified as an integer, or as a string symbolic name such as \"s5\"); this may be NULL if there is no need to be able to refer to the block later.\u00a0 The registered callback is added to the end of the list of registered SLiMEidosBlock objects, and is active immediately; it may be eligible to execute in the current tick.\u00a0 The new SLiMEidosBlock will be defined as a global variable immediately by this method, and will also be returned by this method."
            },
            "simulationFinished": {
                "signature": "(void)simulationFinished(void)",
                "description": " Declare the current simulation finished.\u00a0 This method is equivalent to the Community method simulationFinished(), except that this method is only legal to call in single-species models (to provide backward compatibility).\u00a0 It is recommended that new code should call the Community method; this method may be deprecated in the future."
            },
            "skipTick": {
                "signature": "(void)skipTick(void)",
                "description": " Deactivate the target species for the current tick.\u00a0 This sets the active property of the species to F; it also set the active property of all callbacks that belong to the species (with the species as their species specifier) to F, and sets the active property of all events that are synchronized with the species (with the species as their ticks specifier) to F.\u00a0 The cycle counter for the species will not be incremented at the end of the tick.\u00a0 This method may only be called in first() events, to ensure that species are either active or inactive throughout a given tick."
            },
            "subsetMutations": {
                "signature": "(object<Mutation>)subsetMutations([No<Mutation>$\u00a0exclude\u00a0=\u00a0NULL], [Nio<MutationType>$\u00a0mutType\u00a0=\u00a0NULL], [Ni$\u00a0position\u00a0=\u00a0NULL], [Nis$\u00a0nucleotide\u00a0=\u00a0NULL], [Ni$\u00a0tag\u00a0=\u00a0NULL], [Ni$\u00a0id\u00a0=\u00a0NULL])",
                "description": " Returns a vector of mutations subset from the list of all active mutations in the species (as would be provided by the mutations property).\u00a0 The parameters specify constraints upon the subset of mutations that will be returned.\u00a0 Parameter exclude, if non-NULL, may specify a specific mutation that should not be included (typically the focal mutation in some operation).\u00a0 Parameter mutType, if non-NULL, may specify a mutation type for the mutations to be returned (as either a MutationType object or an integer identifier).\u00a0 Parameter position, if non-NULL, may specify a base position for the mutations to be returned.\u00a0 Parameter nucleotide, if non-NULL, may specify a nucleotide for the mutations to be returned (either as a string, \"A\" / \"C\" / \"G\" / \"T\", or as an integer, 0 / 1 / 2 / 3 respectively).\u00a0 Parameter tag, if non-NULL, may specify a tag value for the mutations to be returned.\u00a0 Parameter id, if non-NULL, may specify a required value for the id property of the mutations to be returned. This method is shorthand for getting the mutations property of the subpopulation, and then using operator [] to select only mutations with the desired properties; besides being much simpler than the equivalent Eidos code, it is also much faster.\u00a0 Note that if you only need to select on mutation type, the mutationsOfType() method will be even faster."
            },
            "treeSeqCoalesced": {
                "signature": "(logical$)treeSeqCoalesced(void)",
                "description": " Returns the coalescence state for the recorded tree sequence at the last simplification.\u00a0 The returned value is a logical singleton flag, T to indicate that full coalescence was observed at the last tree-sequence simplification (meaning that there is a single ancestral individual that roots all ancestry trees at all sites along the chromosome \u2013 although not necessarily the same ancestor at all sites), or F if full coalescence was not observed.\u00a0 For simple models, reaching coalescence may indicate that the model has reached an equilibrium state, but this may not be true in models that modify the dynamics of the model during execution by changing migration rates, introducing new mutations programmatically, dictating non-random mating, etc., so be careful not to attach more meaning to coalescence than it is due; some models may require burn-in beyond coalescence to reach equilibrium, or may not have an equilibrium state at all.\u00a0 Also note that some actions by a model, such as adding a new subpopulation, may cause the coalescence state to revert from T back to F (at the next simplification), so a return value of T may not necessarily mean that the model is coalesced at the present moment \u2013 only that it was coalesced at the last simplification. This method may only be called if tree sequence recording has been turned on with initializeTreeSeq(); in addition, checkCoalescence=T must have been supplied to initializeTreeSeq(), so that the necessary work is done during each tree-sequence simplification.\u00a0 Since this method does not perform coalescence checking itself, but instead simply returns the coalescence state observed at the last simplification, it may be desirable to call treeSeqSimplify() immediately before treeSeqCoalesced() to obtain up-to-date information.\u00a0 However, the speed penalty of doing this in every tick would be large, and most models do not need this level of precision; usually it is sufficient to know that the model has coalesced, without knowing whether that happened in the current tick or in a recent preceding tick."
            },
            "treeSeqOutput": {
                "signature": "(void)treeSeqOutput(string$\u00a0path, [logical$\u00a0simplify\u00a0=\u00a0T], [logical$\u00a0includeModel\u00a0=\u00a0T], [No$\u00a0metadata\u00a0=\u00a0NULL])",
                "description": " Outputs the current tree sequence recording tables to the path specified by path.\u00a0 This method may only be called if tree sequence recording has been turned on with initializeTreeSeq().\u00a0 If simplify is T (the default), simplification will be done immediately prior to output; this is almost always desirable, unless a model wishes to avoid simplification entirely.\u00a0 (Note that if simplification is not done, then all genomes since the last simplification will be marked as samples in the resulting tree sequence.)\u00a0 A binary tree sequence file will be written to the specified path; a filename extension of .trees is suggested for this type of file. Normally, the full SLiM script used to generate the tree sequence is written out to the provenance entry of the tree sequence file, to the model subkey of the parameters top-level key.\u00a0 Supplying F for includeModel suppresses output of the full script. A Dictionary object containing user-generated metadata may be supplied with the metadata parameter.\u00a0 If present, this dictionary will be serialized as JSON and attached to the saved tree sequence under a key named user_metadata, within the SLiM key.\u00a0 If tskit is used to read the tree sequence in Python, this metadata will automatically be deserialized and made available at ts.metadata[\"SLiM\"][\"user_metadata\"].\u00a0 This metadata dictionary is not used by SLiM, or by pyslim, tskit, or msprime; you may use it for any purpose you wish.\u00a0 Note that metadata may actually be any subclass of Dictionary, such as a DataFrame.\u00a0 It can even be a Species object such as sim, or a LogFile instance; however, only the keys and values contained by the object\u2019s Dictionary superclass state will be serialized into the metadata (properties of the subclass will be ignored).\u00a0 This metadata dictionary can be recovered from the saved file using the treeSeqMetadata() function."
            },
            "treeSeqRememberIndividuals": {
                "signature": "(void)treeSeqRememberIndividuals(object<Individual>\u00a0individuals, [logical$\u00a0permanent\u00a0=\u00a0T])",
                "description": " Mark the individuals specified by individuals to be kept across tree sequence table simplification.\u00a0 This method may only be called if tree sequence recording has been turned on with initializeTreeSeq().\u00a0 All currently living individuals are always kept across simplification; this method does not need to be called, and indeed should not be called, for that purpose.\u00a0 Instead, treeSeqRememberIndividuals() allows any individual, including dead individuals, to be kept in the final tree sequence.\u00a0 Typically this would be used, for example, to keep particular individuals that you wanted to be able to trace ancestry back to in later analysis.\u00a0 However, this is not the typical usage pattern for tree sequence recording; most models will not need to call this method. There are two ways to keep individuals across simplification.\u00a0 If permanent is T (the default), then the specified individuals will be permanently remembered: their genomes will be added to the current sample, and they will always be present in the tree sequence.\u00a0 Permanently remembering a large number of individuals will, of course, markedly increase memory usage and runtime. Supplying F for permanent will instead mark the individuals only for (temporary) retention: their genomes will not be added to the sample, and they will appear in the final tree sequence only if one of their genomes is retained across simplification.\u00a0 In other words, the rule of thumb for retained individuals is simple: if a genome is kept by simplification, the genome\u2019s corresponding individual is kept also, if it is retained.\u00a0 Note that permanent remembering takes priority; calling this function with permanent=F on an individual that has previously been permanently remembered will not remove it from the sample. The behavior of simplification for individuals retained with permanent=F depends upon the value of the retainCoalescentOnly flag passed to initializeTreeSeq(); here we will discuss the behavior of that flag in detail.\u00a0 First of all, genomes are always removed by simplification unless they are (a) part of the final generation (i.e., in a living individual when simplification occurs), (b) ancestral to the final generation, (c) a genome of a permanently remembered individual, or (d) ancestral to a permanently remembered individual.\u00a0 If retainCoalescentOnly is T (the default), they are also always removed if they are not a branch point (i.e., a coalescent node or most recent common ancestor) in the tree sequence.\u00a0 In some cases it may be useful to retain a genome and its associated individual when it is simply an intermediate node in the ancestry (i.e., in the middle of a branch).\u00a0 This can be enabled by setting retainCoalescentOnly to F in your call to initializeTreeSeq().\u00a0 In this case, ancestral genomes that are intermediate (\u201cunary nodes\u201d, in tskit parlance) and are within an individual that has been retained using the permanent=F flag here are kept, along with the retained individual itself.\u00a0 Since setting retainCoalescentOnly to F will prevent the unary nodes for retained individuals from being pruned, simplification may often be unable to prune very much at all from the tree sequence, and memory usage and runtime may increase rapidly.\u00a0 If you are retaining many individuals, this setting should therefore be used only with caution; it is not necessary if you are purely interested in the most recent common ancestors.\u00a0 See the pyslim documentation for further discussion of retaining and remembering individuals and the effects of the retainCoalescentOnly flag. The metadata (age, location, etc) that are stored in the resulting tree sequence are those values present at either (a) the final generation, if the individual is alive when the tree sequence is output, or (b) the last time that the individual was remembered, if not.\u00a0 Calling treeSeqRememberIndividuals() on an individual that is already remembered will cause the archived information about the remembered individual to be updated to reflect the individual\u2019s current state.\u00a0 A case where this is particularly important is for the spatial location of individuals in continuous-space models.\u00a0 SLiM automatically remembers the individuals that comprise the first generation of any new subpopulation created with addSubpop(), for easy recapitation and other analysis.\u00a0 However, since these first-generation individuals are remembered at the moment they are created, their spatial locations have not yet been set up, and will contain garbage \u2013 and those garbage values will be archived in their remembered state.\u00a0 If you need correct spatial locations of first-generation individuals for your post-simulation analysis, you should call treeSeqRememberIndividuals() explicitly on the first generation, after setting spatial locations, to update the archived information with the correct spatial positions."
            },
            "treeSeqSimplify": {
                "signature": "(void)treeSeqSimplify(void)",
                "description": " Triggers an immediate simplification of the tree sequence recording tables.\u00a0 This method may only be called if tree sequence recording has been turned on with initializeTreeSeq().\u00a0 A call to this method will free up memory being used by entries that are no longer in the ancestral path of any individual within the current sample (currently living individuals, in other words, plus those explicitly added to the sample with treeSeqRememberIndividuals()), but it can also take a significant amount of time.\u00a0 Typically calling this method is not necessary; the automatic simplification performed occasionally by SLiM should be sufficient for most models."
            }
        },
        "properties": {
            "avatar": {
                "type": "string$",
                "description": " The avatar string used to represent this species in SLiMgui.\u00a0 Outside of SLiMgui, this property still exists, but is not used by SLiM.\u00a0 Avatars are typically one-character strings, often using an emoji that symbolizes the species.\u00a0 This property is read-only; its value should be set with the avatar parameter of initializeSpecies()."
            },
            "chromosome": {
                "type": "object<Chromosome>$",
                "description": " The Chromosome object used by the species."
            },
            "chromosomeType": {
                "type": "string$",
                "description": " The type of chromosome being simulated by this species; this will be one of \"A\", \"X\", or \"Y\"."
            },
            "color": {
                "type": "string$",
                "description": " The color used to display information about this species in SLiMgui.\u00a0 Outside of SLiMgui, this property still exists, but is not used by SLiM.\u00a0 Colors may be specified by name, or with hexadecimal RGB values of the form \"#RRGGBB\" (see the Eidos manual).\u00a0 This property is read-only; its value should be set with the color parameter of initializeSpecies()."
            },
            "cycle": {
                "type": "integer$",
                "description": " The current cycle count for this species.\u00a0 This counter begins at 1, and increments at the end of every tick in which the species is active.\u00a0 In models with non-overlapping generations, particularly WF models, this can be thought of as a generation counter."
            },
            "description": {
                "type": "string$",
                "description": " A human-readable string description for the species.\u00a0 By default, this is the empty string, \"\"; however, it may be set to whatever you wish."
            },
            "dimensionality": {
                "type": "string$",
                "description": " The spatial dimensionality of the simulation for this species, as specified in initializeSLiMOptions().\u00a0 This will be \"\" (the empty string) for non-spatial simulations (the default), or \"x\", \"xy\", or \"xyz\", for simulations using those spatial dimensions respectively."
            },
            "genomicElementTypes": {
                "type": "object<GenomicElementType>",
                "description": " The GenomicElementType objects being used in the species.\u00a0 These are guaranteed to be in sorted order, by their id property."
            },
            "id": {
                "type": "integer$",
                "description": " The identifier for this species.\u00a0 Species identifiers are determined by their declaration order in the script; the first declared species is given an id of 0, the second is given an id of 1, and so forth."
            },
            "mutationTypes": {
                "type": "object<MutationType>",
                "description": " The MutationType objects being used in the species.\u00a0 These are guaranteed to be in sorted order, by their id property."
            },
            "mutations": {
                "type": "object<Mutation>",
                "description": " The Mutation objects that are currently active in the species."
            },
            "name": {
                "type": "string$",
                "description": " A human-readable string name for the subpopulation.\u00a0 This is always the declared name of the species, as given in the explicit species declaration in script, and cannot be changed.\u00a0 The name of a species may appear as a label in SLiMgui, and it can be useful in generating output, debugging, and other purposes.\u00a0 See also the description property, which can be changed by the user and used for any purpose."
            },
            "nucleotideBased": {
                "type": "logical$",
                "description": " If T, the model for this species is nucleotide-based; if F, it is not.\u00a0 See the discussion of the nucleotideBased parameter to initializeSLiMOptions() for discussion."
            },
            "periodicity": {
                "type": "string$",
                "description": " The spatial periodicity of the simulation for this species, as specified in initializeSLiMOptions().\u00a0 This will be \"\" (the empty string) for non-spatial simulations and simulations with no periodic spatial dimensions (the default).\u00a0 Otherwise, it will be a string representing the subset of spatial dimensions that have been declared to be periodic, as specified to initializeSLiMOptions()."
            },
            "scriptBlocks": {
                "type": "object<SLiMEidosBlock>",
                "description": " All registered SLiMEidosBlock objects in the simulation that have been declared with this species as their species specifier (not ticks specifier).\u00a0 These will always be callback blocks; callbacks are species-specific, while other types of blocks are not."
            },
            "sexEnabled": {
                "type": "logical$",
                "description": " If T, sex is enabled for this species; if F, individuals are hermaphroditic."
            },
            "subpopulations": {
                "type": "object<Subpopulation>",
                "description": " The Subpopulation instances currently defined in the species.\u00a0 These are guaranteed to be in sorted order, by their id property."
            },
            "substitutions": {
                "type": "object<Substitution>",
                "description": " A vector of Substitution objects, representing all mutations that have been fixed in this species."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to the simulation."
            }
        }
    },
    "Subpopulation": {
        "constructor": {},
        "methods": {
            "addCloned": {
                "signature": "(object<Individual>)addCloned(object<Individual>$\u00a0parent, [integer$\u00a0count\u00a0=\u00a01], [logical$\u00a0defer\u00a0=\u00a0F])",
                "description": " Generates a new offspring individual from the given parent by clonal reproduction, queues it for addition to the target subpopulation, and returns it.\u00a0 The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.\u00a0 The subpopulation of parent will be used to locate applicable mutation() and modifyChild() callbacks governing the generation of the offspring individual. Beginning in SLiM 4.1, the count parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).\u00a0 Each offspring is generated independently, based upon the given parameters.\u00a0 The returned vector contains all generated offspring, except those that were rejected by a modifyChild() callback.\u00a0 If all offspring are rejected, object<Individual>(0) is returned, which is a zero-length object vector of class Individual; note that this is a change in behavior from earlier versions, which would return NULL. Beginning in SLiM 4.1, passing T for defer will defer the generation of the genomes of the produced offspring until the end of the reproduction phase.\u00a0 Genome generation can only be deferred if there are no active mutation() callbacks; otherwise, an error will result.\u00a0 Furthermore, when genome generation is deferred the mutations of the genomes of the generated offspring may not be accessed until reproduction is complete (whether from a modifyChild() callback or otherwise).\u00a0 There is little or no advantage to deferring genome generation when running single-threaded; in that case, the default of F for defer is generally preferable since it has fewer restrictions.\u00a0 When running multi-threaded, deferring genome generation allows that task to be done in parallel (which is the reason this option exists). Also beginning in SLiM 4.1, in spatial models the spatial position of the offspring will be inherited (i.e., copied) from parent; more specifically, the x property will be inherited in all spatial models (1D/2D/3D), the y property in 2D/3D models, and the z property in 3D models.\u00a0 Properties not inherited will be left uninitialized, as they were prior to SLiM 4.1.\u00a0 The parent\u2019s spatial position is probably not desirable in itself; the intention here is to make it easy to model the natal dispersal of all the new offspring for a given tick with a single vectorized call to deviatePositions() / pointDeviated(). Note that this method is only for use in nonWF models.\u00a0 See addCrossed() for further general notes on the addition of new offspring individuals."
            },
            "addCrossed": {
                "signature": "(object<Individual>)addCrossed(object<Individual>$\u00a0parent1, object<Individual>$\u00a0parent2, [Nfs$\u00a0sex\u00a0=\u00a0NULL], [integer$\u00a0count\u00a0=\u00a01], [logical$\u00a0defer\u00a0=\u00a0F])",
                "description": " Generates a new offspring individual from the given parents by biparental sexual reproduction, queues it for addition to the target subpopulation, and returns it.\u00a0 The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.\u00a0 Attempting to use a newly generated offspring individual as a mate, or to reference it as a member of the target subpopulation in any other way, will result in an error.\u00a0 In most models the returned individual is not used, but it is provided for maximal generality and flexibility. The new offspring individual is generated from parent1 and parent2 by crossing them.\u00a0 In sexual models parent1 must be female and parent2 must be male; in hermaphroditic models, parent1 and parent2 are unrestricted.\u00a0 If parent1 and parent2 are the same individual in a hermaphroditic model, that parent self-fertilizes, or \u201cselfs\u201d, to generate the offspring sexually (note this is not the same as clonal reproduction).\u00a0 Such selfing is considered \u201cincidental\u201d by addCrossed(), however; if the preventIncidentalSelfing flag of initializeSLiMOptions() is T, supplying the same individual for parent1 and parent2 is an error (you must check for and prevent incidental selfing if you set that flag in a nonWF model).\u00a0 If non-incidental selfing is desired, addSelfed() should be used instead. The sex parameter specifies the sex of the offspring.\u00a0 A value of NULL means \u201cmake the default choice\u201d; in non-sexual models it is the only legal value for sex, and does nothing, whereas in sexual models it causes male or female to be chosen with equal probability.\u00a0 A value of \"M\" or \"F\" for sex specifies that the offspring should be male or female, respectively.\u00a0 Finally, a float value from 0.0 to 1.0 for sex provides the probability that the offspring will be male; a value of 0.0 will produce a female, a value of 1.0 will produce a male, and for intermediate values SLiM will draw the sex of the offspring randomly according to the specified probability.\u00a0 Unless you wish the bias the sex ratio of offspring, the default value of NULL should generally be used. Note that any defined, active, and applicable recombination(), mutation(), and modifyChild() callbacks will be called as a side effect of calling this method, before this method even returns.\u00a0 For recombination() and mutation() callbacks, the subpopulation of the parent that is generating a given gamete is used; for modifyChild() callbacks the situation is more complex.\u00a0 In most biparental mating events, parent1 and parent2 will belong to the same subpopulation, and modifyChild() callbacks for that subpopulation will be used, just as in WF models.\u00a0 In certain models (such as models of pollen flow and broadcast spawning), however, biparental mating may occur between parents that are not from the same subpopulation; that is legal in nonWF models, and in that case, modifyChild() callbacks for the subpopulation of parent1 are used (since that is the maternal parent). If the modifyChild() callback process results in rejection of the proposed child, a new offspring individual is not be generated.\u00a0 To force the generation of an offspring individual from a given pair of parents, you could loop until addCrossed() succeeds, but note that if your modifyChild() callback rejects all proposed children from those particular parents, your model will then hang, so care must be taken with this approach.\u00a0 Usually, nonWF models do not force generation of offspring in this manner; rejection of a proposed offspring by a modifyChild() callback typically represents a phenomenon such as post-mating reproductive isolation or lethal genetic incompatibilities that would reduce the expected litter size, so the default behavior is typically desirable. Beginning in SLiM 4.1, the count parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).\u00a0 Each offspring is generated independently, based upon the given parameters.\u00a0 The returned vector contains all generated offspring, except those that were rejected by a modifyChild() callback.\u00a0 If all offspring are rejected, object<Individual>(0) is returned, which is a zero-length object vector of class Individual; note that this is a change in behavior from earlier versions, which would return NULL. Beginning in SLiM 4.1, passing T for defer will defer the generation of the genomes of the produced offspring until the end of the reproduction phase.\u00a0 Genome generation can only be deferred if there are no active mutation() or recombination() callbacks; otherwise, an error will result.\u00a0 Furthermore, when genome generation is deferred the mutations of the genomes of the generated offspring may not be accessed until reproduction is complete (whether from a modifyChild() callback or otherwise).\u00a0 There is little or no advantage to deferring genome generation when running single-threaded; in that case, the default of F for defer is generally preferable since it has fewer restrictions.\u00a0 When running multi-threaded, deferring genome generation allows that task to be done in parallel (which is the reason this option exists). Also beginning in SLiM 4.1, in spatial models the spatial position of the offspring will be inherited (i.e., copied) from parent1; more specifically, the x property will be inherited in all spatial models (1D/2D/3D), the y property in 2D/3D models, and the z property in 3D models.\u00a0 Properties not inherited will be left uninitialized, as they were prior to SLiM 4.1.\u00a0 The parent\u2019s spatial position is probably not desirable in itself; the intention here is to make it easy to model the natal dispersal of all the new offspring for a given tick with a single vectorized call to deviatePositions() / pointDeviated(). Note that this method is only for use in nonWF models, in which offspring generation is managed manually by the model script; in such models, addCrossed() must be called only from reproduction() callbacks, and may not be called at any other time.\u00a0 In WF models, offspring generation is managed automatically by the SLiM core."
            },
            "addEmpty": {
                "signature": "(object<Individual>)addEmpty([Nfs$\u00a0sex\u00a0=\u00a0NULL], [Nl$\u00a0genome1Null\u00a0=\u00a0NULL], [Nl$\u00a0genome2Null\u00a0=\u00a0NULL], [integer$\u00a0count\u00a0=\u00a01])",
                "description": " Generates a new offspring individual with empty genomes (i.e., containing no mutations), queues it for addition to the target subpopulation, and returns it.\u00a0 The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.\u00a0 No recombination() or mutation() callbacks will be called.\u00a0 The target subpopulation will be used to locate applicable modifyChild() callbacks governing the generation of the offspring individual (unlike the other addX() methods, because there is no parental individual to reference).\u00a0 The offspring is considered to have no parents for the purposes of pedigree tracking.\u00a0 The sex parameter is treated as in addCrossed(). By default \u2013 when genome1Null and genome2Null are both NULL \u2013 null genomes will be generated instead of empty genomes only in sex-chromosome simulations, where the sex chromosome that is not being simulated is represented by a null genome; otherwise, empty genomes rather than null genomes will be created.\u00a0 This default behavior can be changed by passing T or F for genome1Null or genome2Null, which will force the corresponding offspring genome to be null (T) or non-null (F).\u00a0 The behavior in sex-chromosome simulations cannot be changed, since the presence of null genomes there is dictated by sex, but T or F may be passed as long as it matches what SLiM would do anyway.\u00a0 In all other simulations there is little point in passing F (since that would be the default behavior anyway), but passing T can be used to make one or both genomes be null genomes, which can be useful for, e.g., modeling haploids (for which, by convention, the second genome is usually a null genome in SLiM). Beginning in SLiM 4.1, the count parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).\u00a0 Each offspring is generated independently, based upon the given parameters.\u00a0 The returned vector contains all generated offspring, except those that were rejected by a modifyChild() callback.\u00a0 If all offspring are rejected, object<Individual>(0) is returned, which is a zero-length object vector of class Individual; note that this is a change in behavior from earlier versions, which would return NULL. Note that this method is only for use in nonWF models.\u00a0 See addCrossed() for further general notes on the addition of new offspring individuals."
            },
            "addRecombinant": {
                "signature": "(object<Individual>)addRecombinant(No<Genome>$\u00a0strand1, No<Genome>$\u00a0strand2, Ni\u00a0breaks1, No<Genome>$\u00a0strand3, No<Genome>$\u00a0strand4, Ni\u00a0breaks2, [Nfs$\u00a0sex\u00a0=\u00a0NULL], [No<Individual>$\u00a0parent1\u00a0=\u00a0NULL], [No<Individual>$\u00a0parent2\u00a0=\u00a0NULL], [logical$\u00a0randomizeStrands\u00a0=\u00a0F], [integer$\u00a0count\u00a0=\u00a01], [logical$\u00a0defer\u00a0=\u00a0F])",
                "description": " Generates a new offspring individual from the given parental genomes with the specified crossover breakpoints, queues it for addition to the target subpopulation, and returns it.\u00a0 The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.\u00a0 The target subpopulation will be used to locate applicable mutation() and modifyChild() callbacks governing the generation of the offspring individual (unlike the other addX() methods, because there are potentially up to four parental individuals to reference); recombination() callbacks will not be called by this method.\u00a0 This method is an advanced feature; most models will use addCrossed(), addSelfed(), or addCloned() instead. This method supports several possible configurations for strand1, strand2, and breaks1 (and the same applies for strand3, strand4, and breaks2).\u00a0 If strand1 and strand2 are both NULL, the corresponding genome in the generated offspring will be empty, as from addEmpty(), with no parental genomes and no added mutations; in this case, breaks1 must be NULL or zero-length.\u00a0 If strand1 is non-NULL but strand2 is NULL, the corresponding genome in the generated offspring will be a clonal copy of strand1 with mutations added, as from addCloned(); in this case, breaks1 must similarly be NULL or zero-length.\u00a0 If strand1 and strand2 are both non-NULL, the corresponding genome in the generated offspring will result from recombination between strand1 and strand2 with mutations added, as from addCrossed(), with strand1 being the initial copy strand; copying will switch between strands at each breakpoint in breaks1, which must be non-NULL but need not be sorted or uniqued (SLiM will sort and unique the supplied breakpoints internally).\u00a0 (It is not currently legal for strand1 to be NULL and strand2 non-NULL; that variant may be assigned some meaning in future.)\u00a0 Again, this discussion applies equally to strand3, strand4, and breaks2, mutatis mutandis.\u00a0 Note that when new mutations are generated by addRecombinant(), their subpopID property will be the id of the offspring\u2019s subpopulation, since the parental subpopulation is ambiguous; this behavior differs from the other add...() methods. The sex parameter is interpreted exactly as in addCrossed(); see that method for discussion.\u00a0 If the offspring sex is specified in any way (i.e., if sex is non-NULL), the strands provided must be compatible with the sex chosen.\u00a0 If the offspring sex is not specified (i.e., if sex is NULL), the sex will be inferred from the strands provided where possible (when modeling an X or Y chromosome), or will be chosen randomly otherwise (when modeling autosomes); it will not be inferred from the sex of the individuals possessing the parental strands, even when the reproductive mode is essentially clonal from a single parent, since such inference would be ambiguous in the general case.\u00a0 When modeling the X or Y, strand1 and strand2 must be X genomes (or NULL), and strand3 and strand4 must both be X genomes or both be Y genomes (or NULL). By default, the offspring is considered to have no parents for the purposes of pedigree tracking, since there may be more than two \u201cparents\u201d in the general case.\u00a0 If pedigree tracking of parentage is desired, parent1 and/or parent2 may be passed to explicitly establish particular individuals as the parents of the offspring for purposes of pedigree tracking.\u00a0 In this case, if only one of parent1 and parent2 is non-NULL, that individual will be set as both of the parents of the offspring, mirroring the way that parentage is tracked for other cases such as addCloned() and addSelfed().\u00a0 It is not required for parent1 or parent2 to actually be a genetic parent of the offspring at all, although typically they would be. If randomizeStrands is F (the default), strand1 will be the initial copy strand when generating the first gamete to form the offspring, and strand3 will be the initial copy strand when generating the second gamete.\u00a0 If randomizeStrands is T, then if strand1 and strand2 are both non-NULL, 50% of the time they will be swapped, making strand2 the initial copy strand for the first gamete; and similarly, if strand3 and strand4 are both non-NULL, 50% of the time they will be swapped, making strand4 the initial copy strand for the second gamete.\u00a0 This is probably usually the desired behavior, to avoid an inheritance bias due to a lack of randomization in the initial copy strand, so passing T for randomizeStrands is recommended unless you specifically desire otherwise.\u00a0 It is not the default behavior only for reasons of backward compatibility. These semantics allow several uses for addRecombinant().\u00a0 When all strands are non-NULL, it is similar to addCrossed() except that the recombination breakpoints are specified explicitly, allowing very precise offspring generation without having to override SLiM\u2019s breakpoint generation with a recombination() callback.\u00a0 When only strand1 and strand3 are supplied, it is very similar to addCloned(), creating a clonal offspring, except that the two parental genomes need not belong to the same individual (whatever that might mean biologically).\u00a0 Supplying only strand1 is useful for modeling clonally reproducing haploids; the second genome of every offspring will be kept empty and will not receive new mutations.\u00a0 For a model of clonally reproducing haploids that undergo horizontal gene transfer (HGT), supplying only strand1 and strand2 will allow HGT from strand2 to replace segments of an otherwise clonal copy of strand1, while the second genome of the generated offspring will again be kept empty; this could be useful for modeling bacterial conjugation, for example.\u00a0 Other variations are also possible. The value of the meanParentAge property of the generated offspring is calculated from the mean parent age of each of its two genomes (whether they turn out to be null genomes or not); that may be an average of two values (if both offspring genomes have at least one parent), a single value (if one offspring genome has no parent), or no values (if both offspring genomes have no parent, in which case 0.0 results).\u00a0 The mean parent age of a given offspring genome is the mean of the ages of the parents of the two strands used to generate that offspring genome; if one strand is NULL then the mean parent age for that offspring genome is the age of the parent of the non-NULL strand, while if both strands are NULL then that offspring genome is parentless and is not used in the final calculation.\u00a0 In other words, if one offspring genome has two parents with ages A and B, and the other offspring genome has one parent with age C, the meanParentAge of the offspring will be (A+B+C+C)\u00a0/\u00a04, not (A+B+C)\u00a0/\u00a03. Note that gene conversion tracts are not explicitly supported by this method; the breaks vectors provide crossover breakpoints, which may be used to implement crossovers or simple gene conversion tracts.\u00a0 There is no way to specify complex gene conversion tracts with heteroduplex mismatch repair. Beginning in SLiM 4.1, the count parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).\u00a0 Each offspring is generated independently, based upon the given parameters.\u00a0 The returned vector contains all generated offspring, except those that were rejected by a modifyChild() callback.\u00a0 If all offspring are rejected, object<Individual>(0) is returned, which is a zero-length object vector of class Individual; note that this is a change in behavior from earlier versions, which would return NULL. Beginning in SLiM 4.1, passing T for defer will defer the generation of the genomes of the produced offspring until the end of the reproduction phase.\u00a0 Genome generation can only be deferred if there are no active mutation() callbacks; otherwise, an error will result.\u00a0 Furthermore, when genome generation is deferred the mutations of the genomes of the generated offspring may not be accessed until reproduction is complete (whether from a modifyChild() callback or otherwise).\u00a0 There is little or no advantage to deferring genome generation when running single-threaded; in that case, the default of F for defer is generally preferable since it has fewer restrictions.\u00a0 When running multi-threaded, deferring genome generation allows that task to be done in parallel (which is the reason this option exists). Also beginning in SLiM 4.1, in spatial models the spatial position of the offspring will be inherited (i.e., copied) from parent1; more specifically, the x property will be inherited in all spatial models (1D/2D/3D), the y property in 2D/3D models, and the z property in 3D models.\u00a0 Properties not inherited will be left uninitialized, as they were prior to SLiM 4.1.\u00a0 The parent\u2019s spatial position is probably not desirable in itself; the intention here is to make it easy to model the natal dispersal of all the new offspring for a given tick with a single vectorized call to deviatePositions() / pointDeviated().\u00a0 If parent1 is NULL (the default), parent2 will be used; if it is also NULL, no spatial position will be inherited. Note that this method is only for use in nonWF models.\u00a0 See addCrossed() for further general notes on the addition of new offspring individuals."
            },
            "addSelfed": {
                "signature": "(object<Individual>)addSelfed(object<Individual>$\u00a0parent, [integer$\u00a0count\u00a0=\u00a01], [logical$\u00a0defer\u00a0=\u00a0F])",
                "description": " Generates a new offspring individual from the given parent by selfing, queues it for addition to the target subpopulation, and returns it.\u00a0 The new offspring will not be visible as a member of the target subpopulation until the end of the offspring generation tick cycle stage.\u00a0 The subpopulation of parent will be used to locate applicable mutation(), recombination(), and modifyChild() callbacks governing the generation of the offspring individual. Since selfing requires that parent act as a source of both a male and a female gamete, this method may be called only in hermaphroditic models; calling it in sexual models will result in an error.\u00a0 This method represents a non-incidental selfing event, so the preventIncidentalSelfing flag of initializeSLiMOptions() has no effect on this method (in contrast to the behavior of addCrossed(), where selfing is assumed to be incidental). Beginning in SLiM 4.1, the count parameter dictates how many offspring will be generated (previously, exactly one offspring was generated).\u00a0 Each offspring is generated independently, based upon the given parameters.\u00a0 The returned vector contains all generated offspring, except those that were rejected by a modifyChild() callback.\u00a0 If all offspring are rejected, object<Individual>(0) is returned, which is a zero-length object vector of class Individual; note that this is a change in behavior from earlier versions, which would return NULL. Beginning in SLiM 4.1, passing T for defer will defer the generation of the genomes of the produced offspring until the end of the reproduction phase.\u00a0 Genome generation can only be deferred if there are no active mutation() or recombination() callbacks; otherwise, an error will result.\u00a0 Furthermore, when genome generation is deferred the mutations of the genomes of the generated offspring may not be accessed until reproduction is complete (whether from a modifyChild() callback or otherwise).\u00a0 There is little or no advantage to deferring genome generation when running single-threaded; in that case, the default of F for defer is generally preferable since it has fewer restrictions.\u00a0 When running multi-threaded, deferring genome generation allows that task to be done in parallel (which is the reason this option exists). Also beginning in SLiM 4.1, in spatial models the spatial position of the offspring will be inherited (i.e., copied) from parent; more specifically, the x property will be inherited in all spatial models (1D/2D/3D), the y property in 2D/3D models, and the z property in 3D models.\u00a0 Properties not inherited will be left uninitialized, as they were prior to SLiM 4.1.\u00a0 The parent\u2019s spatial position is probably not desirable in itself; the intention here is to make it easy to model the natal dispersal of all the new offspring for a given tick with a single vectorized call to deviatePositions() / pointDeviated(). Note that this method is only for use in nonWF models.\u00a0 See addCrossed() for further general notes on the addition of new offspring individuals."
            },
            "addSpatialMap": {
                "signature": "(void)addSpatialMap(object<SpatialMap>$\u00a0map)",
                "description": " Adds the given SpatialMap object, map, to the subpopulation.\u00a0 (The spatial map would have been previously created with a call to defineSpatialMap() on a different subpopulation; addSpatialMap() can then be used to add that existing spatial map with other subpopulations, sharing the map between subpopulations.)\u00a0 If the map is already added to the target subpopulation, this method does nothing; if a different map with the same name is already added to the subpopulation, an error results (because map names must be unique within each subpopulation).\u00a0 The map being added must be compatible with the target subpopulation; in particular, the spatial bounds utilized by the map must exactly match the corresponding spatial bounds for the subpopulation, and the dimensionality of the subpopulation must encompass the spatiality of the map.\u00a0 For example, if the map has a spatiality of \"xz\" then the subpopulation must have a dimensionality of \"xyz\" so that it encompasses both \"x\" and \"z\", and the subpopulation\u2019s spatial bounds for \"x\" and \"z\" must match those for the map (but the spatial bounds for \"y\" are unimportant, since the map does not use that dimension). Adding a map to a subpopulation is not strictly necessary, at present; one may query a SpatialMap object directly using mapValue(), regarding points in a subpopulation, without the map actually having been added to that subpopulation.\u00a0 However, it is a good idea to use addSpatialMap(), both for its compatibility check that prevents unnoticed scripting errors, and because it ensures correct display of the model in SLiMgui."
            },
            "cachedFitness": {
                "signature": "(float)cachedFitness(Ni\u00a0indices)",
                "description": " The fitness values calculated for the individuals at the indices given are returned.\u00a0 If NULL is passed, fitness values for all individuals in the subpopulation are returned.\u00a0 The fitness values returned are cached values; mutationEffect() and fitnessEffect() callbacks are therefore not called as a side effect of this method.\u00a0 It is always an error to call cachedFitness() from inside a mutationEffect() or fitnessEffect() callback, since fitness values are in the middle of being set up.\u00a0 In WF models, it is also an error to call cachedFitness() from a late() event, because fitness values for the new offspring generation have not yet been calculated and are undefined.\u00a0 In nonWF models, the population may be a mixture of new and old individuals, so instead, NAN will be returned as the fitness of any new individuals whose fitness has not yet been calculated.\u00a0 When new subpopulations are first created with addSubpop() or addSubpopSplit(), the fitness of all of the newly created individuals is considered to be 1.0 until fitness values are recalculated."
            },
            "configureDisplay": {
                "signature": "(void)configureDisplay([Nf\u00a0center\u00a0=\u00a0NULL], [Nf$\u00a0scale\u00a0=\u00a0NULL], [Ns$\u00a0color\u00a0=\u00a0NULL])",
                "description": " This method customizes the display of the subpopulation in SLiMgui\u2019s Population Visualization graph.\u00a0 When this method is called by a model running outside SLiMgui, it will do nothing except type-checking and bounds-checking its arguments.\u00a0 When called by a model running in SLiMgui, the position, size, and color of the subpopulation\u2019s displayed circle can be controlled as specified below. The center parameter sets the coordinates of the center of the subpopulation\u2019s displayed circle; it must be a float vector of length two, such that center[0] provides the x-coordinate and center[1] provides the y-coordinate.\u00a0 The square central area of the Population Visualization occupies scaled coordinates in [0,1] for both x and y, so the values in center must be within those bounds.\u00a0 If a value of NULL is provided, SLiMgui\u2019s default center will be used (which currently arranges subpopulations in a circle). The scale parameter sets a scaling factor to be applied to the radius of the subpopulation\u2019s displayed circle.\u00a0 The default radius used by SLiMgui is a function of the subpopulation\u2019s number of individuals; this default radius is then multiplied by scale.\u00a0 If a value of NULL is provided, the default radius will be used; this is equivalent to supplying a scale of 1.0.\u00a0 Typically the same scale value should be used by all subpopulations, to scale all of their circles up or down uniformly, but that is not required. The color parameter sets the color to be used for the displayed subpopulation\u2019s circle.\u00a0 Colors may be specified by name, or with hexadecimal RGB values of the form \"#RRGGBB\" (see the Eidos manual).\u00a0 If color is NULL or the empty string, \"\", SLiMgui\u2019s default (fitness-based) color will be used."
            },
            "defineSpatialMap": {
                "signature": "(object<SpatialMap>$)defineSpatialMap(string$\u00a0name, string$\u00a0spatiality, numeric\u00a0values, [logical$\u00a0interpolate\u00a0=\u00a0F], [Nif\u00a0valueRange\u00a0=\u00a0NULL], [Ns\u00a0colors\u00a0=\u00a0NULL])",
                "description": " Defines a spatial map for the subpopulation; see the SpatialMap documentation regarding this class.\u00a0 The new map is automatically added to the subpopulation; addSpatialMap() does not need to be called.\u00a0 (That method is for sharing the map with additional subpopulations, beyond the one for which the map was originally defined.)\u00a0 The new SpatialMap object is returned, and may be retained permanently using defineConstant() or defineGlobal() for convenience. The name of the map is given by name, and can be used to identify it.\u00a0 The map uses the spatial dimensions referenced by spatiality, which must be a subset of the dimensions defined for the simulation in initializeSLiMOptions().\u00a0 Spatiality \"x\" is permitted for dimensionality \"x\"; spatiality \"x\", \"y\", or \"xy\" for dimensionality \"xy\"; and spatiality \"x\", \"y\", \"z\", \"xy\", \"yz\", \"xz\", or \"xyz\" for dimensionality \"xyz\".\u00a0 The spatial map is defined by a grid of values supplied in parameter values.\u00a0 That grid of values is aligned with the spatial bounds of the subpopulation, as described in more detail below; the spatial map is therefore coupled to those spatial bounds, and can only be used in subpopulations that match those particular spatial bounds (to avoid stretching or shrinking the map).\u00a0 The remaining optional parameters are described below. Note that the semantics of this method changed in SLiM 3.5; in particular, the gridSize parameter was removed, and the interpretation of the values parameter changed as described below.\u00a0 Existing code written prior to SLiM 3.5 will produce an error, due to the removed gridSize parameter, and must be revised carefully to obtain the same result, even if NULL had been passed for gridSize previously. Beginning in SLiM 3.5, the values parameter must be a vector/matrix/array with the number of dimensions appropriate for the declared spatiality of the map; for example, a map with spatiality \"x\" would require a (one-dimensional) vector, spatiality \"xy\" would require a (two-dimensional) matrix, and a map with spatiality of \"xyz\" would require a three-dimensional array.\u00a0 (See the Eidos manual for discussion of vectors, matrices, and arrays.)\u00a0 The data in values is interpreted in such a way that a two-dimensional matrix of values, with (0, 0) at upper left and values by column, is transformed into the format expected by SLiM, with (0, 0) at lower left and values by row; in other words, the two-dimensional matrix as it prints in the Eidos console will match the appearance of the two-dimensional spatial map as seen in SLiMgui.\u00a0 This is a change in behavior from versions prior to SLiM 3.5; it ensures that images loaded from disk with the Eidos class Image can be used directly as spatial maps, achieving the expected orientation, with no need for transposition or flipping.\u00a0 If the spatial map is a three-dimensional array, it is read as successive z-axis \u201cplanes\u201d, each of which is a two-dimensional matrix that is treated as described above. Moving on to the other parameters of defineSpatialMap(): if interpolate is F, values across the spatial map are not interpolated; the value at a given point is equal to the nearest value defined by the grid of values specified.\u00a0 If interpolate is T, values across the spatial map will be interpolated (using linear, bilinear, or trilinear interpolation as appropriate) to produce spatially continuous variation in values.\u00a0 In either case, the corners of the value grid are exactly aligned with the corners of the spatial boundaries of the subpopulation as specified by setSpatialBounds(), and the value grid is then stretched across the spatial extent of the subpopulation in such a manner as to produce equal spacing between the values along each dimension.\u00a0 The setting of interpolation only affects how values between these grid points are calculated: by nearest-neighbor, or by linear interpolation.\u00a0 Interpolation of spatial maps with periodic boundaries is not handled specially; to ensure that the edges of a periodic spatial map join smoothly, simply ensure that the grid values at the edges of the map are identical, since they will be coincident after periodic wrapping.\u00a0 Note that cubic/bicubic interpolation is generally smoother than linear/bilinear interpolation, with fewer artifacts, but it is substantially slower to calculate; use the interpolate() method of SpatialMap to precalculate an interpolated map using cubic/bucubic interpolation. The valueRange and colors parameters travel together; either both are unspecified, or both are specified.\u00a0 They control how map values will be transformed into colors, by SLiMgui and by the mapColor() method.\u00a0 The valueRange parameter establishes the color-mapped range of spatial map values, as a vector of length two specifying a minimum and maximum; this does not need to match the actual range of values in the map.\u00a0 The colors parameter then establishes the corresponding colors for values within the interval defined by valueRange: values less than or equal to valueRange[0] will map to colors[0], values greater than or equal to valueRange[1] will map to the last colors value, and intermediate values will shade continuously through the specified vector of colors, with interpolation between adjacent colors to produce a continuous spectrum.\u00a0 This is much simpler than it sounds in this description; see the recipes in chapter 15 for an illustration of its use. Note that at present, SLiMgui will only display spatial maps of spatiality \"x\", \"y\", or \"xy\"; the color-mapping parameters will simply be ignored by SLiMgui for other spatiality values (even if the spatiality is a superset of these values; SLiMgui will not attempt to display an \"xyz\" spatial map, for example, since it has no way to choose which 2D slice through the xyz space it ought to display).\u00a0 The mapColor() method will return translated color strings for any spatial map, however, even if SLiMgui is unable to display the spatial map.\u00a0 If there are multiple spatial maps that SLiMgui is capable of displaying, it choose one for display by default, but other maps may be selected from the action menu on the individuals view (by clicking on the button with the gear icon)."
            },
            "deviatePositions": {
                "signature": "(void)deviatePositions(No<Individual>\u00a0individuals, string$\u00a0boundary, numeric$\u00a0maxDistance, string$\u00a0functionType, ...)",
                "description": " Deviates the spatial positions of the individuals supplied in individuals, using the provided boundary condition and dispersal kernel.\u00a0 If individuals is NULL, the positions of all individuals in the target subpopulation are deviated.\u00a0 This method is essentially a more efficient shorthand for getting the spatial positions of individuals from the spatialPosition property, deviating those positions with pointDeviated(), and setting the deviated positions back into individuals with the setSpatialPosition() method.\u00a0 The boundary condition boundary must be one of \"none\", \"periodic\", \"reflecting\", \"stopping\", or \"reprising\", and the spatial kernel type functionType must be one of \"f\", \"l\", \"e\", \"n\", or \"t\", with the ellipsis parameters ... supplying kernel configuration parameters appropriate for that kernel type; see pointDeviated() for further details.\u00a0 As with pointDeviated(), the ellipsis parameters that follow functionType may each, independently, be either a singleton or a vector of length equal to n.\u00a0 This allows each individual\u2019s position to be deviated with a different kernel, representing, for example, the movements of individuals with differing dispersal capabilities/propensities.\u00a0 (However, other parameters such as boundary, maxDistance, and functionType must be the same for all of the points, in the present design.)"
            },
            "outputMSSample": {
                "signature": "(void)outputMSSample(integer$\u00a0sampleSize, [logical$\u00a0replace\u00a0=\u00a0T], [string$\u00a0requestedSex\u00a0=\u00a0\"*\"], [Ns$\u00a0filePath\u00a0=\u00a0NULL], [logical$\u00a0append\u00a0=\u00a0F], [logical$\u00a0filterMonomorphic\u00a0=\u00a0F])",
                "description": " Output a random sample from the subpopulation in MS format.\u00a0 Positions in the output will span the interval [0,1].\u00a0 A sample of genomes (not entire individuals, note) of size sampleSize from the subpopulation will be output.\u00a0 The sample may be done either with or without replacement, as specified by replace; the default is to sample with replacement.\u00a0 A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing \"M\" or \"F\" for requestedSex; passing \"*\", the default, indicates that genomes from individuals should be selected randomly, without respect to sex.\u00a0 If the sampling options provided by this method are not adequate, see the outputMS() method of Genome for a more flexible low-level option. If the optional parameter filePath is NULL (the default), output will be sent to Eidos\u2019s output stream.\u00a0 Otherwise, output will be sent to the filesystem path specified by filePath, overwriting that file if append if F, or appending to the end of it if append is T. If filterMonomorphic is F (the default), all mutations that are present in the sample will be included in the output.\u00a0 This means that some mutations may be included that are actually monomorphic within the sample (i.e., that exist in every sampled genome, and are thus apparently fixed).\u00a0 These may be filtered out with filterMonomorphic = T if desired; note that this option means that some mutations that do exist in the sampled genomes might not be included in the output, simply because they exist in every sampled genome. See outputSample() and outputVCFSample() for other output formats.\u00a0 Output is generally done in a late() event, so that the output reflects the state of the simulation at the end of a tick."
            },
            "outputSample": {
                "signature": "(void)outputSample(integer$\u00a0sampleSize, [logical$\u00a0replace\u00a0=\u00a0T], [string$\u00a0requestedSex\u00a0=\u00a0\"*\"], [Ns$\u00a0filePath\u00a0=\u00a0NULL], [logical$\u00a0append\u00a0=\u00a0F])",
                "description": " Output a random sample from the subpopulation in SLiM\u2019s native format.\u00a0 A sample of genomes (not entire individuals, note) of size sampleSize from the subpopulation will be output.\u00a0 The sample may be done either with or without replacement, as specified by replace; the default is to sample with replacement.\u00a0 A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing \"M\" or \"F\" for requestedSex; passing \"*\", the default, indicates that genomes from individuals should be selected randomly, without respect to sex.\u00a0 If the sampling options provided by this method are not adequate, see the output() method of Genome for a more flexible low-level option. If the optional parameter filePath is NULL (the default), output will be sent to Eidos\u2019s output stream.\u00a0 Otherwise, output will be sent to the filesystem path specified by filePath, overwriting that file if append if F, or appending to the end of it if append is T. See outputMSSample() and outputVCFSample() for other output formats.\u00a0 Output is generally done in a late() event, so that the output reflects the state of the simulation at the end of a tick."
            },
            "outputVCFSample": {
                "signature": "(void)outputVCFSample(integer$\u00a0sampleSize, [logical$\u00a0replace\u00a0=\u00a0T], [string$\u00a0requestedSex\u00a0=\u00a0\"*\"], [logical$\u00a0outputMultiallelics\u00a0=\u00a0T], [Ns$\u00a0filePath\u00a0=\u00a0NULL], [logical$\u00a0append\u00a0=\u00a0F], [logical$\u00a0simplifyNucleotides\u00a0=\u00a0F], [logical$\u00a0outputNonnucleotides\u00a0=\u00a0T])",
                "description": " Output a random sample from the subpopulation in VCF format.\u00a0 A sample of individuals (not genomes, note \u2013 unlike the outputSample() and outputMSSample() methods) of size sampleSize from the subpopulation will be output.\u00a0 The sample may be done either with or without replacement, as specified by replace; the default is to sample with replacement.\u00a0 A particular sex of individuals may be requested for the sample, for simulations in which sex is enabled, by passing \"M\" or \"F\" for requestedSex; passing \"*\", the default, indicates that genomes from individuals should be selected randomly, without respect to sex.\u00a0 If the sampling options provided by this method are not adequate, see the outputVCF() method of Genome for a more flexible low-level option. If the optional parameter filePath is NULL (the default), output will be sent to Eidos\u2019s output stream.\u00a0 Otherwise, output will be sent to the filesystem path specified by filePath, overwriting that file if append if F, or appending to the end of it if append is T. The parameters outputMultiallelics, simplifyNucleotides, and outputNonnucleotides affect the format of the output produced; see the reference documentation for further discussion. See outputMSSample() and outputSample() for other output formats.\u00a0 Output is generally done in a late() event, so that the output reflects the state of the simulation at the end of a tick."
            },
            "pointDeviated": {
                "signature": "(float)pointDeviated(integer$\u00a0n, float\u00a0point, string$\u00a0boundary, numeric$\u00a0maxDistance, string$\u00a0functionType, ...)",
                "description": " Returns a vector containing n points that are derived from point by adding a deviation drawn from a dispersal kernel (specified by maxDistance, functionType, and the ellipsis parameters ..., as detailed below) and then applying a boundary condition specified by boundary.\u00a0 This method therefore performs the steps of a simple dispersal algorithm in a single vectorized call.\u00a0 See deviatePositions() for an even more efficient approach. The parameter point may contain a single point which is deviated and bounded n independent times, or may contain n points each of which is deviated and bounded.\u00a0 In any case, each point in point should match the dimensionality of the model \u2013 one element in a 1D model, two elements in a 2D model, or three elements in a 3D model.\u00a0 This method should not be called in a non-spatial model. The dispersal kernel is specified similarly to other kernel-based methods, such as setInteractionFunction() and smooth().\u00a0 For pointDeviated(), functionType may be \"f\" with no ellipsis arguments ... to use a flat kernel out to maxDistance; \"l\" with no ellipsis arguments for a kernel that decreases linearly from the center to zero at maxDistance; \"e\", in which case the ellipsis should supply a numeric$ lambda (rate) parameter for a negative exponential function; \"n\", in which case the ellipsis should supply a numeric$ sigma (standard deviation) parameter for a Gaussian function; or \"t\", in which case the ellipsis should supply a numeric$ degrees of freedom and a numeric$ scale parameter for a t-distribution function.\u00a0 The Cauchy (\"c\") kernel is not supported by pointDeviated() since it is not well-behaved for this purpose, and the Student\u2019s t (\"t\") kernel is not allowed in 3D models at present simply because it hasn\u2019t been implemented.\u00a0 See the InteractionType class documentation (section 25.8) for more detailed discussion of the available kernel types and their parameters and probability distribution functions.\u00a0 For pointDeviated(), the ellipsis parameters that follow functionType may each, independently, be either a singleton or a vector of length equal to n.\u00a0 This allows each point to be deviated with a different kernel, representing, for example, the movements of individuals with differing dispersal capabilities/propensities.\u00a0 (However, other parameters such as boundary, maxDistance, and functionType must be the same for all of the points, in the present design.) The random points returned from this method are drawn from the probability distribution that is radially symmetric and has density proportional to the kernel \u2013 in other words, at distance r the density is proportional to the kernel type referred to by functionType.\u00a0 (Said another way, the shape of the cross-section through the probability density function is given by the kernel.)\u00a0 For instance, the value of the type \"e\" (exponential) kernel with rate a at r is proportional to exp(\u2212ar), and so in 2D, the probability density that this method with kernel type \"e\" draws from has density proportional to p(x,\u00a0y)\u00a0=\u00a0exp(\u2212a\u00a0sqrt(x2\u00a0+\u00a0y2)), since r\u00a0=\u00a0sqrt(x2\u00a0+\u00a0y2) is the distance.\u00a0 Note that the distribution of the distance is not given by the kernel except in 1D: in the type\u00a0\"e\"\u00a0example, the distribution of the distance in 1D is exponential, while in 2D it has density proportional to r\u00a0exp(\u2212ar) (i.e., Gamma with shape parameter 1).\u00a0 For another example, the value of the type \"n\" (Normal) kernel at r with standard deviation 1 is proportional to exp(\u2212r2\u00a0/\u00a02), and so the density is proportional to\u00a0p(x,\u00a0y)\u00a0=\u00a0exp(\u2212(x2\u00a0+\u00a0y2)\u00a0/\u00a02).\u00a0 This is the standard bivariate Normal, and equivalent to drawing independent Normals for the x and y directions; however, the Normal is the only distribution for which independent draws along each axis will result in a radially symmetric distribution.\u00a0 The distribution of the distance in 2D with type \"n\" is proportional to r\u00a0exp(\u2212r2\u00a0/\u00a02), i.e., Rayleigh. The boundary condition must be one of \"none\", \"periodic\", \"reflecting\", \"stopping\", or \"reprising\".\u00a0 For \"none\", no boundary condition is enforced; the deviated points are simply returned as is.\u00a0 For \"periodic\", \"reflecting\", and \"stopping\", the boundary condition is enforced just as it is by the pointPeriodic(), pointReflected(), and pointStopped() methods; see their documentation for further details.\u00a0 For \"reprising\", if the deviated point is out of bounds a new deviated point will be chosen, based upon the same original point, until a point inside bounds is obtained.\u00a0 Note that absorbing boundaries (for which being out-of-bounds is lethal) would be implemented in script; this method cannot enforce them. Note that for the typical usage case, in which point comes from the spatialPosition property for a vector of individuals, and the result is then set back onto the same vector of individuals using the setSpatialPosition() method, the deviatePositions() method provides an even more efficient alternative."
            },
            "pointInBounds": {
                "signature": "(logical)pointInBounds(float\u00a0point)",
                "description": " Returns T if point is inside the spatial boundaries of the subpopulation, F otherwise.\u00a0 For example, for a simulation with \"xy\" dimensionality, if point contains exactly two values constituting an (x,y) point, the result will be T if and only if ((point[0]>=x0) & (point[0]<=x1) & (point[1]>=y0) & (point[1]<=y1)) given spatial bounds (x0, y0, x1, y1).\u00a0 This method is useful for implementing absorbing or reprising boundary conditions.\u00a0 This may only be called in simulations for which continuous space has been enabled with initializeSLiMOptions(). The length of point must be an exact multiple of the dimensionality of the simulation; in other words, point may contain values comprising more than one point.\u00a0 In this case, a logical vector will be returned in which each element is T if the corresponding point in point is inside the spatial boundaries of the subpopulation, F otherwise."
            },
            "pointPeriodic": {
                "signature": "(float)pointPeriodic(float\u00a0point)",
                "description": " Returns a revised version of point that has been brought inside the periodic spatial boundaries of the subpopulation (as specified by the periodicity parameter of initializeSLiMOptions()) by wrapping around periodic spatial boundaries.\u00a0 In brief, if a coordinate of point lies beyond a periodic spatial boundary, that coordinate is wrapped around the boundary, so that it lies inside the spatial extent by the same magnitude that it previously lay outside, but on the opposite side of the space; in effect, the two edges of the periodic spatial boundary are seamlessly joined.\u00a0 This is done iteratively until all coordinates lie inside the subpopulation\u2019s periodic boundaries.\u00a0 Note that non-periodic spatial boundaries are not enforced by this method; they should be enforced using pointReflected(), pointStopped(), or some other means of enforcing boundary constraints (which can be used after pointPeriodic() to bring the remaining coordinates into bounds; coordinates already brought into bounds by pointPeriodic() will be unaffected by those calls).\u00a0 This method is useful for implementing periodic boundary conditions.\u00a0 This may only be called in simulations for which continuous space\u00a0 and at least one periodic spatial dimension have been enabled with initializeSLiMOptions(). The length of point must be an exact multiple of the dimensionality of the simulation; in other words, point may contain values comprising more than one point.\u00a0 In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned."
            },
            "pointReflected": {
                "signature": "(float)pointReflected(float\u00a0point)",
                "description": " Returns a revised version of point that has been brought inside the spatial boundaries of the subpopulation by reflection.\u00a0 In brief, if a coordinate of point lies beyond a spatial boundary, that coordinate is reflected across the boundary, so that it lies inside the boundary by the same magnitude that it previously lay outside the boundary.\u00a0 This is done iteratively until all coordinates lie inside the subpopulation\u2019s boundaries.\u00a0 This method is useful for implementing reflecting boundary conditions.\u00a0 This may only be called in simulations for which continuous space has been enabled with initializeSLiMOptions(). The length of point must be an exact multiple of the dimensionality of the simulation; in other words, point may contain values comprising more than one point.\u00a0 In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned."
            },
            "pointStopped": {
                "signature": "(float)pointStopped(float\u00a0point)",
                "description": " Returns a revised version of point that has been brought inside the spatial boundaries of the subpopulation by clamping.\u00a0 In brief, if a coordinate of point lies beyond a spatial boundary, that coordinate is set to exactly the position of the boundary, so that it lies on the edge of the spatial boundary.\u00a0 This method is useful for implementing stopping boundary conditions.\u00a0 This may only be called in simulations for which continuous space has been enabled with initializeSLiMOptions(). The length of point must be an exact multiple of the dimensionality of the simulation; in other words, point may contain values comprising more than one point.\u00a0 In this case, each point will be processed as described above and a new vector containing all of the processed points will be returned."
            },
            "pointUniform": {
                "signature": "(float)pointUniform([integer$\u00a0n\u00a0=\u00a01])",
                "description": " Returns a new point (or points, for n > 1) generated from uniform draws for each coordinate, within the spatial boundaries of the subpopulation.\u00a0 The returned vector will contain n points, each comprised of a number of coordinates equal to the dimensionality of the simulation, so it will be of total length n*dimensionality.\u00a0 This may only be called in simulations for which continuous space has been enabled with initializeSLiMOptions()."
            },
            "removeSpatialMap": {
                "signature": "(void)removeSpatialMap(so<SpatialMap>$\u00a0map)",
                "description": " Removes the SpatialMap object specified by map from the subpopulation.\u00a0 The parameter map may be either a SpatialMap object, or a string name for spatial map.\u00a0 The map must have been added to the subpopulation with addSpatialMap(); if it has not been, an error results.\u00a0 Removing spatial maps that are no longer in use is optional in most cases.\u00a0 It is generally a good idea because it might decrease SLiM\u2019s memory footprint; also, it avoids an error if the subpopulation\u2019s spatial bounds are changed (see setSpatialBounds())."
            },
            "removeSubpopulation": {
                "signature": "(void)removeSubpopulation(void)",
                "description": " Removes this subpopulation from the model.\u00a0 The subpopulation is immediately removed from the list of active subpopulations, and the symbol representing the subpopulation is undefined.\u00a0 The subpopulation object itself remains unchanged until children are next generated (at which point it is deallocated), but it is no longer part of the simulation and should not be used. Note that this method is only for use in nonWF models, in which there is a distinction between a subpopulation being empty and a subpopulation being removed from the simulation; an empty subpopulation may be re-colonized by migrants, whereas as a removed subpopulation no longer exists at all.\u00a0 WF models do not make this distinction; when a subpopulation is empty it is automatically removed.\u00a0 WF models should therefore call setSubpopulationSize(0) instead of this method; setSubpopulationSize() is the standard way for WF models to change the subpopulation size, including to a size of 0."
            },
            "sampleIndividuals": {
                "signature": "(object<Individual>)sampleIndividuals(integer$\u00a0size, [logical$\u00a0replace\u00a0=\u00a0F], [No<Individual>$\u00a0exclude\u00a0=\u00a0NULL], [Ns$\u00a0sex\u00a0=\u00a0NULL], [Ni$\u00a0tag\u00a0=\u00a0NULL], [Ni$\u00a0minAge\u00a0=\u00a0NULL], [Ni$\u00a0maxAge\u00a0=\u00a0NULL], [Nl$\u00a0migrant\u00a0=\u00a0NULL], [Nl$\u00a0tagL0\u00a0=\u00a0NULL], [Nl$\u00a0tagL1\u00a0=\u00a0NULL], [Nl$\u00a0tagL2\u00a0=\u00a0NULL], [Nl$\u00a0tagL3\u00a0=\u00a0NULL], [Nl$\u00a0tagL4\u00a0=\u00a0NULL])",
                "description": " Returns a vector of individuals, of size less than or equal to parameter size, sampled from the individuals in the target subpopulation.\u00a0 Sampling is done without replacement if replace is F (the default), or with replacement if replace is T.\u00a0 The remaining parameters specify constraints upon the pool of individuals that will be considered candidates for the sampling.\u00a0 Parameter exclude, if non-NULL, may specify a specific individual that should not be considered a candidate (typically the focal individual in some operation).\u00a0 Parameter sex, if non-NULL, may specify a sex (\"M\" or \"F\") for the individuals to be drawn, in sexual models.\u00a0 Parameter tag, if non-NULL, may specify a tag property value for the individuals to be drawn.\u00a0 Parameters minAge and maxAge, if non-NULL, may specify a minimum or maximum age for the individuals to be drawn, in nonWF models.\u00a0 Parameter migrant, if non-NULL, may specify a required value for the migrant property of the individuals to be drawn (so T will require that individuals be migrants, F will require that they not be).\u00a0 Finally, parameters tagL0, tagL1, tagL2, tagL3, and tagL4, if non-NULL, may specify a required value (T or F) for the corresponding properties (tagL0, tagL1, tagL2, tagL3, and tagL4) of the individuals to be drawn.\u00a0 Note that if any tag/tagL parameter is specified as non-NULL, that tag/tagL property must have a defined value for every individual in the subpopulation, otherwise an error may result (although this requirement will not necessarily be checked comprehensively by this method in every invocation).\u00a0 If the candidate pool is smaller than the requested sample size, all eligible candidates will be returned (in randomized order); the result will be a zero-length vector if no eligible candidates exist (unlike sample()). This method is similar to getting the individuals property of the subpopulation, using operator [] to select only individuals with the desired properties, and then using sample() to sample from that candidate pool.\u00a0 However, besides being much simpler than the equivalent Eidos code, it is also much faster, and it does not fail if less than the full sample size is available.\u00a0 See subsetIndividuals() for a similar method that returns a full subset, rather than a sample."
            },
            "setCloningRate": {
                "signature": "(void)setCloningRate(numeric\u00a0rate)",
                "description": " Set the cloning rate of this subpopulation.\u00a0 The rate is changed to rate, which should be between 0.0 and 1.0, inclusive (see the SLiM manual for further details).\u00a0 Clonal reproduction can be enabled in both non-sexual (i.e. hermaphroditic) and sexual simulations.\u00a0 In non-sexual simulations, rate must be a singleton value representing the overall clonal reproduction rate for the subpopulation.\u00a0 In sexual simulations, rate may be either a singleton (specifying the clonal reproduction rate for both sexes) or a vector containing two numeric values (the female and male cloning rates specified separately, at indices 0 and 1 respectively).\u00a0 During mating and offspring generation, the probability that any given offspring individual will be generated by cloning \u2013 by asexual reproduction without gametes or meiosis \u2013 will be equal to the cloning rate (for its sex, in sexual simulations) set in the parental (not the offspring!) subpopulation."
            },
            "setMigrationRates": {
                "signature": "(void)setMigrationRates(io<Subpopulation>\u00a0sourceSubpops, numeric\u00a0rates)",
                "description": " Set the migration rates to this subpopulation from the subpopulations in sourceSubpops to the corresponding rates specified in rates; in other words, rates gives the expected fractions of the children in this subpopulation that will subsequently be generated from parents in the subpopulations sourceSubpops (see the SLiM manual for further details).\u00a0 This method will only set the migration fractions from the subpopulations given; migration rates from other subpopulations will be left unchanged (explicitly set a zero rate to turn off migration from a given subpopulation).\u00a0 The type of sourceSubpops may be either integer, specifying subpopulations by identifier, or object, specifying subpopulations directly."
            },
            "setSelfingRate": {
                "signature": "(void)setSelfingRate(numeric$\u00a0rate)",
                "description": " Set the selfing rate of this subpopulation.\u00a0 The rate is changed to rate, which should be between 0.0 and 1.0, inclusive (see the SLiM manual for further details).\u00a0 Selfing can only be enabled in non-sexual (i.e. hermaphroditic) simulations.\u00a0 During mating and offspring generation, the probability that any given offspring individual will be generated by selfing \u2013 by self-fertilization via gametes produced by meiosis by a single parent \u2013 will be equal to the selfing rate set in the parental (not the offspring!) subpopulation."
            },
            "setSexRatio": {
                "signature": "(void)setSexRatio(float$\u00a0sexRatio)",
                "description": " Set the sex ratio of this subpopulation to sexRatio.\u00a0 As defined in SLiM, this is actually the fraction of the subpopulation that is male; in other words, the M:(M+F) ratio.\u00a0 This will take effect when children are next generated; it does not change the current subpopulation state.\u00a0 Unlike the selfing rate, the cloning rate, and migration rates, the sex ratio is deterministic: SLiM will generate offspring that exactly satisfy the requested sex ratio (within integer roundoff limits)."
            },
            "setSpatialBounds": {
                "signature": "(void)setSpatialBounds(numeric\u00a0bounds)",
                "description": " Set the spatial boundaries of the subpopulation to bounds.\u00a0 This method may be called only for simulations in which continuous space has been enabled with initializeSLiMOptions().\u00a0 The length of bounds must be double the spatial dimensionality, so that it supplies both minimum and maximum values for each coordinate.\u00a0 More specifically, for a dimensionality of \"x\", bounds should supply (x0,\u00a0x1) values; for dimensionality \"xy\" it should supply (x0,\u00a0y0,\u00a0x1,\u00a0y1) values; and for dimensionality \"xyz\" it should supply (x0,\u00a0y0,\u00a0z0,\u00a0x1,\u00a0y1,\u00a0z1) (in that order).\u00a0 These boundaries will be used by SLiMgui to calibrate the display of the subpopulation, and will be used by methods such as pointInBounds(), pointReflected(), pointStopped(), and pointUniform().\u00a0 The default spatial boundaries for all subpopulations span the interval [0,1] in each dimension.\u00a0 Spatial dimensions that are periodic (as established with the periodicity parameter to initializeSLiMOptions()) must have a minimum coordinate value of 0.0 (a restriction that allows the handling of periodicity to be somewhat more efficient).\u00a0 The current spatial bounds for the subpopulation may be obtained through the spatialBounds property. The spatial bounds of a subpopulation are shared with any SpatialMap objects added to the subpopulation.\u00a0 For this reason, once a spatial map has been added to a subpopulation, the spatial bounds of the subpopulation can no longer be changed (because it would stretch or shrink the associated spatial map, which does not seem to make physical sense).\u00a0 The bounds for a subpopulation should therefore be configured before any spatial maps are added to it.\u00a0 If those bounds do need to change subsequently, any associated spatial maps must first be removed with removeSpatialMap(), to ensure model consistency."
            },
            "setSubpopulationSize": {
                "signature": "(void)setSubpopulationSize(integer$\u00a0size)",
                "description": " Set the size of this subpopulation to size individuals (see the SLiM manual for further details).\u00a0 This will take effect when children are next generated; it does not change the current subpopulation state.\u00a0 Setting a subpopulation to a size of 0 does have some immediate effects that serve to disconnect it from the simulation: the subpopulation is removed from the list of active subpopulations, the subpopulation is removed as a source of migration for all other subpopulations, and the symbol representing the subpopulation is undefined.\u00a0 In this case, the subpopulation itself remains unchanged until children are next generated (at which point it is deallocated), but it is no longer part of the simulation and should not be used."
            },
            "spatialMapColor": {
                "signature": "(string)spatialMapColor(string$\u00a0name, numeric\u00a0value)",
                "description": " This method has been deprecated, and may be removed in a future release of SLiM.\u00a0 In SLiM 4.1 and later, use the SpatialMap method mapColor() instead, and see that method\u2019s documentation.\u00a0 (This method differs only in taking a name parameter, which is used to look up the spatial map from those that have been added to the subpopulation.)"
            },
            "spatialMapImage": {
                "signature": "(object<Image>$)spatialMapImage(string$\u00a0name, [Ni$\u00a0width\u00a0=\u00a0NULL], [Ni$\u00a0height\u00a0=\u00a0NULL], [logical$\u00a0centers\u00a0=\u00a0F], [logical$\u00a0color\u00a0=\u00a0T])",
                "description": " This method has been deprecated, and may be removed in a future release of SLiM.\u00a0 In SLiM 4.1 and later, use the SpatialMap method mapImage() instead, and see that method\u2019s documentation.\u00a0 (This method differs only in taking a name parameter, which is used to look up the spatial map from those that have been added to the subpopulation.)"
            },
            "spatialMapValue": {
                "signature": "(float)spatialMapValue(so<SpatialMap>$\u00a0map, float\u00a0point)",
                "description": " Looks up the spatial map specified by map, and uses its mapping machinery (as defined by the gridSize, values, and interpolate parameters to defineSpatialMap()) to translate the coordinates of point into a corresponding map value.\u00a0 The parameter map may specify the map either as a SpatialMap object, or by its string name; in either case, the map must have been added to the subpopulation.\u00a0 The length of point must be equal to the spatiality of the spatial map; in other words, for a spatial map with spatiality \"xz\", point must be of length 2, specifying the x and z coordinates of the point to be evaluated.\u00a0 Interpolation will automatically be used if it was enabled for the spatial map.\u00a0 Point coordinates are clamped into the range defined by the spatial boundaries, even if the spatial boundaries are periodic; use pointPeriodic() to wrap the point coordinates first if desired.\u00a0 See the documentation for defineSpatialMap() for information regarding the details of value mapping. Beginning in SLiM 3.3, point may contain more than one point to be looked up.\u00a0 In this case, the length of point must be an exact multiple of the spatiality of the spatial map; for a spatial map with spatiality \"xz\", for example, the length of point must be an exact multiple of 2, and successive pairs of elements from point (elements 0 and 1, then elements 2 and 3, etc.) will be taken as the x and z coordinates of the points to be evaluated.\u00a0 This allows spatialMapValue() to be used in a vectorized fashion. The mapValue() method of SpatialMap provides the same functionality directly on the SpatialMap class; spatialMapValue() is provided on Subpopulation partly for backward compatibility, but also for convenience in some usage cases."
            },
            "subsetIndividuals": {
                "signature": "(object<Individual>)subsetIndividuals([No<Individual>$\u00a0exclude\u00a0=\u00a0NULL], [Ns$\u00a0sex\u00a0=\u00a0NULL], [Ni$\u00a0tag\u00a0=\u00a0NULL], [Ni$\u00a0minAge\u00a0=\u00a0NULL], [Ni$\u00a0maxAge\u00a0=\u00a0NULL], [Nl$\u00a0migrant\u00a0=\u00a0NULL], [Nl$\u00a0tagL0\u00a0=\u00a0NULL], [Nl$\u00a0tagL1\u00a0=\u00a0NULL], [Nl$\u00a0tagL2\u00a0=\u00a0NULL], [Nl$\u00a0tagL3\u00a0=\u00a0NULL], [Nl$\u00a0tagL4\u00a0=\u00a0NULL])",
                "description": " Returns a vector of individuals subset from the individuals in the target subpopulation.\u00a0 The parameters specify constraints upon the subset of individuals that will be returned.\u00a0 Parameter exclude, if non-NULL, may specify a specific individual that should not be included (typically the focal individual in some operation).\u00a0 Parameter sex, if non-NULL, may specify a sex (\"M\" or \"F\") for the individuals to be returned, in sexual models.\u00a0 Parameter tag, if non-NULL, may specify a tag property value for the individuals to be returned.\u00a0 Parameters minAge and maxAge, if non-NULL, may specify a minimum or maximum age for the individuals to be returned, in nonWF models.\u00a0 Parameter migrant, if non-NULL, may specify a required value for the migrant property of the individuals to be returned (so T will require that individuals be migrants, F will require that they not be).\u00a0 Finally, parameters tagL0, tagL1, tagL2, tagL3, and tagL4, if non-NULL, may specify a required value (T or F) for the corresponding properties (tagL0, tagL1, tagL2, tagL3, and tagL4) of the individuals to be returned.\u00a0 Note that if any tag/tagL parameter is specified as non-NULL, that tag/tagL property must have a defined value for every individual in the subpopulation, otherwise an error may result (although this requirement will not necessarily be checked comprehensively by this method in every invocation). This method is shorthand for getting the individuals property of the subpopulation, and then using operator [] to select only individuals with the desired properties; besides being much simpler than the equivalent Eidos code, it is also much faster.\u00a0 See sampleIndividuals() for a similar method that returns a sample taken from a chosen subset of individuals."
            },
            "takeMigrants": {
                "signature": "(void)takeMigrants(object<Individual>\u00a0migrants)",
                "description": " Immediately moves the individuals in migrants to the target subpopulation (removing them from their previous subpopulation).\u00a0 Individuals in migrants that are already in the target subpopulation are unaffected.\u00a0 Note that the indices and order of individuals and genomes in both the target and source subpopulations will change unpredictably as a side effect of this method. Note that this method is only for use in nonWF models, in which migration is managed manually by the model script.\u00a0 In WF models, migration is managed automatically by the SLiM core based upon the migration rates set for each subpopulation with setMigrationRates()."
            }
        },
        "properties": {
            "cloningRate": {
                "type": "float",
                "description": " The fraction of children in the next generation that will be produced by cloning (as opposed to biparental mating).\u00a0 In non-sexual (i.e. hermaphroditic) simulations, this property is a singleton float representing the overall subpopulation cloning rate.\u00a0 In sexual simulations, this property is a float vector with two values: the cloning rate for females (at index 0) and for males (at index 1)."
            },
            "description": {
                "type": "string$",
                "description": " A human-readable string description for the subpopulation.\u00a0 By default, this is the empty string, \"\"; however, it may be set to whatever you wish.\u00a0 When tree-sequence recording is enabled, description is persisted in the subpopulation\u2019s metadata in tree-sequence output."
            },
            "firstMaleIndex": {
                "type": "integer$",
                "description": " The index of the first male individual in the subpopulation.\u00a0 The genomes vector is sorted into females first and males second; firstMaleIndex gives the position of the boundary between those sections.\u00a0 Note, however, that there are two genomes per diploid individual, and the firstMaleIndex is not premultiplied by 2; you must multiply it by 2 before using it to decide whether a given index into genomes is a genome for a male or a female.\u00a0 The firstMaleIndex property is also the number of females in the subpopulation, given this design.\u00a0 For non-sexual (i.e. hermaphroditic) simulations, this property has an undefined value and should not be used."
            },
            "fitnessScaling": {
                "type": "float$",
                "description": " A float scaling factor applied to the fitness of all individuals in this subpopulation (i.e., the fitness value computed for each individual will be multiplied by this value).\u00a0 This is primarily of use in nonWF models, where fitness is absolute, rather than in WF models, where fitness is relative (and thus a constant factor multiplied into the fitness of every individual will make no difference); however, it may be used in either type of model.\u00a0 This provides a simple, fast way to modify the fitness of all individuals in a subpopulation; conceptually it is similar to returning the same fitness effect for all individuals in the subpopulation from a fitnessEffect() callback, but without the complexity and performance overhead of implementing such a callback.\u00a0 To scale the fitness of individuals by different (individual-specific) factors, see the fitnessScaling property of Individual. The value of fitnessScaling is reset to 1.0 every tick, so that any scaling factor set lasts for only a single tick.\u00a0 This reset occurs immediately after fitness values are calculated, in both WF and nonWF models."
            },
            "genomes": {
                "type": "object<Genome>",
                "description": " All of the genomes contained by the subpopulation; there are two genomes per diploid individual."
            },
            "genomesNonNull": {
                "type": "object<Genome>",
                "description": " All of the genomes contained by the subpopulation, as with the genomes property, if all of them are not null genomes; any null genomes present are excluded from the returned vector.\u00a0 This is a convenience shorthand, sometimes useful in models that involve null genomes."
            },
            "id": {
                "type": "integer$",
                "description": " The identifier for this subpopulation; for subpopulation p3, for example, this is 3."
            },
            "immigrantSubpopFractions": {
                "type": "float",
                "description": " The expected value of the fraction of children in the next generation that are immigrants arriving from particular subpopulations."
            },
            "immigrantSubpopIDs": {
                "type": "integer",
                "description": " The identifiers of the particular subpopulations from which immigrants will arrive in the next generation."
            },
            "individualCount": {
                "type": "integer$",
                "description": " The number of individuals in the subpopulation; one-half of the number of genomes."
            },
            "individuals": {
                "type": "object<Individual>",
                "description": " All of the individuals contained by the subpopulation.\u00a0 Each individual is diploid and thus contains two Genome objects.\u00a0 See the sampleIndividuals() and subsetIndividuals() for fast ways to get a subset of the individuals in a subpopulation."
            },
            "lifetimeReproductiveOutput": {
                "type": "integer",
                "description": " If pedigree tracking is turned on with initializeSLiMOptions(keepPedigrees=T), lifetimeReproductiveOutput contains the value of the Individual property reproductiveOutput for all individuals in the subpopulation that died in the last viability/survival tick cycle stage (or, for WF models, immediately after reproduction).\u00a0 This allows access to the lifetime reproductive output of individuals in the subpopulation at the end of their lives.\u00a0 If pedigree tracking is not on, this property is unavailable."
            },
            "lifetimeReproductiveOutputF": {
                "type": "integer",
                "description": " If pedigree tracking is turned on with initializeSLiMOptions(keepPedigrees=T), lifetimeReproductiveOutputF contains the value of the Individual property reproductiveOutput for all female individuals in the subpopulation that died in the last viability/survival tick cycle stage (or, for WF models, immediately after reproduction).\u00a0 This property is undefined if separate sexes have not been enabled, or if pedigree tracking is not on."
            },
            "lifetimeReproductiveOutputM": {
                "type": "integer",
                "description": " If pedigree tracking is turned on with initializeSLiMOptions(keepPedigrees=T), lifetimeReproductiveOutputM contains the value of the Individual property reproductiveOutput for all male individuals in the subpopulation that died in the last viability/survival tick cycle stage (or, for WF models, immediately after reproduction).\u00a0 This property is undefined if separate sexes have not been enabled, or if pedigree tracking is not on."
            },
            "name": {
                "type": "string$",
                "description": " A human-readable string name for the subpopulation.\u00a0 By default, this is the subpopulation\u2019s symbol as a string; for subpopulation p3, for example, name defaults to \"p3\".\u00a0 However, it may be set to whatever you wish except that subpopulation names must be unique across time (two different subpopulations may not both have the name \"foo\", even if they never exist at the same time).\u00a0 A subpopulation\u2019s name may appear as a label in SLiMgui, and it can be useful in generating output, debugging, and other purposes.\u00a0 When tree-sequence recording is enabled, name is persisted in the subpopulation\u2019s metadata in tree-sequence output, and can then be used in Python to identify the subpopulation; if you plan to take advantage of that feature, name should follow the syntax of Python identifiers: starting with a letter or underscore [a-zA-Z_], followed by letters, digits, or underscores [a-zA-Z0-9_], without spaces, hyphens, or other characters."
            },
            "selfingRate": {
                "type": "float$",
                "description": " The expected value of the fraction of children in the next generation that will be produced by selfing (as opposed to biparental mating).\u00a0 Selfing is only possible in non-sexual (i.e. hermaphroditic) simulations; for sexual simulations this property always has a value of 0.0."
            },
            "sexRatio": {
                "type": "float$",
                "description": " For sexual simulations, the sex ratio for the subpopulation.\u00a0 This is defined, in SLiM, as the fraction of the subpopulation that is male; in other words, it is actually the M:(M+F) ratio.\u00a0 For non-sexual (i.e. hermaphroditic) simulations, this property has an undefined value and should not be used."
            },
            "spatialMaps": {
                "type": "object<SpatialMap>",
                "description": " The spatial maps that are currently added to the subpopulation."
            },
            "spatialBounds": {
                "type": "float",
                "description": " The spatial boundaries of the subpopulation.\u00a0 The length of the spatialBounds property depends upon the spatial dimensionality declared with initializeSLiMOptions().\u00a0 If the spatial dimensionality is zero (as it is by default), the value of this property is float(0) (a zero-length float vector).\u00a0 Otherwise, minimums are supplied for each coordinate used by the dimensionality of the simulation, followed by maximums for each.\u00a0 In other words, if the declared dimensionality is \"xy\", the spatialBounds property will contain values (x0,\u00a0y0,\u00a0x1,\u00a0y1); bounds for the z coordinate will not be included in that case, since that coordinate is not used in the simulation\u2019s dimensionality.\u00a0 This property cannot be set, but the setSpatialBounds() method may be used to achieve the same thing."
            },
            "species": {
                "type": "object<Species>$",
                "description": " The species to which the target object belongs."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is initially undefined, and it is an error to try to read it; if you wish it to have a defined value, you must arrange that yourself by explicitly setting its value prior to using it elsewhere in your code.\u00a0 The value of tag is not used by SLiM; it is free for you to use.\u00a0 See also the getValue() and setValue() methods (provided by the Dictionary class; see the Eidos manual), for another way of attaching state to subpopulations."
            }
        }
    },
    "Substitution": {
        "constructor": {},
        "methods": {},
        "properties": {
            "id": {
                "type": "integer$",
                "description": " The identifier for this mutation.\u00a0 Each mutation created during a run receives an immutable identifier that will be unique across the duration of the run, and that identifier is carried over to the Substitution object when the mutation fixes."
            },
            "fixationTick": {
                "type": "integer$",
                "description": " The tick in which this mutation fixed."
            },
            "mutationType": {
                "type": "object<MutationType>$",
                "description": " The MutationType from which this mutation was drawn."
            },
            "nucleotide": {
                "type": "string$",
                "description": " A string representing the nucleotide associated with this mutation; this will be \"A\", \"C\", \"G\", or \"T\".\u00a0 If the mutation is not nucleotide-based, this property is unavailable."
            },
            "nucleotideValue": {
                "type": "integer$",
                "description": " An integer representing the nucleotide associated with this mutation; this will be 0 (A), 1 (C), 2 (G), or 3 (T).\u00a0 If the mutation is not nucleotide-based, this property is unavailable."
            },
            "originTick": {
                "type": "integer$",
                "description": " The tick in which this mutation arose."
            },
            "position": {
                "type": "integer$",
                "description": " The position in the chromosome of this mutation."
            },
            "selectionCoeff": {
                "type": "float$",
                "description": " The selection coefficient of the mutation, drawn from the distribution of fitness effects of its MutationType."
            },
            "subpopID": {
                "type": "integer$",
                "description": " The identifier of the subpopulation in which this mutation arose.\u00a0 This value is carried over from the Mutation object directly; if a \u201ctag\u201d value was used in the Mutation object, that value will carry over to the corresponding Substitution object.\u00a0 The subpopID in Substitution is a read-write property to allow it to be used as a \u201ctag\u201d in the same way, if the origin subpopulation identifier is not needed."
            },
            "tag": {
                "type": "integer$",
                "description": " A user-defined integer value.\u00a0 The value of tag is carried over automatically from the original Mutation object.\u00a0 Apart from that, the value of tag is not used by SLiM; it is free for you to use."
            }
        }
    }
}
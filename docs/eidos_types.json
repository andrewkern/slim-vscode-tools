{
    "integer": {
        "description": "The integer type is used in Eidos to represent integers \u2013 whole numbers, with no fractional component.\u00a0 Unlike in many languages, exponential notation may be used to specify integer literals (\u201cliterals\u201d means values stated literally in the script, rather than derived through calculations). The integer type is advantageous primarily because it is exact; it does not suffer from any sort of roundoff error. Exact comparison with integer constants is therefore safe; roundoff error will not lead to problems caused by 0.999999999 being deemed to be unequal to 1.\u00a0 However, integer is disadvantageous because it can only represent a limited range of values, and beyond that range, results will be unpredictable.\u00a0 Eidos uses 64 bits to store integer values, so that range is quite wide; to \u22129223372036854775806 to 9223372036854775807, to be exact.\u00a0 That is broad, but it is still enormously narrower than the range of numbers representable with float."
    },
    "float": {
        "description": "The float type is used in Eidos to represent all non-integer numbers \u2013 fractions and real numbers.\u00a0 Exponential notation may be used to specify float literals; in particular; literals with a decimal point or a negative exponent are taken to be of type float. Note that this rule means that some literals are represented using float even though they could also be represented using integer. The float type is advantageous primarily because it can represent an enormously wide range of values.\u00a0 Eidos uses C++\u2019s double type to represent its float values; the range of values allowed will depend upon your computer\u2019s settings, but it will be vast.\u00a0 If that range is exceeded, or if numerical problems occur, type float can also represent values as infinity or as \u201cNot A Number\u201d (INF and NAN, respectively, in Eidos).\u00a0 The float type is thus more robust for operations that might produce such values.\u00a0 The disadvantage of float is that it is inexact; some values cannot be represented exactly (just as 1/3 in base 10 cannot be represented exactly, and must be written as 0.3333333...).\u00a0 Roundoff can thus cause comparison errors, overflow and underflow errors, and the accumulation of numerical error. Several float constants are defined in Eidos; besides INF and NAN, PI is defined as \u03c0 (3.14159...), and E is defined as e (2.71828...)."
    },
    "logical": {
        "description": "The logical type represents true and false values, such as those from comparisons.\u00a0 In many languages this type is called something like boolean or BOOL; Eidos follows R in using the name logical instead. There are no logical literals in Eidos.\u00a0 However, there are defined constants that behave in essentially the same way as literals.\u00a0 In particular, T is defined as true, and F is defined as false.\u00a0 These are the only two values that the logical type can take.\u00a0 As in a great many other languages, these logical values have equivalent numerical values; F is 0, and T is 1 (and in fact any non-zero value is considered to be true if converted to logical type).\u00a0 Values of type integer or float may therefore be converted to logical, and vice-versa."
    },
    "string": {
        "description": "The string type represents a string of characters \u2013 a word, a sentence, a paragraph, the complete works of Shakespeare.\u00a0 There is no formatting on a string \u2013 no font, no point size, no bold or italic.\u00a0 Instead, it is just a character stream.\u00a0 A string literal must be enclosed by either single or double quotation marks, ' or \".\u00a0 This choice simplifies writing Eidos strings that themselves contain quote characters, because you can delimit the string with the opposite kind of quote.\u00a0 For example, 'You say, \"Ere thrice the sun done salutation to the dawn\"' is a string that contains double quotes, whereas \"Quoth the Raven, 'nevermore'.\u201d is a string that contains single quotes.\u00a0 Apart from this consideration, it does not matter whether you use single or double quotes; the internal representation is the same.\u00a0 The suggested convention is to prefer double quotes, all else being equal, since they are more universally used in other programming languages. A complication arises if one wishes to include both single and double quotation marks within a string; whichever delimiter you choose, one or the other quote character will terminate the string literal.\u00a0 In this case, the quotation mark must be \u201cescaped\u201d by preceding it with a backslash, \\.\u00a0 The backslash can be used to \u201cescape\u201d various other characters; to include a newline in a string, for example, use \\n, and to include a tab, use \\t.\u00a0 Since the backslash has this special meaning, backslashes themselves must be escaped as \\\\.\u00a0 An alternative to dealing with escape sequences is to use the \u201chere document\u201d style of string literal; see the Eidos manual for details on this."
    },
    "NULL": {
        "description": "The NULL type two primary uses: as a return value, and as a parameter. As a return value, NULL is used to indicate that a function had nothing useful to return.\u00a0 Some functions always return NULL, such as print(); print() sends its output directly to the Eidos console.\u00a0 It has nothing useful to return, so it returns NULL.\u00a0 (That NULL value does not normally get printed out by Eidos because it is marked as an \u201cinvisible\u201d return, a side topic not really worth getting into here; invisible returns work much as they do in R). Some functions will return a useful value if they can, but will return NULL if they can\u2019t. Often a NULL return is a result of passing NULL in as an argument; garbage in, garbage out, as they say.\u00a0 For example, the readFile() function will return NULL if an error occurs that prevents the file read operation from completing.\u00a0 The calling code could then detect that NULL return and act accordingly \u2013 it might try to read from a different path, print an error, or terminate execution with stop(), or it might just ignore the problem, if reading the file was optional anyway (such as an optional configuration file to modify the default behavior of a script). The other use of NULL, as mentioned above, is as an argument to a function. Passing NULL is occasionally a way of signaling that you don\u2019t want to supply a value for an argument, or that you want a default behavior from the function rather than telling it more specifically what to do. NULL cannot be an element of a vector of some other type; it cannot be used to mark missing or unknown values, for example.\u00a0 Instead, NULL is its own type of vector in Eidos, always of zero length.\u00a0 (There is also no NA value in Eidos like the one in R, while we\u2019re on the topic of marking missing values.\u00a0 Not having to worry about missing values makes Eidos substantially simpler and faster, and Eidos \u2013 unlike R \u2013 is not designed to be used for doing statistical analysis, so marking missing values is not expected to be important.\u00a0 Eidos does support NAN \u2013 Not A Number \u2013 values in float vectors, however, which could conceivably be used to mark missing values if necessary.) The basic philosophy of how Eidos handles NULL values in expressions and computations is that NULL in such situations represents a non-fatal error or an unknown value.\u00a0 If using the NULL value in some meaningful way could lead to potentially misleading or incorrect results, Eidos will generate a fatal error.\u00a0 The idea is to give Eidos code an opportunity to detect a NULL, and thus to catch and handle the non-fatal error; but if the code does not handle the NULL, using the NULL in further operations will result in a fatal error before the functioning of the code is seriously compromised.\u00a0 NULL values are thus a sort of third rail; there\u2019s a good reason they exist, but you have to be very careful around them.\u00a0 They are a bit like zero-valued pointers in C (NULL), C++ (nullptr), Objective-C (nil), and similar languages; they are widely used, but if you ever use one the wrong way it is an immediate and fatal error.\u00a0 For further details, please consult the Eidos manual."
    },
    "object": {
        "description": "In addition to logical, integer, float, string, and NULL, there is one more type in Eidos left to discuss: object.\u00a0 A variable of type object is a vector that contains elements; it is a container, a bag of stuff.\u00a0 In this way, it is similar to Eidos\u2019s other types; a float vector in Eidos contains floating-point elements, whereas an object vector contains object-elements (often just called \u201cobjects\u201d; whether one is referring to a single object-element or a vector of type object is generally clear from context).\u00a0 An object vector can also embody behavior: it has operations that it can perform using the elements it contains, which all belong to a class that defines the available behaviors.\u00a0 The object type in Eidos is thus similar to objects in other languages such as Java, C++, or R \u2013 except much more limited.\u00a0 In Eidos you cannot define your own object classes; you work only with the predefined object classes supplied by SLiM or whatever other Context you might be using Eidos within.\u00a0 These predefined object classes generally define Context-dependent object-elements related to the task performed by the Context; in SLiM, the classes are things such as mutations, genomic elements, and mutation types (described in SLiM\u2019s documentation).\u00a0 Eidos itself also supplies a few built-in object classes, notably Dictionary and Image. The behaviors of objects in Eidos manifest in two ways: objects can have properties (also called instance variables or member variables, in other languages) that can be read from and written to, and they can have methods (also called member functions, in other languages).\u00a0 The behavior of an object vector in Eidos is determined by the class of element the object contains; an Eidos object will always contain only one class of element (just as a float cannot contain string-elements, for example). Instances of particular object classes \u2013 particular kinds of objects \u2013 are obtained via built-in functions and/or global constants and variables.\u00a0 For example, in SLiM there is a global constant called sim that represents the simulated species as an instance of the Species class."
    }
}